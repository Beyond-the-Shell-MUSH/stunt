From 9364b8b144e65c474ce9729dd5254c11d118669a Mon Sep 17 00:00:00 2001
From: Steve Wainstead <wainstead@gmail.com>
Date: Mon, 8 Jun 2009 03:50:47 +0000
Subject: [PATCH 012/223] Casts all around to satisfy the compiler.

---
 server/parser.y |   22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/server/parser.y b/server/parser.y
index 16e5581..8a66939 100644
--- a/server/parser.y
+++ b/server/parser.y
@@ -343,12 +343,12 @@ expr:
 		}
 	| tFLOAT
 		{
-		    $$ = alloc_var(TYPE_FLOAT);
+                  $$ = alloc_var((var_type)TYPE_FLOAT);
 		    $$->e.var.v.fnum = $1;
 		}
 	| tSTRING
 		{
-		    $$ = alloc_var(TYPE_STR);
+                  $$ = alloc_var((var_type)TYPE_STR);
 		    $$->e.var.v.str = $1;
 		}
 	| tOBJECT
@@ -370,7 +370,7 @@ expr:
 		{
 		    /* Treat $foo like #0.("foo") */
 		    Expr *obj = alloc_var(TYPE_OBJ);
-		    Expr *prop = alloc_var(TYPE_STR);
+		    Expr *prop = alloc_var((var_type)TYPE_STR);
 		    obj->e.var.v.obj = 0;
 		    prop->e.var.v.str = $2;
 		    $$ = alloc_binary(EXPR_PROP, obj, prop);
@@ -378,7 +378,7 @@ expr:
 	| expr '.' tID
 		{
 		    /* Treat foo.bar like foo.("bar") for simplicity */
-		    Expr *prop = alloc_var(TYPE_STR);
+		    Expr *prop = alloc_var((var_type)TYPE_STR);
 		    prop->e.var.v.str = $3;
 		    $$ = alloc_binary(EXPR_PROP, $1, prop);
 		}
@@ -389,7 +389,7 @@ expr:
 	| expr ':' tID '(' arglist ')'
 		{
 		    /* treat foo:bar(args) like foo:("bar")(args) */
-		    Expr *verb = alloc_var(TYPE_STR);
+		    Expr *verb = alloc_var((var_type)TYPE_STR);
 		    verb->e.var.v.str = $3;
 		    $$ = alloc_verb($1, verb, $5);
 		}
@@ -397,7 +397,7 @@ expr:
 		{
 		    /* treat $bar(args) like #0:("bar")(args) */
 		    Expr *obj = alloc_var(TYPE_OBJ);
-		    Expr *verb = alloc_var(TYPE_STR);
+		    Expr *verb = alloc_var((var_type)TYPE_STR);
 		    obj->e.var.v.obj = 0;
 		    verb->e.var.v.str = $2;
 		    $$ = alloc_verb(obj, verb, $4);
@@ -462,7 +462,7 @@ expr:
 		    $$ = alloc_expr(EXPR_CALL);
 		    if ((f_no = number_func_by_name($1)) == FUNC_NOT_FOUND) {
 			/* Replace with call_function("$1", @args) */
-			Expr	       *fname = alloc_var(TYPE_STR);
+			Expr	       *fname = alloc_var((var_type)TYPE_STR);
 			Arg_List       *a = alloc_arg_list(ARG_NORMAL, fname);
 
 			fname->e.var.v.str = $1;
@@ -579,7 +579,7 @@ expr:
 	| '`' expr '!' codes default '\''
 		{
 		    $$ = alloc_expr(EXPR_CATCH);
-		    $$->e._catch.try = $2;
+		    $$->e._catch._try = $2;
 		    $$->e._catch.codes = $4;
 		    $$->e._catch.except = $5;
 		}
@@ -1021,7 +1021,7 @@ static struct loop_entry *loop_stack;
 static void
 push_loop_name(const char *name)
 {
-    struct loop_entry  *entry = mymalloc(sizeof(struct loop_entry), M_AST);
+    struct loop_entry *entry = (loop_entry *) mymalloc(sizeof(struct loop_entry), M_AST);
 
     entry->next = loop_stack;
     entry->name = (name ? str_dup(name) : 0);
@@ -1049,7 +1049,7 @@ pop_loop_name(void)
 static void
 suspend_loop_scope(void)
 {
-    struct loop_entry  *entry = mymalloc(sizeof(struct loop_entry), M_AST);
+    struct loop_entry *entry = (loop_entry *) mymalloc(sizeof(struct loop_entry), M_AST);
 
     entry->next = loop_stack;
     entry->name = 0;
@@ -1185,7 +1185,7 @@ my_error(void *data, const char *msg)
     struct parser_state	*state = (struct parser_state *) data;
     Var			v;
     
-    v.type = TYPE_STR;
+    v.type = (var_type)TYPE_STR;
     v.v.str = str_dup(msg);
     state->errors = listappend(state->errors, v);
 }
-- 
1.7.9.5

