From 2614bb1e953c3bf737254068cb8dfcf9c16aa29a Mon Sep 17 00:00:00 2001
From: Steve Wainstead <wainstead@gmail.com>
Date: Sun, 17 Jul 2011 05:30:49 +0000
Subject: [PATCH 176/223] Two file-wide changes, and one small one:

1) Renamed the struct file_type to fileio_file_type, to get around a
compiler complaint about the struct and the typedef having the same
name.

2) Mass changed "if(" to "if (", "while(" to "while ("

3) Qualifed BI_RAISE to p.BI_RAISE to fix a compile error
---
 server/extension-fileio.c |  256 ++++++++++++++++++++++-----------------------
 1 file changed, 128 insertions(+), 128 deletions(-)

diff --git a/server/extension-fileio.c b/server/extension-fileio.c
index 64e7be4..eeb1f88 100644
--- a/server/extension-fileio.c
+++ b/server/extension-fileio.c
@@ -72,7 +72,7 @@ typedef unsigned short umode_t;
 const char *raw_bytes_to_clean(const char *buffer, int buflen) {
   static Stream *s = 0;
   int i;
-  if(!s) 
+  if (!s) 
 	 s = new_stream(100);
 
   for (i = 0; i < buflen; i++) {
@@ -100,9 +100,9 @@ const char *clean_to_raw_bytes(const char *buffer, int *buflen) {
  *  File types are either TEXT or BINARY
  */
 
-typedef struct file_type *file_type;
+typedef struct fileio_file_type *file_type;
 
-struct file_type { 
+struct fileio_file_type { 
     
   const char* (*in_filter)(const char *data, int buflen);
 
@@ -110,8 +110,8 @@ struct file_type {
 
 };
 
-file_type file_type_binary = NULL;
-file_type file_type_text = NULL;
+fileio_file_type file_type_binary;
+fileio_file_type file_type_text;
 
 
 
@@ -126,7 +126,7 @@ typedef struct file_handle file_handle;
 struct file_handle {
   char  valid;               /* Is this a valid entry?   */
   char *name;                /* pathname of the file     */
-  file_type type;            /* text or binary, sir?     */
+  fileio_file_type type;            /* text or binary, sir?     */
   file_mode mode;            /* readin', writin' or both */
  
   FILE  *file;               /* the actual file handle   */  
@@ -163,9 +163,9 @@ file_handle file_table[FILE_IO_MAX_FILES];
 
 char file_handle_valid(Var fhandle) {
   int32 i = fhandle.v.num;
-  if(fhandle.type != TYPE_INT)
+  if (fhandle.type != TYPE_INT)
 	 return 0;
-  if((i < 0) || (i >= FILE_IO_MAX_FILES))
+  if ((i < 0) || (i >= FILE_IO_MAX_FILES))
 	 return 0;
   return file_table[i].valid;
 }
@@ -181,7 +181,7 @@ const char *file_handle_name(Var fhandle) {
   return file_table[i].name;
 }
 
-file_type file_handle_type(Var fhandle) {
+fileio_file_type file_handle_type(Var fhandle) {
   int32 i = fhandle.v.num;
   return file_table[i].type;
 }  
@@ -204,20 +204,20 @@ int32 file_allocate_next_handle(void) {
   static int32 current_handle = 0;
   int32 wrapped = current_handle;
 
-  if(current_handle > FILE_IO_MAX_FILES)
+  if (current_handle > FILE_IO_MAX_FILES)
 	 wrapped = current_handle = 0;
 
-  while(current_handle < FILE_IO_MAX_FILES) {
-	 if(!file_table[current_handle].valid)
+  while (current_handle < FILE_IO_MAX_FILES) {
+	 if (!file_table[current_handle].valid)
 		break;
 
 	 current_handle++;
-	 if(current_handle > FILE_IO_MAX_FILES)
+	 if (current_handle > FILE_IO_MAX_FILES)
 		current_handle = 0;
-	 if(current_handle == wrapped)
+	 if (current_handle == wrapped)
 		current_handle = FILE_IO_MAX_FILES;
   }
-  if(current_handle == FILE_IO_MAX_FILES) {
+  if (current_handle == FILE_IO_MAX_FILES) {
 	 current_handle = 0;
 	 return -1;
   }
@@ -225,14 +225,14 @@ int32 file_allocate_next_handle(void) {
 }
 
 
-Var file_handle_new(const char *name, file_type type, file_mode mode) {
+Var file_handle_new(const char *name, fileio_file_type type, file_mode mode) {
   Var r;
   int32 handle = file_allocate_next_handle();
   
   r.type = TYPE_INT;
   r.v.num = handle;
 
-  if(handle >= 0) {
+  if (handle >= 0) {
 	 file_table[handle].valid = 1;
 	 file_table[handle].name = str_dup(name);
 	 file_table[handle].type = type;
@@ -248,7 +248,7 @@ void file_handle_set_file(Var fhandle, FILE *f) {
 }
 
 /***************************************************************
- * Interface for modestrings
+` * Interface for modestrings
  ***************************************************************/
 
 /*
@@ -257,15 +257,15 @@ void file_handle_set_file(Var fhandle, FILE *f) {
  *  NULL if not.
  */ 
 
-const char *file_modestr_to_mode(const char *s, file_type *type, file_mode *mode) {
+const char *file_modestr_to_mode(const char *s, fileio_file_type *type, file_mode *mode) {
   static char buffer[4] = {0, 0, 0, 0};
   int p = 0;
-  file_type t;
+  fileio_file_type t;
   file_mode m = 0;
 
-  if(!file_type_binary) {
-	 file_type_binary = mymalloc(sizeof(struct file_type), M_STRING);
-	 file_type_text= mymalloc(sizeof(struct file_type), M_STRING);
+  if (!file_type_binary) {
+	 file_type_binary = mymalloc(sizeof(struct fileio_file_type), M_STRING);
+	 file_type_text= mymalloc(sizeof(struct fileio_file_type), M_STRING);
 	 file_type_binary->in_filter = raw_bytes_to_binary;
 	 file_type_binary->out_filter = binary_to_raw_bytes;
 	 file_type_text->in_filter = raw_bytes_to_clean;
@@ -273,33 +273,33 @@ const char *file_modestr_to_mode(const char *s, file_type *type, file_mode *mode
   }
 
   
-  if(strlen(s) != 4)
+  if (strlen(s) != 4)
 	 return 0;
   
-  if(s[0] == 'r')           m |= FILE_O_READ;
-  else if(s[0] == 'w')      m |= FILE_O_WRITE;
-  else if(s[0] == 'a')      m |= FILE_O_WRITE;
+  if (s[0] == 'r')           m |= FILE_O_READ;
+  else if (s[0] == 'w')      m |= FILE_O_WRITE;
+  else if (s[0] == 'a')      m |= FILE_O_WRITE;
   else 
 	 return NULL;
   
   
   buffer[p++] = s[0];
   
-  if(s[1] == '+') {
+  if (s[1] == '+') {
 	 m |= (s[0] == 'r') ? FILE_O_WRITE : FILE_O_READ;
 	 buffer[p++] = '+';
   } else if (s[1] != '-') {
 	 return NULL;
   }
 
-  if(s[2] == 't')            t = file_type_text;
+  if (s[2] == 't')            t = file_type_text;
   else if (s[2] == 'b') {
 	 t = file_type_binary;
 	 buffer[p++] = 'b';
   } else
 	 return NULL;
 
-  if(s[3] == 'f')            m |= FILE_O_FLUSH;
+  if (s[3] == 'f')            m |= FILE_O_FLUSH;
   else if (s[3] != 'n')
 	 return NULL;
 
@@ -321,7 +321,7 @@ file_make_error(const char *errtype, const char *msg) {
   value.type = TYPE_STR;
   value.v.str = str_dup(errtype);
 
-  p.kind = BI_RAISE;
+  p.kind = p.BI_RAISE;
   p.u.raise.code.type = TYPE_STR;
   p.u.raise.code.v.str = str_dup("E_FILE");
   p.u.raise.msg = str_dup(msg);
@@ -333,7 +333,7 @@ file_make_error(const char *errtype, const char *msg) {
 package file_raise_errno(const char *value_str) {
   char *strerr;
   
-  if(errno) {
+  if (errno) {
 	 strerr = strerror(errno);
 	 return file_make_error(value_str, strerr);
   }  else {
@@ -368,13 +368,13 @@ int file_verify_path(const char *pathname) {
    *  any of instances the substring "/."
    */
 
-  if(pathname[0] == '\0')
+  if (pathname[0] == '\0')
 	 return 1;
 
-  if((strlen(pathname) > 1) && (pathname[0] == '.') && (pathname[1] == '.'))
+  if ((strlen(pathname) > 1) && (pathname[0] == '.') && (pathname[1] == '.'))
 		return 0;
 
-  if(strindex(pathname, "/.", 0))
+  if (strindex(pathname, "/.", 0))
 		return 0;
   
   return 1;
@@ -385,14 +385,14 @@ int file_verify_path(const char *pathname) {
  **************************************************************/
 
 FILE *file_handle_file_safe(Var handle) {
-  if(!file_handle_valid(handle))
+  if (!file_handle_valid(handle))
 	 return NULL;
   else
 	 return file_handle_file(handle);
 }
 
 const char *file_handle_name_safe(Var handle) {
-  if(!file_handle_valid(handle))
+  if (!file_handle_valid(handle))
 	 return NULL;
   else
 	 return file_handle_name(handle);
@@ -405,14 +405,14 @@ const char *file_handle_name_safe(Var handle) {
 const char *file_resolve_path(const char *pathname) {
   static Stream *s = 0;
   
-  if(!s)
+  if (!s)
 	 s = new_stream(strlen(pathname) + strlen(FILE_SUBDIR) + 1);
   
-  if(!file_verify_path(pathname))
+  if (!file_verify_path(pathname))
 	 return NULL;
   
   stream_add_string(s, FILE_SUBDIR);
-  if(pathname[0] == '/')
+  if (pathname[0] == '/')
 	 stream_add_string(s, pathname + 1);
   else
 	 stream_add_string(s, pathname);
@@ -461,10 +461,10 @@ bf_file_open(Var arglist, Byte next, void *vdata, Objid progr)
   const char *mode = arglist.v.list[2].v.str;
   const char *fmode;
   file_mode rmode;
-  file_type type;
+  fileio_file_type type;
   FILE *f;
 
-  if(!file_verify_caller(progr))
+  if (!file_verify_caller(progr))
 	 r = file_raise_notokcall("file_open", progr);
   else if ((real_filename = file_resolve_path(filename)) == NULL)
 	 r = file_raise_notokfilename("file_open", filename);
@@ -495,7 +495,7 @@ bf_file_close(Var arglist, Byte next, void *vdata, Objid progr)
   Var fhandle = arglist.v.list[1];
   FILE *f;
 
-  if(!file_verify_caller(progr))
+  if (!file_verify_caller(progr))
 	 r = file_raise_notokcall("file_close", progr);
   else if ((f = file_handle_file_safe(fhandle)) == NULL)
 	 r = make_raise_pack(E_INVARG, "Invalid FHANDLE", fhandle);
@@ -520,7 +520,7 @@ bf_file_name(Var arglist, Byte next, void *vdata, Objid progr)
   const char *name;
   Var rv;   
 
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_name", progr);
   } else if ((name = file_handle_name_safe(fhandle)) == NULL) {
 	 r = make_raise_pack(E_INVARG, "Invalid FHANDLE", fhandle);
@@ -540,32 +540,32 @@ bf_file_openmode(Var arglist, Byte next, void *vdata, Objid progr)
   Var fhandle = arglist.v.list[1];
   char buffer[5] = {0, 0, 0, 0, 0};
   file_mode mode;
-  file_type type;
+  fileio_file_type type;
   Var rv;   
 
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_name", progr);
   } else if (!file_handle_valid(fhandle)) {
 	 r = make_raise_pack(E_INVARG, "Invalid FHANDLE", fhandle);
   } else {
 	 type = file_handle_type(fhandle);
 	 mode = file_handle_mode(fhandle);
-	 if(mode & FILE_O_READ) {
+	 if (mode & FILE_O_READ) {
 		buffer[0] = 'r';
-	 } else if(mode & FILE_O_WRITE) {
+	 } else if (mode & FILE_O_WRITE) {
 		buffer[0] = 'w';
 	 }
-	 if(mode & (FILE_O_READ | FILE_O_WRITE))
+	 if (mode & (FILE_O_READ | FILE_O_WRITE))
 		buffer[1] = '+';
 	 else
 		buffer[1] = '-';
 
-	 if(type == file_type_binary)
+	 if (type == file_type_binary)
 		buffer[2] = 'b';
 	 else
 		buffer[2] = 't';
 	 
-	 if(mode & FILE_O_FLUSH)
+	 if (mode & FILE_O_FLUSH)
 		buffer[3] = 'f';
 	 else
 		buffer[3] = 'n';
@@ -598,12 +598,12 @@ static const char *file_read_line(Var fhandle, int *count) {
 
   f = file_handle_file(fhandle);
   
-  if(str == 0)
+  if (str == 0)
 	 str = new_stream(FILE_IO_BUFFER_LENGTH);
   
  try_again:
 
-  if(fgets(buffer, sizeof(buffer), f) == NULL) {
+  if (fgets(buffer, sizeof(buffer), f) == NULL) {
 	 
 	 /* Yes, this means it's an error to read an incomplete line
 	  * at the end of a file.  No magic vanishing \n's.
@@ -611,7 +611,7 @@ static const char *file_read_line(Var fhandle, int *count) {
 	  * it shouldn't be possible read one.
 	  */
 	 
-	 if(used_stream) 
+	 if (used_stream) 
 		reset_stream(str);
 	 rv = NULL;
   } else {
@@ -619,16 +619,16 @@ static const char *file_read_line(Var fhandle, int *count) {
 
 	 total_len += len;
 
-	 if(len == sizeof(buffer) - 1 && buffer[len - 1] != '\n') {
+	 if (len == sizeof(buffer) - 1 && buffer[len - 1] != '\n') {
 		used_stream = 1;
 		stream_add_string(str, buffer);
 		goto try_again;
 	 }
 	 
-	 if(buffer[len - 1] == '\n')
+	 if (buffer[len - 1] == '\n')
 		buffer[len-1] = '\0';
 	 
-	 if(used_stream) {
+	 if (used_stream) {
 		stream_add_string(str, buffer);
 		rv = reset_stream(str);
 	 } else {
@@ -652,10 +652,10 @@ bf_file_readline(Var arglist, Byte next, void *vdata, Objid progr)
   Var rv;
   int len;
   file_mode mode;
-  file_type type;
+  fileio_file_type type;
   const char *line;
 
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_readline", progr);
   } else if (!file_handle_valid(fhandle)) {
 	 r = make_raise_pack(E_INVARG, "Invalid FHANDLE", fhandle);
@@ -663,7 +663,7 @@ bf_file_readline(Var arglist, Byte next, void *vdata, Objid progr)
 	 r = make_raise_pack(E_INVARG, "File is open write-only", fhandle);
   else {
 	 type = file_handle_type(fhandle);
-	 if((line = file_read_line(fhandle, &len)) == NULL)
+	 if ((line = file_read_line(fhandle, &len)) == NULL)
 		r = file_raise_errno("readline");
 	 else {		
 		rv.type = TYPE_STR;
@@ -681,13 +681,13 @@ bf_file_readline(Var arglist, Byte next, void *vdata, Objid progr)
 
 void free_line_buffer(line_buffer *head, int strings_too) {
   line_buffer *next;
-  if(head) {
+  if (head) {
 	 next = head->next;
 	 free(head);
 	 head = next;
-	 while(head != NULL) {
+	 while (head != NULL) {
 		next = head->next;
-		if(strings_too)
+		if (strings_too)
 		  free_str(head->line);
 		myfree(head, M_STRING);
 		head = next;
@@ -710,7 +710,7 @@ bf_file_readlines(Var arglist, Byte next, void *vdata, Objid progr)
   int32 begin = arglist.v.list[2].v.num;
   int32 end   = arglist.v.list[3].v.num;
   int32 begin_loc = 0, linecount = 0;
-  file_type type;
+  fileio_file_type type;
   file_mode mode;
   Var rv;
   int current_line = 0, len = 0, i = 0;
@@ -719,9 +719,9 @@ bf_file_readlines(Var arglist, Byte next, void *vdata, Objid progr)
   line_buffer *linebuf_head = NULL, *linebuf_cur = NULL;
   
   
-  if((begin < 1) || (begin > end))
+  if ((begin < 1) || (begin > end))
 	 return make_error_pack(E_INVARG);
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_readlines", progr);
   } else if ((f = file_handle_file_safe(fhandle)) == NULL) {
 	 r = make_raise_pack(E_INVARG, "Invalid FHANDLE", fhandle);
@@ -734,11 +734,11 @@ bf_file_readlines(Var arglist, Byte next, void *vdata, Objid progr)
 
 	 /* "seek" to that line */
 	 begin--;
-	 while((current_line != begin) 
+	 while ((current_line != begin) 
 			 && ((line = file_read_line(fhandle, &len)) != NULL)) 
 		current_line++;	
 	 
-	 if(((begin != 0) && (line == NULL)) || ((begin_loc = ftell(f)) == -1))
+	 if (((begin != 0) && (line == NULL)) || ((begin_loc = ftell(f)) == -1))
 		r = file_raise_errno("read_line");
 	 else {
 		type = file_handle_type(fhandle);
@@ -750,7 +750,7 @@ bf_file_readlines(Var arglist, Byte next, void *vdata, Objid progr)
 		
 		linebuf_head = linebuf_cur = new_line_buffer(NULL);
 		
-		while((current_line != end) 
+		while ((current_line != end) 
 				&& ((line = file_read_line(fhandle, &len)) != NULL)) {
 		  linebuf_cur->next = new_line_buffer(str_dup((type->in_filter)(line, len)));
 		  linebuf_cur = linebuf_cur->next;
@@ -761,13 +761,13 @@ bf_file_readlines(Var arglist, Byte next, void *vdata, Objid progr)
 
 		linebuf_cur = linebuf_head->next;
 
-		if(fseek(f, begin_loc, SEEK_SET) == -1) {
+		if (fseek(f, begin_loc, SEEK_SET) == -1) {
 		  free_line_buffer(linebuf_head, 1);
 		  r = file_raise_errno("seeking");
 		} else {
 		  rv = new_list(linecount);		  
 		  i = 1;
-		  while(linebuf_cur != NULL) {
+		  while (linebuf_cur != NULL) {
 			 rv.v.list[i].type = TYPE_STR;
 			 rv.v.list[i].v.str = linebuf_cur->line;
 			 linebuf_cur = linebuf_cur->next;
@@ -795,10 +795,10 @@ bf_file_writeline(Var arglist, Byte next, void *vdata, Objid progr)
   const char *buffer = arglist.v.list[2].v.str;
   int len;
   file_mode mode;
-  file_type type;
+  fileio_file_type type;
   FILE *f;
 
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_writeline", progr);
   } else if ((f = file_handle_file_safe(fhandle)) == NULL) {
 	 r = make_raise_pack(E_INVARG, "Invalid FHANDLE", fhandle);
@@ -806,10 +806,10 @@ bf_file_writeline(Var arglist, Byte next, void *vdata, Objid progr)
 	 r = make_raise_pack(E_INVARG, "File is open read-only", fhandle);
   else {
 	 type = file_handle_type(fhandle);
-	 if((fputs((type->out_filter)(buffer, &len), f) == EOF) || (fputc('\n', f) != '\n'))
+	 if ((fputs((type->out_filter)(buffer, &len), f) == EOF) || (fputc('\n', f) != '\n'))
 		r = file_raise_errno(file_handle_name(fhandle));
 	 else {
-		  if(mode & FILE_O_FLUSH) {
+		  if (mode & FILE_O_FLUSH) {
 			/*	printf("flushing...\n"); */
 				fflush(f);
 		  }
@@ -837,15 +837,15 @@ bf_file_send(Var arglist, Byte next, void *vdata, Objid progr)
   int read = 0, total_sent = 0;
 
     
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_send", progr);
-  } else if((real_filename = file_resolve_path(filename)) == NULL) {
+  } else if ((real_filename = file_resolve_path(filename)) == NULL) {
 	 r =  file_raise_notokfilename("file_send", filename);
   } else {
-	 if((f = fopen(real_filename, "rb")) == NULL) {
+	 if ((f = fopen(real_filename, "rb")) == NULL) {
 		return file_raise_errno("file_send");
 	 } else {
-		while((read = fread(buffer, sizeof(char), sizeof(buffer), f))) {
+		while ((read = fread(buffer, sizeof(char), sizeof(buffer), f))) {
 		  total_sent += read;
 		  notify_bytes(victim, buffer, read);
 		}
@@ -875,7 +875,7 @@ bf_file_read(Var arglist, Byte next, void *vdata, Objid progr)
 
   Var fhandle = arglist.v.list[1];
   file_mode mode;
-  file_type type;
+  fileio_file_type type;
   int32 record_length = arglist.v.list[2].v.num;
   int32 read_length;
 
@@ -890,10 +890,10 @@ bf_file_read(Var arglist, Byte next, void *vdata, Objid progr)
 
   read_length = (record_length > sizeof(buffer)) ? sizeof(buffer) : record_length;
 
-  if(str == 0)
+  if (str == 0)
 	 str = new_stream(FILE_IO_BUFFER_LENGTH);
 
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_read", progr);
   } else if ((f = file_handle_file_safe(fhandle)) == NULL) {
 	 r = make_raise_pack(E_INVARG, "Invalid FHANDLE", fhandle);
@@ -904,7 +904,7 @@ bf_file_read(Var arglist, Byte next, void *vdata, Objid progr)
 
   try_again:
 	 read = fread(buffer, sizeof(char), read_length, f);
-	 if(!read && !len) {
+	 if (!read && !len) {
 		/* 
 		 * No more to read.  This is only an error if nothing
 		 * has been read so far.
@@ -948,12 +948,12 @@ bf_file_flush(Var arglist, Byte next, void *vdata, Objid progr)
   Var fhandle = arglist.v.list[1];
   FILE *f;
 
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_flush", progr);
   } else if ((f = file_handle_file_safe(fhandle)) == NULL) {
 	 r = make_raise_pack(E_INVARG, "Invalid FHANDLE", fhandle);
   } else {
-	 if(fflush(f))
+	 if (fflush(f))
 		r = file_raise_errno("flushing");
 	 else
 		r = no_var_pack();
@@ -975,12 +975,12 @@ bf_file_write(Var arglist, Byte next, void *vdata, Objid progr)
   const char *buffer = arglist.v.list[2].v.str;
   const char *rawbuffer;
   file_mode mode;
-  file_type type;
+  fileio_file_type type;
   int len;
   int written;
   FILE *f;
 
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_write", progr);
   } else if ((f = file_handle_file_safe(fhandle)) == NULL) {
 	 r = make_raise_pack(E_INVARG, "Invalid FHANDLE", fhandle);
@@ -990,10 +990,10 @@ bf_file_write(Var arglist, Byte next, void *vdata, Objid progr)
 	 type = file_handle_type(fhandle);
 	 rawbuffer = (type->out_filter)(buffer, &len);
 	 written = fwrite(rawbuffer, sizeof(char), len, f);
-	 if(!written)
+	 if (!written)
 		r = file_raise_errno(file_handle_name(fhandle));
 	 else {
-		if(mode & FILE_O_FLUSH)
+		if (mode & FILE_O_FLUSH)
 		  fflush(f);
 		rv.type = TYPE_INT;
 		rv.v.num = written;
@@ -1024,7 +1024,7 @@ bf_file_seek(Var arglist, Byte next, void *vdata, Objid progr)
   int whnce = 0, whence_ok = 1;
   FILE *f;
 
-  if(!mystrcasecmp(whence, "SEEK_SET"))
+  if (!mystrcasecmp(whence, "SEEK_SET"))
 	 whnce = SEEK_SET;
   else if (!mystrcasecmp(whence, "SEEK_CUR"))
 	 whnce = SEEK_CUR;
@@ -1033,14 +1033,14 @@ bf_file_seek(Var arglist, Byte next, void *vdata, Objid progr)
   else 
 	 whence_ok = 0;
 
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_seek", progr);
   } else if ((f = file_handle_file_safe(fhandle)) == NULL) {
 	 r = make_raise_pack(E_INVARG, "Invalid FHANDLE", var_ref(fhandle));
   } else if (!whence_ok) {
 	 r = make_raise_pack(E_INVARG, "Invalid whence", zero);
   } else {
-	 if(fseek(f, seek_to, whnce))
+	 if (fseek(f, seek_to, whnce))
 		r = file_raise_errno(file_handle_name(fhandle));		
 	 else
 		r = no_var_pack();
@@ -1061,13 +1061,13 @@ bf_file_tell(Var arglist, Byte next, void *vdata, Objid progr)
   Var rv;
   FILE *f;
 
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_tell", progr);
   } else if ((f = file_handle_file_safe(fhandle)) == NULL) {
 	 r = make_raise_pack(E_INVARG, "Invalid FHANDLE", var_ref(fhandle));
   } else {
 	 rv.type = TYPE_INT;
-	 if((rv.v.num = ftell(f)) < 0)
+	 if ((rv.v.num = ftell(f)) < 0)
 		r = file_raise_errno(file_handle_name(fhandle));		
 	 else
 		r = make_var_pack(rv);
@@ -1088,7 +1088,7 @@ bf_file_eof(Var arglist, Byte next, void *vdata, Objid progr)
   Var rv;
   FILE *f;
 
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_eof", progr);
   } else if ((f = file_handle_file_safe(fhandle)) == NULL) {
 	 r = make_raise_pack(E_INVARG, "Invalid FHANDLE", var_ref(fhandle));
@@ -1112,16 +1112,16 @@ bf_file_eof(Var arglist, Byte next, void *vdata, Objid progr)
 int file_stat(Objid progr, Var filespec, package *r, struct stat *buf) {
   int statok = 0;
   
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 *r = file_raise_notokcall("file_stat", progr);
   } else if (filespec.type == TYPE_STR) {
 	 const char *filename = filespec.v.str;
 	 const char *real_filename;
 
-	 if((real_filename = file_resolve_path(filename)) == NULL) {
+	 if ((real_filename = file_resolve_path(filename)) == NULL) {
 		*r =  file_raise_notokfilename("file_stat", filename);
 	 } else {
-		if(stat(real_filename, buf) != 0)		  
+		if (stat(real_filename, buf) != 0)		  
 		  *r = file_raise_errno(filename);
 		else {
 		  statok = 1;
@@ -1129,10 +1129,10 @@ int file_stat(Objid progr, Var filespec, package *r, struct stat *buf) {
 	 }
   } else {
 	 FILE *f;
-	 if((f = file_handle_file_safe(filespec)) == NULL)
+	 if ((f = file_handle_file_safe(filespec)) == NULL)
 		*r = make_raise_pack(E_INVARG, "Invalid FHANDLE", filespec);
 	 else {
-		if(fstat(fileno(f), buf) != 0)
+		if (fstat(fileno(f), buf) != 0)
 		  *r = file_raise_errno(file_handle_name(filespec));
 		else {
 		  statok = 1;
@@ -1142,8 +1142,8 @@ int file_stat(Objid progr, Var filespec, package *r, struct stat *buf) {
   return statok;
 }
 
-const char *file_type_string(umode_t st_mode) {
-  if(S_ISREG(st_mode))
+const char *fileio_file_type_string(umode_t st_mode) {
+  if (S_ISREG(st_mode))
 	 return "reg";
   else if (S_ISDIR(st_mode))
 	 return "dir";
@@ -1159,7 +1159,7 @@ const char *file_type_string(umode_t st_mode) {
 
 const char *file_mode_string(umode_t st_mode) {
   static Stream *s = 0;
-  if(!s)
+  if (!s)
 	 s = new_stream(4);
   stream_printf(s, "%03o", st_mode & 0777);
   return reset_stream(s);
@@ -1345,7 +1345,7 @@ bf_file_stat(Var arglist, Byte next, void *vdata, Objid progr)
 int file_list_select(const struct dirent *d) {
   const char *name = d->d_name;
   int l = strlen(name);
-  if((l == 1) && (name[0] == '.'))
+  if ((l == 1) && (name[0] == '.'))
 	 return 0;
   else if ((l == 2) && (name[0] == '.') && (name[1] == '.'))
 	 return 0;
@@ -1366,9 +1366,9 @@ bf_file_list(Var arglist, Byte next, void *vdata, Objid progr)
 						? is_true(arglist.v.list[2])
 						: 0);
   
-    if(!file_verify_caller(progr)) {
+    if (!file_verify_caller(progr)) {
         r = file_raise_notokcall("file_list", progr);
-    } else if((real_pathname = file_resolve_path(pathspec)) == NULL) {
+    } else if ((real_pathname = file_resolve_path(pathspec)) == NULL) {
         r =  file_raise_notokfilename("file_list", pathspec);
     } else {
         DIR *curdir;
@@ -1409,7 +1409,7 @@ bf_file_list(Var arglist, Byte next, void *vdata, Objid progr)
 			rv = listappend(rv, detail);
 		    }
 		}
-		if(failed) {
+		if (failed) {
 			free_var(rv);
 			r = file_raise_errno(pathspec);
 		} else
@@ -1434,12 +1434,12 @@ bf_file_mkdir(Var arglist, Byte next, void *vdata, Objid progr)
   const char *pathspec = arglist.v.list[1].v.str;
   const char *real_pathname;
 
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_mkdir", progr);
-  } else if((real_pathname = file_resolve_path(pathspec)) == NULL) {
+  } else if ((real_pathname = file_resolve_path(pathspec)) == NULL) {
 	 r =  file_raise_notokfilename("file_mkdir", pathspec);
   } else {
-	 if(mkdir(real_pathname, 0777) != 0) 
+	 if (mkdir(real_pathname, 0777) != 0) 
 		r = file_raise_errno(pathspec);
 	 else 
 		r = no_var_pack();
@@ -1460,12 +1460,12 @@ bf_file_rmdir(Var arglist, Byte next, void *vdata, Objid progr)
   const char *pathspec = arglist.v.list[1].v.str;
   const char *real_pathname;
 
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_rmdir", progr);
-  } else if((real_pathname = file_resolve_path(pathspec)) == NULL) {
+  } else if ((real_pathname = file_resolve_path(pathspec)) == NULL) {
 	 r =  file_raise_notokfilename("file_rmdir", pathspec);
   } else {
-	 if(rmdir(real_pathname) != 0)
+	 if (rmdir(real_pathname) != 0)
 		r = file_raise_errno(pathspec);
 	 else 
 		r = no_var_pack();
@@ -1486,12 +1486,12 @@ bf_file_remove(Var arglist, Byte next, void *vdata, Objid progr)
   const char *pathspec = arglist.v.list[1].v.str;
   const char *real_pathname;
 
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_remove", progr);
-  } else if((real_pathname = file_resolve_path(pathspec)) == NULL) {
+  } else if ((real_pathname = file_resolve_path(pathspec)) == NULL) {
 	 r =  file_raise_notokfilename("file_remove", pathspec);
   } else {
-	 if(remove(real_pathname) != 0)
+	 if (remove(real_pathname) != 0)
 		r = file_raise_errno(pathspec);
 	 else 
 		r = no_var_pack();	 
@@ -1513,19 +1513,19 @@ bf_file_rename(Var arglist, Byte next, void *vdata, Objid progr)
   char *real_fromspec = NULL;
   const char *real_tospec;
   
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_rename", progr);
-  } else if((real_fromspec = str_dup(file_resolve_path(fromspec))) == NULL) {
+  } else if ((real_fromspec = str_dup(file_resolve_path(fromspec))) == NULL) {
 	 r =  file_raise_notokfilename("file_rename", fromspec);
-  } else if((real_tospec = file_resolve_path(tospec)) == NULL) {
+  } else if ((real_tospec = file_resolve_path(tospec)) == NULL) {
 	 r =  file_raise_notokfilename("file_rename", tospec);
   } else {
-	 if(rename(real_fromspec, real_tospec) != 0)
+	 if (rename(real_fromspec, real_tospec) != 0)
 		r = file_raise_errno("rename");
 	 else 
 		r = no_var_pack();	 
   }
-  if(real_fromspec)
+  if (real_fromspec)
 	 free_str(real_fromspec);
   free_var(arglist);
   return r;
@@ -1542,12 +1542,12 @@ int file_chmodstr_to_mode(const char *modespec, mode_t *newmode) {
   mode_t m = 0;
   int i = 0, fct = 1;
 
-  if(strlen(modespec) != 3)
+  if (strlen(modespec) != 3)
 	 return 0;
   else {
-	 for(i = 2; i >= 0; i--) {
+	 for (i = 2; i >= 0; i--) {
 		char c = modespec[i];
-		if(!((c  >= '0') && (c <= '7')))
+		if (!((c  >= '0') && (c <= '7')))
 		  return 0;
 		else {
 		  m += fct * (c - '0');
@@ -1568,14 +1568,14 @@ bf_file_chmod(Var arglist, Byte next, void *vdata, Objid progr)
   mode_t newmode;
   const char *real_filename;
 
-  if(!file_verify_caller(progr)) {
+  if (!file_verify_caller(progr)) {
 	 r = file_raise_notokcall("file_chmod", progr);
-  } else if(!file_chmodstr_to_mode(modespec, &newmode)) {
+  } else if (!file_chmodstr_to_mode(modespec, &newmode)) {
 	 r = make_raise_pack(E_INVARG, "Invalid mode string", zero);	 
-  } else if((real_filename = file_resolve_path(pathspec)) == NULL) {
+  } else if ((real_filename = file_resolve_path(pathspec)) == NULL) {
 	 r =  file_raise_notokfilename("file_chmod", pathspec);
   } else {
-	 if(chmod(real_filename, newmode) != 0)
+	 if (chmod(real_filename, newmode) != 0)
 		r = file_raise_errno("chmod");
 	 else 
 		r = no_var_pack();	 
-- 
1.7.9.5

