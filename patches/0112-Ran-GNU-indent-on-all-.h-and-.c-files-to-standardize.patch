From cf33acdfc8bce2f6485184f55142204d3fada68d Mon Sep 17 00:00:00 2001
From: Steve Wainstead <wainstead@gmail.com>
Date: Wed, 26 Jan 2011 20:30:05 +0000
Subject: [PATCH 112/223] Ran GNU indent on all .h and .c files to standardize
 the formatting. This project came with a
 .indent_pro file, which gives the args -kr -ip4
 -psl -nfca -lps to GNU indent; and this dates from
 1997, so I'm sticking with it for now.

---
 server/ast.c                         |   24 +-
 server/ast.h                         |    3 +-
 server/bg_name_lookup.c              | 1249 ++++++++++++-----------
 server/client_bsd.c                  |    3 +-
 server/client_sysv.c                 |    3 +-
 server/code_gen.c                    |   81 +-
 server/db.h                          |   55 +-
 server/db_file.c                     |  254 ++---
 server/db_io.c                       |   30 +-
 server/db_io.h                       |    4 +-
 server/db_objects.c                  |   20 +-
 server/db_private.h                  |    8 +-
 server/db_properties.c               |   93 +-
 server/db_verbs.c                    |   44 +-
 server/decompile.c                   |  160 +--
 server/disassemble.c                 |   51 +-
 server/eval_env.c                    |    9 +-
 server/eval_vm.c                     |    9 +-
 server/exceptions.c                  |    3 +-
 server/execute.c                     |  294 +++---
 server/execute.h                     |    9 +-
 server/ext-FUP-1.8/ext-FUP.c         | 1834 +++++++++++++++++-----------------
 server/ext-FUP-1.8/ext-FUP_options.h |    8 +-
 server/ext-FUP-1.8/extensions.c      |   63 +-
 server/ext-FUP.c                     | 1827 ++++++++++++++++-----------------
 server/ext-FUP_options.h             |    7 +-
 server/ext-xml.c                     |  389 +++----
 server/extensions.c                  |  154 +--
 server/functions.c                   |   64 +-
 server/functions.h                   |    4 +-
 server/gnu-malloc.c                  |    4 +-
 server/keywords.c                    |    9 +-
 server/list.c                        |  105 +-
 server/log.c                         |   13 +-
 server/log.h                         |    4 +-
 server/match.c                       |    2 +-
 server/md5.c                         |    3 +-
 server/my-fcntl.h                    |    4 +-
 server/my-ioctl.h                    |    2 +-
 server/my-stdio.h                    |    8 +-
 server/name_lookup.c                 |   42 +-
 server/net_bsd_lcl.c                 |    7 +-
 server/net_bsd_tcp.c                 |  160 +--
 server/net_mp_fake.c                 |    8 +-
 server/net_mp_poll.c                 |    6 +-
 server/net_mp_selct.c                |    8 +-
 server/net_mplex.c                   |    3 +-
 server/net_multi.c                   |   58 +-
 server/net_proto.c                   |    3 +-
 server/net_proto.h                   |    6 +-
 server/net_single.c                  |    9 +-
 server/net_sysv_lcl.c                |    9 +-
 server/net_sysv_tcp.c                |    8 +-
 server/net_tcp.c                     |   64 +-
 server/network.c                     |  126 +--
 server/network.h                     |   12 +-
 server/numbers.c                     |   57 +-
 server/objects.c                     |   20 +-
 server/options.h                     |    8 +-
 server/parse_cmd.c                   |   14 +-
 server/pattern.c                     |    6 +-
 server/pattern.h                     |    2 +-
 server/pgperf/boolarray.c            |   87 +-
 server/pgperf/boolarray.h            |   21 +-
 server/pgperf/getopt.c               |  346 +++----
 server/pgperf/hashtable.c            |  112 +--
 server/pgperf/hashtable.h            |   15 +-
 server/pgperf/iterator.c             |  117 ++-
 server/pgperf/iterator.h             |   22 +-
 server/pgperf/keylist.c              | 1666 +++++++++++++++---------------
 server/pgperf/keylist.h              |   41 +-
 server/pgperf/listnode.c             |  127 +--
 server/pgperf/listnode.h             |   25 +-
 server/pgperf/main.c                 |   94 +-
 server/pgperf/options.c              |  592 ++++++-----
 server/pgperf/options.h              |   90 +-
 server/pgperf/perfect.c              |  480 +++++----
 server/pgperf/perfect.h              |   25 +-
 server/pgperf/prototype.h            |    2 +-
 server/pgperf/readline.c             |   78 +-
 server/pgperf/readline.h             |    5 +-
 server/pgperf/stderr.c               |  100 +-
 server/pgperf/stderr.h               |    6 +-
 server/pgperf/xmalloc.c              |   67 +-
 server/program.c                     |    3 +-
 server/program.h                     |    4 +-
 server/property.c                    |    9 +-
 server/ref_count.c                   |    6 +-
 server/regexpr.c                     |  203 ++--
 server/server.c                      |  341 ++++---
 server/server.h                      |   10 +-
 server/storage.c                     |   10 +-
 server/storage.h                     |    3 +-
 server/str_intern.c                  |  195 ++--
 server/streams.c                     |   12 +-
 server/streams.h                     |    2 +-
 server/structures.h                  |   33 +-
 server/sym_table.c                   |    8 +-
 server/tasks.c                       |  607 ++++++-----
 server/tasks.h                       |   12 +-
 server/timers.c                      |    2 +-
 server/tools/moobrowser.c            | 1451 ++++++++++++++-------------
 server/unparse.c                     |   21 +-
 server/utils.c                       |   41 +-
 server/verbs.c                       |   28 +-
 server/version.c                     |    3 +-
 106 files changed, 7580 insertions(+), 7088 deletions(-)

diff --git a/server/ast.c b/server/ast.c
index 36212cf..e7436de 100644
--- a/server/ast.c
+++ b/server/ast.c
@@ -40,7 +40,8 @@ begin_code_allocation()
 {
     pool_size = 10;
     next_pool_slot = 0;
-    pool = (entry *)mymalloc(pool_size * sizeof(struct entry), M_AST_POOL);
+    pool =
+	(entry *) mymalloc(pool_size * sizeof(struct entry), M_AST_POOL);
 }
 
 void
@@ -65,7 +66,9 @@ allocate(int size, Memory_Type type)
 	int i;
 
 	pool_size *= 2;
-	new_pool = (entry *)mymalloc(pool_size * sizeof(struct entry), M_AST_POOL);
+	new_pool =
+	    (entry *) mymalloc(pool_size * sizeof(struct entry),
+			       M_AST_POOL);
 	for (i = 0; i < next_pool_slot; i++) {
 	    new_pool[i] = pool[i];
 	}
@@ -95,7 +98,7 @@ deallocate(void *ptr)
 char *
 alloc_string(const char *buffer)
 {
-  char *string = (char *)allocate(strlen(buffer) + 1, M_STRING);
+    char *string = (char *) allocate(strlen(buffer) + 1, M_STRING);
 
     strcpy(string, buffer);
     return string;
@@ -110,7 +113,7 @@ dealloc_string(char *str)
 double *
 alloc_float(double value)
 {
-  double *d = (double *)allocate(sizeof(double), M_FLOAT);
+    double *d = (double *) allocate(sizeof(double), M_FLOAT);
 
     *d = value;
     return d;
@@ -125,7 +128,7 @@ dealloc_node(void *node)
 Stmt *
 alloc_stmt(enum Stmt_Kind kind)
 {
-  Stmt *result = (Stmt *)allocate(sizeof(Stmt), M_AST);
+    Stmt *result = (Stmt *) allocate(sizeof(Stmt), M_AST);
 
     result->kind = kind;
     result->next = 0;
@@ -135,7 +138,7 @@ alloc_stmt(enum Stmt_Kind kind)
 Cond_Arm *
 alloc_cond_arm(Expr * condition, Stmt * stmt)
 {
-  Cond_Arm *result = (Cond_Arm *)allocate(sizeof(Cond_Arm), M_AST);
+    Cond_Arm *result = (Cond_Arm *) allocate(sizeof(Cond_Arm), M_AST);
 
     result->condition = condition;
     result->stmt = stmt;
@@ -146,7 +149,8 @@ alloc_cond_arm(Expr * condition, Stmt * stmt)
 Except_Arm *
 alloc_except(int id, Arg_List * codes, Stmt * stmt)
 {
-  Except_Arm *result = (Except_Arm *)allocate(sizeof(Except_Arm), M_AST);
+    Except_Arm *result =
+	(Except_Arm *) allocate(sizeof(Except_Arm), M_AST);
 
     result->id = id;
     result->codes = codes;
@@ -159,7 +163,7 @@ alloc_except(int id, Arg_List * codes, Stmt * stmt)
 Expr *
 alloc_expr(enum Expr_Kind kind)
 {
-  Expr *result = (Expr *)allocate(sizeof(Expr), M_AST);
+    Expr *result = (Expr *) allocate(sizeof(Expr), M_AST);
 
     result->kind = kind;
     return result;
@@ -198,7 +202,7 @@ alloc_verb(Expr * obj, Expr * verb, Arg_List * args)
 Arg_List *
 alloc_arg_list(enum Arg_Kind kind, Expr * expr)
 {
-  Arg_List *result = (Arg_List *)allocate(sizeof(Arg_List), M_AST);
+    Arg_List *result = (Arg_List *) allocate(sizeof(Arg_List), M_AST);
 
     result->kind = kind;
     result->expr = expr;
@@ -209,7 +213,7 @@ alloc_arg_list(enum Arg_Kind kind, Expr * expr)
 Scatter *
 alloc_scatter(enum Scatter_Kind kind, int id, Expr * expr)
 {
-  Scatter *sc = (Scatter *)allocate(sizeof(Scatter), M_AST);
+    Scatter *sc = (Scatter *) allocate(sizeof(Scatter), M_AST);
 
     sc->kind = kind;
     sc->id = id;
diff --git a/server/ast.h b/server/ast.h
index 64ae554..298ca17 100644
--- a/server/ast.h
+++ b/server/ast.h
@@ -170,7 +170,8 @@ struct Stmt_Finally {
 
 enum Stmt_Kind {
     STMT_COND, STMT_LIST, STMT_RANGE, STMT_WHILE, STMT_FORK, STMT_EXPR,
-    STMT_RETURN, STMT_TRY_EXCEPT, STMT_TRY_FINALLY, STMT_BREAK, STMT_CONTINUE
+    STMT_RETURN, STMT_TRY_EXCEPT, STMT_TRY_FINALLY, STMT_BREAK,
+	STMT_CONTINUE
 };
 
 union Stmt_Data {
diff --git a/server/bg_name_lookup.c b/server/bg_name_lookup.c
index a2337f9..0a6eeb0 100644
--- a/server/bg_name_lookup.c
+++ b/server/bg_name_lookup.c
@@ -1,10 +1,10 @@
 #include <errno.h>
 #include <signal.h>
-#include <netdb.h>      /* gethostby{name,addr}() */
-#include <unistd.h>     /* write(), read(), sleep(), alarm() */
-#include <stdlib.h>     /* malloc(), free() */
-#include <netinet/in.h> /* inet_ntoa() */
-#include <arpa/inet.h>  /* ditto */
+#include <netdb.h>		/* gethostby{name,addr}() */
+#include <unistd.h>		/* write(), read(), sleep(), alarm() */
+#include <stdlib.h>		/* malloc(), free() */
+#include <netinet/in.h>		/* inet_ntoa() */
+#include <arpa/inet.h>		/* ditto */
 #include <time.h>
 
 #include "tasks.h"
@@ -14,72 +14,76 @@
 #include "list.h"
 #include "my-in.h"
 
-#include "log.h"        /* errlog() */
-#include "exceptions.h" /* panic() */
-#include "net_multi.h"  /* network_{,un}register_fd() */
-#include "storage.h"    /* str_dup() */
-#include "server.h"     /* set_server_cmdline() */
+#include "log.h"		/* errlog() */
+#include "exceptions.h"		/* panic() */
+#include "net_multi.h"		/* network_{,un}register_fd() */
+#include "storage.h"		/* str_dup() */
+#include "server.h"		/* set_server_cmdline() */
 
 enum lookup_enum { ASYNC_FROM_ADDR, ASYNC_FROM_NAME };
-struct async_name_lookup_info
-{
-  enum lookup_enum kind;
- 
-  unsigned timeout;
-  unsigned started;
- 
-  union
-  {
-    char *name;
-    struct in_addr address;
-  } u;
- 
-  pid_t pid;
-  int pipe_fd;
- 
-  vm the_vm;
- 
-  struct async_name_lookup_info *next;
+struct async_name_lookup_info {
+    enum lookup_enum kind;
+
+    unsigned timeout;
+    unsigned started;
+
+    union {
+	char *name;
+	struct in_addr address;
+    } u;
+
+    pid_t pid;
+    int pipe_fd;
+
+    vm the_vm;
+
+    struct async_name_lookup_info *next;
 };
 
 enum request_enum { REQ_FROM_ADDR, REQ_FROM_NAME };
-struct async_request /* Same as name_lookup.c's struct request */
-{
-  enum request_enum kind;
+struct async_request {		/* Same as name_lookup.c's struct request */
+    enum request_enum kind;
 
-  unsigned timeout;
+    unsigned timeout;
 
-  union
-  {
-    unsigned length;
-    /* struct sockaddr_in address; Why? */
-    struct in_addr address;
-  } u;
+    union {
+	unsigned length;
+	/* struct sockaddr_in address; Why? */
+	struct in_addr address;
+    } u;
 };
 
 enum reply_enum { AR_SUCCESS, AR_FAILURE };
-struct async_reply
-{
-  enum reply_enum success;
- 
-  enum error error;
- 
-  int num_aliases;
-  int num_addresses;
+struct async_reply {
+    enum reply_enum success;
+
+    enum error error;
+
+    int num_aliases;
+    int num_addresses;
 };
- 
+
 typedef struct async_reply async_reply;
 typedef struct async_request async_request;
 
 struct async_name_lookup_info *async_name_lookup_info = 0;
-int                            async_name_lookup_len  = 0;
+int async_name_lookup_len = 0;
 
-static task_enum_action lookup_task_queue_enumerator(task_closure closure, void *data);
+static task_enum_action lookup_task_queue_enumerator(task_closure closure,
+						     void *data);
 static void async_name_lookup_readable(int fd, void *ip);
-static struct async_name_lookup_info *dequeue_lookup_task(struct async_name_lookup_info *info_ptr);
-
-static struct async_name_lookup_info *async_lookup_from_name(const char *name, unsigned timeout);
-static struct async_name_lookup_info *async_lookup_from_addr(struct in_addr addr, unsigned timeout);
+static struct async_name_lookup_info *dequeue_lookup_task(struct
+							  async_name_lookup_info
+							  *info_ptr);
+
+static struct async_name_lookup_info *async_lookup_from_name(const char
+							     *name,
+							     unsigned
+							     timeout);
+static struct async_name_lookup_info *async_lookup_from_addr(struct in_addr
+							     addr,
+							     unsigned
+							     timeout);
 
 static void async_lookup_from_addr_child(int to_parent, int from_parent);
 static void async_lookup_from_name_child(int to_parent, int from_parent);
@@ -88,27 +92,26 @@ static void async_child_catch_alarm(int sig);
 
 /*** Utils ***/
 
-static ssize_t  /* Shamelessly stolen from name_lookup.c */
+static ssize_t			/* Shamelessly stolen from name_lookup.c */
 robust_read(int fd, void *buffer, int len)
 {
     int count;
- 
+
     do {
-        count = read(fd, buffer, len);
+	count = read(fd, buffer, len);
     } while (count == -1 && errno == EINTR);
- 
+
     return count;
-} 
+}
 
 static inline ssize_t
 robust_write(int fd, const void *buffer, int len)
 {
-  int ret;
+    int ret;
 
-  while (((ret = write(fd, buffer, len)) == -1) && (errno == EINTR))
-    ;
+    while (((ret = write(fd, buffer, len)) == -1) && (errno == EINTR));
 
-  return ret;
+    return ret;
 }
 
 /* Writes the string length followed by the string to an fd.
@@ -116,16 +119,17 @@ robust_write(int fd, const void *buffer, int len)
 static inline int
 string_write(int fd, char *str)
 {
-  ssize_t ret;
-  size_t size;
+    ssize_t ret;
+    size_t size;
+
+    size = strlen(str);
 
-  size = strlen(str);
-  
-  ret = robust_write(fd, &size, sizeof(size));
-  if (ret != sizeof(size)) return ret;
+    ret = robust_write(fd, &size, sizeof(size));
+    if (ret != sizeof(size))
+	return ret;
 
-  ret = robust_write(fd, str, size);
-  return ret;
+    ret = robust_write(fd, str, size);
+    return ret;
 }
 
 /* Reads a string length followed by a string.
@@ -134,25 +138,26 @@ string_write(int fd, char *str)
 static inline char *
 string_read(int fd)
 {
-  ssize_t ret;
-  size_t size;
-  char *str;
-
-  ret = robust_read(fd, &size, sizeof(size));
-  if (ret != sizeof(size)) return NULL;
-
-  str = (char *)malloc(size+1);
-  if (str == NULL) panic("STRING_READ: Out of memory.\n");
-
-  ret = robust_read(fd, str, size);
-  if (ret != (ssize_t) size)
-  {
-    free(str);
-    return NULL;
-  }
+    ssize_t ret;
+    size_t size;
+    char *str;
+
+    ret = robust_read(fd, &size, sizeof(size));
+    if (ret != sizeof(size))
+	return NULL;
+
+    str = (char *) malloc(size + 1);
+    if (str == NULL)
+	panic("STRING_READ: Out of memory.\n");
+
+    ret = robust_read(fd, str, size);
+    if (ret != (ssize_t) size) {
+	free(str);
+	return NULL;
+    }
 
-  str[size] = '\0';
-  return str;
+    str[size] = '\0';
+    return str;
 }
 
 
@@ -164,58 +169,58 @@ string_read(int fd)
 static task_enum_action
 lookup_task_queue_enumerator(task_closure closure, void *data)
 {
-  int x;
-  struct async_name_lookup_info *info_ptr;
-  task_enum_action tea;
-  static const char status[] = "name_lookup()";
- 
-  info_ptr = async_name_lookup_info;
-
-  for (x=1; x<=async_name_lookup_len; x++)
-  {
-    if (!info_ptr)
-      panic("LOOKUP_TASK_QUEUE_ENUMERATOR: Ran off end of linked list!");
- 
-    tea = (*closure)(info_ptr->the_vm, status, data);
- 
-    if (tea == TEA_KILL)
-    {
-      errlog("LOOKUP_TASK_QUEUE_ENUMERATOR: TEA_KILL\n");
-      dequeue_lookup_task(info_ptr);
+    int x;
+    struct async_name_lookup_info *info_ptr;
+    task_enum_action tea;
+    static const char status[] = "name_lookup()";
+
+    info_ptr = async_name_lookup_info;
+
+    for (x = 1; x <= async_name_lookup_len; x++) {
+	if (!info_ptr)
+	    panic
+		("LOOKUP_TASK_QUEUE_ENUMERATOR: Ran off end of linked list!");
+
+	tea = (*closure) (info_ptr->the_vm, status, data);
+
+	if (tea == TEA_KILL) {
+	    errlog("LOOKUP_TASK_QUEUE_ENUMERATOR: TEA_KILL\n");
+	    dequeue_lookup_task(info_ptr);
+	}
+
+	if (tea != TEA_CONTINUE)
+	    return tea;
+
+	info_ptr = info_ptr->next;
     }
- 
-    if (tea != TEA_CONTINUE)
-      return tea;
- 
-    info_ptr=info_ptr->next;
-  }
- 
-  return TEA_CONTINUE;
-} 
+
+    return TEA_CONTINUE;
+}
 
 
 static enum error
 enqueue_lookup_task(vm the_vm, void *ip)
 {
-  struct async_name_lookup_info **info_walk;
+    struct async_name_lookup_info **info_walk;
+
+    struct async_name_lookup_info *info_ptr =
+	(struct async_name_lookup_info *) ip;
 
-  struct async_name_lookup_info *info_ptr = (struct async_name_lookup_info *) ip;
+    network_register_fd(info_ptr->pipe_fd, async_name_lookup_readable,
+			NULL, info_ptr);
+    info_ptr->the_vm = the_vm;
+
+    /* Easier to throw them on the beginning, but oh well */
+    info_walk = &async_name_lookup_info;
+    while (*info_walk) {
+	info_walk = &((*info_walk)->next);
+    }
 
-  network_register_fd(info_ptr->pipe_fd, async_name_lookup_readable, NULL, info_ptr);
-  info_ptr->the_vm = the_vm;
+    *info_walk = info_ptr;
 
-  /* Easier to throw them on the beginning, but oh well */
-  info_walk = &async_name_lookup_info;
-  while (*info_walk)
-  {
-    info_walk=&((*info_walk)->next);
-  }
- 
-  *info_walk = info_ptr;
+    async_name_lookup_len++;
 
-  async_name_lookup_len++;
- 
-  return E_NONE;
+    return E_NONE;
 }
 
 
@@ -225,36 +230,36 @@ enqueue_lookup_task(vm the_vm, void *ip)
 static struct async_name_lookup_info *
 dequeue_lookup_task(struct async_name_lookup_info *info_ptr)
 {
-  struct async_name_lookup_info **info_walk;
-  int x=0;
-  int cleaned=0;
- 
-  network_unregister_fd(info_ptr->pipe_fd);
-  close(info_ptr->pipe_fd);
- 
-  for (info_walk=&async_name_lookup_info; *info_walk; info_walk=&((*info_walk)->next))
-  {
-    if (*info_walk == info_ptr)
-    {
-      struct async_name_lookup_info *next;
-
-      next = (*info_walk)->next; 
-      free(*info_walk);
-      *info_walk = next;
-      cleaned = 1;
-      break;
+    struct async_name_lookup_info **info_walk;
+    int x = 0;
+    int cleaned = 0;
+
+    network_unregister_fd(info_ptr->pipe_fd);
+    close(info_ptr->pipe_fd);
+
+    for (info_walk = &async_name_lookup_info; *info_walk;
+	 info_walk = &((*info_walk)->next)) {
+	if (*info_walk == info_ptr) {
+	    struct async_name_lookup_info *next;
+
+	    next = (*info_walk)->next;
+	    free(*info_walk);
+	    *info_walk = next;
+	    cleaned = 1;
+	    break;
+	}
+
+	if (++x > async_name_lookup_len)
+	    panic
+		("DEQUEUE_LOOKUP_TASK: Queue is longer than it should be. :-(");
     }
- 
-    if (++x > async_name_lookup_len)
-      panic("DEQUEUE_LOOKUP_TASK: Queue is longer than it should be. :-(");
-  }
- 
-  if (!cleaned)
-    panic("DEQUEUE_LOOKUP_TASK: Failed to clean up.");
- 
-  async_name_lookup_len--;
- 
-  return *info_walk;
+
+    if (!cleaned)
+	panic("DEQUEUE_LOOKUP_TASK: Failed to clean up.");
+
+    async_name_lookup_len--;
+
+    return *info_walk;
 }
 
 
@@ -263,112 +268,109 @@ dequeue_lookup_task(struct async_name_lookup_info *info_ptr)
 static void
 async_name_lookup_readable(int fd, void *ip)
 {
-  struct async_name_lookup_info *info_ptr = (struct async_name_lookup_info *) ip;
-
-  async_reply rep;
-  Var r;
- 
-  char *name;
- 
-  if ((robust_read(info_ptr->pipe_fd, &rep, sizeof(rep)) != sizeof(rep)))
-  {
-    /* fd was probably closed as child died */
-    r.type  = TYPE_ERR;
-    r.v.err = E_VARNF;
-  }
-  else if (rep.success == AR_FAILURE)
-  {
-    /* Child reported an error, just return that */
-    r.type  = TYPE_ERR;
-    r.v.err = rep.error;
-  }
-  else if ((name = string_read(fd)) == NULL)
-  {
-    /* fd was probably closed as child died */
-    r.type  = TYPE_ERR;
-    r.v.err = E_VARNF;
-  }
-  else
-  {
-    int x;
-    char          **alias_list;
-    struct in_addr *addr_list;
+    struct async_name_lookup_info *info_ptr =
+	(struct async_name_lookup_info *) ip;
 
-    if ((alias_list = (char **)calloc(rep.num_aliases, sizeof(alias_list[0]))) == NULL)
-    {
-      panic("ASYNC_NAME_LOOKUP_READABLE: Out of memory\n");
-    }
-
-    if ((addr_list = (struct in_addr *)calloc(rep.num_addresses, sizeof(struct in_addr))) == NULL)
-    {
-      panic("ASYNC_NAME_LOOKUP_READABLE: Out of memory\n");
-    }
+    async_reply rep;
+    Var r;
 
-    /* Read the alias ptrs into our array */
-    for (x=0; x<rep.num_aliases; x++)
-    {
-      alias_list[x] = string_read(info_ptr->pipe_fd);
-      /* oklog("Alias %d: %s\n", x, alias_list[x]); */
-      /* Should do something smarter on error */
-      if (alias_list[x] == NULL)
-        panic("ASYNC_NAME_LOOKUP_READABLE: Couldn't read alias.\n");
-    }
+    char *name;
 
-    /* Read the addrs */
-    for (x=0; x<rep.num_addresses; x++)
-    {
-      /* Should do something smarter on error */
-      if (robust_read(info_ptr->pipe_fd, &(addr_list[x].s_addr), sizeof(addr_list[0].s_addr)) != sizeof(addr_list[0].s_addr))
-        panic("ASYNC_NAME_LOOKUP_READABLE: Couldn't read address.\n");
-      /* oklog("Address %d: %s\n", x, inet_ntoa(addr_list[x])); */
+    if ((robust_read(info_ptr->pipe_fd, &rep, sizeof(rep)) != sizeof(rep))) {
+	/* fd was probably closed as child died */
+	r.type = TYPE_ERR;
+	r.v.err = E_VARNF;
+    } else if (rep.success == AR_FAILURE) {
+	/* Child reported an error, just return that */
+	r.type = TYPE_ERR;
+	r.v.err = rep.error;
+    } else if ((name = string_read(fd)) == NULL) {
+	/* fd was probably closed as child died */
+	r.type = TYPE_ERR;
+	r.v.err = E_VARNF;
+    } else {
+	int x;
+	char **alias_list;
+	struct in_addr *addr_list;
+
+	if ((alias_list =
+	     (char **) calloc(rep.num_aliases,
+			      sizeof(alias_list[0]))) == NULL) {
+	    panic("ASYNC_NAME_LOOKUP_READABLE: Out of memory\n");
+	}
+
+	if ((addr_list =
+	     (struct in_addr *) calloc(rep.num_addresses,
+				       sizeof(struct in_addr))) == NULL) {
+	    panic("ASYNC_NAME_LOOKUP_READABLE: Out of memory\n");
+	}
+
+	/* Read the alias ptrs into our array */
+	for (x = 0; x < rep.num_aliases; x++) {
+	    alias_list[x] = string_read(info_ptr->pipe_fd);
+	    /* oklog("Alias %d: %s\n", x, alias_list[x]); */
+	    /* Should do something smarter on error */
+	    if (alias_list[x] == NULL)
+		panic
+		    ("ASYNC_NAME_LOOKUP_READABLE: Couldn't read alias.\n");
+	}
+
+	/* Read the addrs */
+	for (x = 0; x < rep.num_addresses; x++) {
+	    /* Should do something smarter on error */
+	    if (robust_read
+		(info_ptr->pipe_fd, &(addr_list[x].s_addr),
+		 sizeof(addr_list[0].s_addr)) !=
+		sizeof(addr_list[0].s_addr))
+		panic
+		    ("ASYNC_NAME_LOOKUP_READABLE: Couldn't read address.\n");
+	    /* oklog("Address %d: %s\n", x, inet_ntoa(addr_list[x])); */
+	}
+
+	/* Yay, return successful result */
+	r = new_list(3);
+
+	r.v.list[1].type = TYPE_STR;
+	r.v.list[1].v.str = str_dup(name);
+
+	r.v.list[2] = new_list(rep.num_aliases);
+	for (x = 0; x < rep.num_aliases; x++) {
+	    r.v.list[2].v.list[x + 1].type = TYPE_STR;
+	    r.v.list[2].v.list[x + 1].v.str = str_dup(alias_list[x]);
+	}
+
+	r.v.list[3] = new_list(rep.num_addresses);
+	for (x = 0; x < rep.num_addresses; x++) {
+	    unsigned char *y = (unsigned char *) &(addr_list[x].s_addr);
+
+	    r.v.list[3].v.list[x + 1] = new_list(4);
+	    r.v.list[3].v.list[x + 1].v.list[1].type = TYPE_INT;
+	    r.v.list[3].v.list[x + 1].v.list[1].v.num = (int) *y++;
+	    r.v.list[3].v.list[x + 1].v.list[2].type = TYPE_INT;
+	    r.v.list[3].v.list[x + 1].v.list[2].v.num = (int) *y++;
+	    r.v.list[3].v.list[x + 1].v.list[3].type = TYPE_INT;
+	    r.v.list[3].v.list[x + 1].v.list[3].v.num = (int) *y++;
+	    r.v.list[3].v.list[x + 1].v.list[4].type = TYPE_INT;
+	    r.v.list[3].v.list[x + 1].v.list[4].v.num = (int) *y++;
+	}
+
+	/* Free all our stuff */
+	free(name);
+	free(alias_list);
+	free(addr_list);
     }
 
-    /* Yay, return successful result */
-    r = new_list(3);
-
-    r.v.list[1].type  = TYPE_STR;
-    r.v.list[1].v.str = str_dup(name);
-
-    r.v.list[2] = new_list(rep.num_aliases);
-    for (x=0; x<rep.num_aliases; x++)
-    {
-      r.v.list[2].v.list[x+1].type  = TYPE_STR;
-      r.v.list[2].v.list[x+1].v.str = str_dup(alias_list[x]);
-    }
+    resume_task(info_ptr->the_vm, r);
 
-    r.v.list[3] = new_list(rep.num_addresses);
-    for (x=0; x<rep.num_addresses; x++)
-    {
-      unsigned char *y=(unsigned char *) &(addr_list[x].s_addr);
-
-      r.v.list[3].v.list[x+1] = new_list(4);
-      r.v.list[3].v.list[x+1].v.list[1].type  = TYPE_INT;
-      r.v.list[3].v.list[x+1].v.list[1].v.num = (int) *y++;
-      r.v.list[3].v.list[x+1].v.list[2].type  = TYPE_INT;
-      r.v.list[3].v.list[x+1].v.list[2].v.num = (int) *y++;
-      r.v.list[3].v.list[x+1].v.list[3].type  = TYPE_INT;
-      r.v.list[3].v.list[x+1].v.list[3].v.num = (int) *y++;
-      r.v.list[3].v.list[x+1].v.list[4].type  = TYPE_INT;
-      r.v.list[3].v.list[x+1].v.list[4].v.num = (int) *y++;
-    }
+    /* Clean up */
+    dequeue_lookup_task(info_ptr);
 
-    /* Free all our stuff */
-    free(name);
-    free(alias_list);
-    free(addr_list);
-  }
- 
-  resume_task(info_ptr->the_vm, r);
- 
-  /* Clean up */
-  dequeue_lookup_task(info_ptr);
- 
-  return;
+    return;
 }
 
 
 /*** Builtin function stuff ***/
- 
+
 
 /* bf_name_lookup(str/list addr, int timeout) => {str name, list aliases, list addresses}
  * E_PERM    - Not a wizard.
@@ -383,82 +385,75 @@ async_name_lookup_readable(int fd, void *ip)
 static package
 bf_name_lookup(Var arglist, Byte next, void *vdata, Objid progr)
 {
-  Var r;  /* probably unneeded */
-  struct async_name_lookup_info *info_ptr;
- 
-  int timeout = arglist.v.list[2].v.num;
- 
-  if (!is_wizard(progr))
-  {
-    free_var(arglist);
-    return make_error_pack(E_PERM);
-  }
- 
-  switch (arglist.v.list[1].type)
-  {
-  case TYPE_STR:
-    if ((info_ptr = async_lookup_from_name(arglist.v.list[1].v.str, timeout)) == NULL)
-    {
-      free_var(arglist);
-      return make_error_pack(E_RECMOVE);  /* Problem starting or talking to child */
-    }
-    else
-    {
-      free_var(arglist);
-      return make_suspend_pack(enqueue_lookup_task, info_ptr);
-    }
- 
-    break;
-  case TYPE_LIST:
-    if (arglist.v.list[1].v.list[0].v.num != 4)
-    {
-      free_var(arglist);
-      return make_error_pack(E_INVARG);
+    Var r;			/* probably unneeded */
+    struct async_name_lookup_info *info_ptr;
+
+    int timeout = arglist.v.list[2].v.num;
+
+    if (!is_wizard(progr)) {
+	free_var(arglist);
+	return make_error_pack(E_PERM);
     }
-    else
-    {
-      int x;
-      struct in_addr tmp_addr;
-      unsigned char *y = (unsigned char *) &(tmp_addr.s_addr);
-
-      /* We have a list of length 4. Turn it into an IP. */
-      for (x=1; x<=4; x++)
-      {
-        if ((arglist.v.list[1].v.list[x].type != TYPE_INT) ||
-            (arglist.v.list[1].v.list[x].v.num < 0)        ||
-            (arglist.v.list[1].v.list[x].v.num > 255))
-        {
-          free_var(arglist);
-          return make_error_pack(E_INVARG);
-        }
-        else
-          *y++ = (unsigned char) arglist.v.list[1].v.list[x].v.num;
-      }
-
-      free_var(arglist); /* We're done with them at this point */
-
-      /* Try to look it up. */
-      if ((info_ptr = async_lookup_from_addr(tmp_addr, timeout)) == NULL)
-        return make_error_pack(E_RECMOVE);  /* Problem starting or talking to child */
-      else
-        return make_suspend_pack(enqueue_lookup_task, info_ptr);
+
+    switch (arglist.v.list[1].type) {
+    case TYPE_STR:
+	if ((info_ptr =
+	     async_lookup_from_name(arglist.v.list[1].v.str,
+				    timeout)) == NULL) {
+	    free_var(arglist);
+	    return make_error_pack(E_RECMOVE);	/* Problem starting or talking to child */
+	} else {
+	    free_var(arglist);
+	    return make_suspend_pack(enqueue_lookup_task, info_ptr);
+	}
+
+	break;
+    case TYPE_LIST:
+	if (arglist.v.list[1].v.list[0].v.num != 4) {
+	    free_var(arglist);
+	    return make_error_pack(E_INVARG);
+	} else {
+	    int x;
+	    struct in_addr tmp_addr;
+	    unsigned char *y = (unsigned char *) &(tmp_addr.s_addr);
+
+	    /* We have a list of length 4. Turn it into an IP. */
+	    for (x = 1; x <= 4; x++) {
+		if ((arglist.v.list[1].v.list[x].type != TYPE_INT) ||
+		    (arglist.v.list[1].v.list[x].v.num < 0) ||
+		    (arglist.v.list[1].v.list[x].v.num > 255)) {
+		    free_var(arglist);
+		    return make_error_pack(E_INVARG);
+		} else
+		    *y++ =
+			(unsigned char) arglist.v.list[1].v.list[x].v.num;
+	    }
+
+	    free_var(arglist);	/* We're done with them at this point */
+
+	    /* Try to look it up. */
+	    if ((info_ptr =
+		 async_lookup_from_addr(tmp_addr, timeout)) == NULL)
+		return make_error_pack(E_RECMOVE);	/* Problem starting or talking to child */
+	    else
+		return make_suspend_pack(enqueue_lookup_task, info_ptr);
+	}
+
+	break;
+    default:
+	free_var(arglist);
+	return make_error_pack(E_TYPE);
+	break;
     }
 
-    break;
-  default:
+    /* Hmm... */
+    errlog("BF_NAME_LOOKUP: How did we get here?\n");
+
+    r.type = TYPE_INT;
+    r.v.num = 0;
+
     free_var(arglist);
-    return make_error_pack(E_TYPE);
-    break;
-  }
- 
-  /* Hmm... */
-  errlog("BF_NAME_LOOKUP: How did we get here?\n");
-
-  r.type = TYPE_INT;
-  r.v.num = 0;
-
-  free_var(arglist);
-  return make_var_pack(r);
+    return make_var_pack(r);
 }
 
 
@@ -468,52 +463,51 @@ bf_name_lookup(Var arglist, Byte next, void *vdata, Objid progr)
 static package
 bf_name_lookups(Var arglist, Byte next, void *vdata, Objid progr)
 {
-  Var r;
-  int x;
-  struct async_name_lookup_info *info_ptr;
- 
-  if (!is_wizard(progr))
-  {
+    Var r;
+    int x;
+    struct async_name_lookup_info *info_ptr;
+
+    if (!is_wizard(progr)) {
+	free_var(arglist);
+	return make_error_pack(E_PERM);
+    }
+
+    info_ptr = async_name_lookup_info;
+    r = new_list(async_name_lookup_len);
+
+    for (x = 1; x <= async_name_lookup_len; x++) {
+	r.v.list[x] = new_list(4);
+
+	if (!info_ptr)
+	    panic("BF_NAME_LOOKUPS: Ran off end of linked list!");
+
+	r.v.list[x].v.list[1].type = TYPE_STR;
+	r.v.list[x].v.list[1].v.str = str_dup(info_ptr->u.name);
+
+	r.v.list[x].v.list[2].type = TYPE_INT;
+	r.v.list[x].v.list[2].v.num = info_ptr->timeout;
+
+	r.v.list[x].v.list[3].type = TYPE_INT;
+	r.v.list[x].v.list[3].v.num = info_ptr->started;
+
+	r.v.list[x].v.list[4].type = TYPE_INT;
+	r.v.list[x].v.list[4].v.num = info_ptr->the_vm->task_id;
+
+	info_ptr = info_ptr->next;
+    }
+
     free_var(arglist);
-    return make_error_pack(E_PERM);
-  }
- 
-  info_ptr = async_name_lookup_info;
-  r = new_list(async_name_lookup_len);
- 
-  for (x=1; x<=async_name_lookup_len; x++)
-  {
-    r.v.list[x] = new_list(4);
- 
-    if (!info_ptr)
-      panic("BF_NAME_LOOKUPS: Ran off end of linked list!");
- 
-    r.v.list[x].v.list[1].type = TYPE_STR;
-    r.v.list[x].v.list[1].v.str = str_dup(info_ptr->u.name);
- 
-    r.v.list[x].v.list[2].type = TYPE_INT;
-    r.v.list[x].v.list[2].v.num = info_ptr->timeout;
- 
-    r.v.list[x].v.list[3].type = TYPE_INT;
-    r.v.list[x].v.list[3].v.num = info_ptr->started;
- 
-    r.v.list[x].v.list[4].type = TYPE_INT;
-    r.v.list[x].v.list[4].v.num = info_ptr->the_vm->task_id;
- 
-    info_ptr = info_ptr->next;
-  }
- 
-  free_var(arglist);
-  return make_var_pack(r);
-} 
+    return make_var_pack(r);
+}
 
 
 void
 register_name_lookup()
-{ 
-  register_task_queue(lookup_task_queue_enumerator);
-  (void) register_function("name_lookup", 2, 2, bf_name_lookup, TYPE_ANY, TYPE_INT);
-  (void) register_function("name_lookups", 0, 0, bf_name_lookups);
+{
+    register_task_queue(lookup_task_queue_enumerator);
+    (void) register_function("name_lookup", 2, 2, bf_name_lookup, TYPE_ANY,
+			     TYPE_INT);
+    (void) register_function("name_lookups", 0, 0, bf_name_lookups);
 }
 
 
@@ -524,149 +518,154 @@ register_name_lookup()
  * We probably inherit signal handlers?
  * And we should probably close() the network fd's?
  */
-static pid_t spawn_async_lookup(void (*child_proc) (int to_parent, int from_parent),
-                                 int *to_child, int *from_child)
+static pid_t
+spawn_async_lookup(void (*child_proc) (int to_parent, int from_parent),
+		   int *to_child, int *from_child)
 {
-  int pipe_to_child[2], pipe_from_child[2];
-  pid_t pid;
- 
-  if (pipe(pipe_to_child) < 0) {
-    log_perror("SPAWN_ASYNC_LOOKUP: Couldn't create first pipe");
-  } else if (pipe(pipe_from_child) < 0) {
-    log_perror("SPAWN_ASYNC_LOOKUP: Couldn't create second pipe");
-    close(pipe_to_child[0]);
-    close(pipe_to_child[1]);
-  } else if ((pid = fork()) < 0) {
-    log_perror("SPAWN_ASYNC_LOOKUP: Couldn't fork name lookup process");
-    close(pipe_to_child[0]);
-    close(pipe_to_child[1]);
-    close(pipe_from_child[0]);
-    close(pipe_from_child[1]);
-  } else if (pid != 0) {      /* parent */
- 
-    close(pipe_to_child[0]);
-    close(pipe_from_child[1]);
-    *to_child = pipe_to_child[1];
-    *from_child = pipe_from_child[0];
- 
-    return pid;
-  } else {                   /* child */
-    close(pipe_to_child[1]);
-    close(pipe_from_child[0]);
- 
-    signal(SIGALRM, async_child_catch_alarm);
- 
-    (*child_proc) (pipe_from_child[1], pipe_to_child[0]);
-    exit(0);
-  }
- 
-  return 0;
-} 
+    int pipe_to_child[2], pipe_from_child[2];
+    pid_t pid;
+
+    if (pipe(pipe_to_child) < 0) {
+	log_perror("SPAWN_ASYNC_LOOKUP: Couldn't create first pipe");
+    } else if (pipe(pipe_from_child) < 0) {
+	log_perror("SPAWN_ASYNC_LOOKUP: Couldn't create second pipe");
+	close(pipe_to_child[0]);
+	close(pipe_to_child[1]);
+    } else if ((pid = fork()) < 0) {
+	log_perror
+	    ("SPAWN_ASYNC_LOOKUP: Couldn't fork name lookup process");
+	close(pipe_to_child[0]);
+	close(pipe_to_child[1]);
+	close(pipe_from_child[0]);
+	close(pipe_from_child[1]);
+    } else if (pid != 0) {	/* parent */
+
+	close(pipe_to_child[0]);
+	close(pipe_from_child[1]);
+	*to_child = pipe_to_child[1];
+	*from_child = pipe_from_child[0];
+
+	return pid;
+    } else {			/* child */
+	close(pipe_to_child[1]);
+	close(pipe_from_child[0]);
+
+	signal(SIGALRM, async_child_catch_alarm);
+
+	(*child_proc) (pipe_from_child[1], pipe_to_child[0]);
+	exit(0);
+    }
+
+    return 0;
+}
 
 
 static struct async_name_lookup_info *
 async_lookup_from_name(const char *name, unsigned timeout)
 {
-  struct async_name_lookup_info *info_new;
- 
-  async_request req;
-
-  int pid;
-  int to_child, from_child;
- 
- 
-  if ((info_new=(struct async_name_lookup_info *)malloc(sizeof(struct async_name_lookup_info))) == NULL)
-  {
-    errlog("ASYNC_LOOKUP_FROM_NAME: Malloc failed.\n");
-    return NULL;
-  }
- 
-  pid = spawn_async_lookup(async_lookup_from_name_child, &to_child, &from_child);
-  if (!pid)
-  {
-    errlog("ASYNC_LOOKUP_FROM_NAME: Could not spawn child!\n");
-    free(info_new);
-    return NULL;
-  }
- 
-  req.kind     = REQ_FROM_NAME;
-  req.timeout  = timeout;
-  req.u.length = strlen(name);
- 
-  if (robust_write(to_child, &req, sizeof(req)) == -1)
-  {
-    log_perror("ASYNC_LOOKUP_FROM_NAME: Couldn't write request to child");
-    free(info_new);
-    return NULL;
-  }
- 
-  if (robust_write(to_child, name, req.u.length) == -1)
-  {
-    log_perror("ASYNC_LOOKUP_FROM_NAME: Couldn't write name to child");
-    free(info_new);
-    return NULL;
-  }
- 
-  close(to_child);
- 
-  info_new->timeout = timeout;
-  info_new->started = time(NULL);
-  info_new->u.name  = str_dup(name);
-  info_new->pid     = pid;
-  info_new->pipe_fd = from_child;
-  info_new->next    = 0;
- 
-  return info_new;
-} 
+    struct async_name_lookup_info *info_new;
+
+    async_request req;
+
+    int pid;
+    int to_child, from_child;
+
+
+    if ((info_new =
+	 (struct async_name_lookup_info *)
+	 malloc(sizeof(struct async_name_lookup_info))) == NULL) {
+	errlog("ASYNC_LOOKUP_FROM_NAME: Malloc failed.\n");
+	return NULL;
+    }
+
+    pid =
+	spawn_async_lookup(async_lookup_from_name_child, &to_child,
+			   &from_child);
+    if (!pid) {
+	errlog("ASYNC_LOOKUP_FROM_NAME: Could not spawn child!\n");
+	free(info_new);
+	return NULL;
+    }
+
+    req.kind = REQ_FROM_NAME;
+    req.timeout = timeout;
+    req.u.length = strlen(name);
+
+    if (robust_write(to_child, &req, sizeof(req)) == -1) {
+	log_perror
+	    ("ASYNC_LOOKUP_FROM_NAME: Couldn't write request to child");
+	free(info_new);
+	return NULL;
+    }
+
+    if (robust_write(to_child, name, req.u.length) == -1) {
+	log_perror("ASYNC_LOOKUP_FROM_NAME: Couldn't write name to child");
+	free(info_new);
+	return NULL;
+    }
+
+    close(to_child);
+
+    info_new->timeout = timeout;
+    info_new->started = time(NULL);
+    info_new->u.name = str_dup(name);
+    info_new->pid = pid;
+    info_new->pipe_fd = from_child;
+    info_new->next = 0;
+
+    return info_new;
+}
 
 
 static struct async_name_lookup_info *
 async_lookup_from_addr(struct in_addr addr, unsigned timeout)
 {
-  struct async_name_lookup_info *info_new;
- 
-  async_request req;
-
-  int pid;
-  int to_child, from_child;
-
- 
-  if ((info_new=(struct async_name_lookup_info *)malloc(sizeof(struct async_name_lookup_info))) == NULL)
-  {
-    errlog("ASYNC_LOOKUP_FROM_ADDR: Malloc failed.\n");
-    return NULL;
-  }
- 
-  pid = spawn_async_lookup(async_lookup_from_addr_child, &to_child, &from_child);
-  if (!pid)
-  {
-    errlog("ASYNC_LOOKUP_FROM_ADDR: Could not spawn child!\n");
-    free(info_new);
-    return NULL;
-  }
- 
-  req.kind             = REQ_FROM_ADDR;
-  req.timeout          = timeout;
-  req.u.address.s_addr = addr.s_addr;
- 
-  if (robust_write(to_child, &req, sizeof(req)) == -1)
-  {
-    log_perror("ASYNC_LOOKUP_FROM_ADDR: Couldn't write request to child");
-    free(info_new);
-    return NULL;
-  }
-
-  close(to_child);
- 
-  info_new->timeout          = timeout;
-  info_new->started          = time(NULL);
-  info_new->u.address.s_addr = addr.s_addr;
-  info_new->pid              = pid;
-  info_new->pipe_fd          = from_child;
-  info_new->next             = 0;
-
-  return info_new;
-} 
+    struct async_name_lookup_info *info_new;
+
+    async_request req;
+
+    int pid;
+    int to_child, from_child;
+
+
+    if ((info_new =
+	 (struct async_name_lookup_info *)
+	 malloc(sizeof(struct async_name_lookup_info))) == NULL) {
+	errlog("ASYNC_LOOKUP_FROM_ADDR: Malloc failed.\n");
+	return NULL;
+    }
+
+    pid =
+	spawn_async_lookup(async_lookup_from_addr_child, &to_child,
+			   &from_child);
+    if (!pid) {
+	errlog("ASYNC_LOOKUP_FROM_ADDR: Could not spawn child!\n");
+	free(info_new);
+	return NULL;
+    }
+
+    req.kind = REQ_FROM_ADDR;
+    req.timeout = timeout;
+    req.u.address.s_addr = addr.s_addr;
+
+    if (robust_write(to_child, &req, sizeof(req)) == -1) {
+	log_perror
+	    ("ASYNC_LOOKUP_FROM_ADDR: Couldn't write request to child");
+	free(info_new);
+	return NULL;
+    }
+
+    close(to_child);
+
+    info_new->timeout = timeout;
+    info_new->started = time(NULL);
+    info_new->u.address.s_addr = addr.s_addr;
+    info_new->pid = pid;
+    info_new->pipe_fd = from_child;
+    info_new->next = 0;
+
+    return info_new;
+}
 
 
 /*** Runs in child ***/
@@ -676,156 +675,150 @@ async_lookup_from_addr(struct in_addr addr, unsigned timeout)
 static void
 async_child_catch_alarm(int sig)
 {
-  _exit(1);
+    _exit(1);
 }
 
 
 /* Called from async_lookup_from_{name,addr}_child.
  * Figures out what our name lookup answer was, and tells the parent about it.
  */
-static void process_lookup_answer(int to_parent, struct hostent *answer)
+static void
+process_lookup_answer(int to_parent, struct hostent *answer)
 {
-  async_reply   rep;
-
-  if (answer == NULL)
-  {
-    /* Report failure */
-    rep.success = AR_FAILURE;
- 
-    switch (h_errno)
-    {
-    case HOST_NOT_FOUND:
-      rep.error   = E_PROPNF;
-      break;
-    case TRY_AGAIN:
-      rep.error   = E_MAXREC;
-      break;
-    case NO_DATA:
-      rep.error   = E_INVIND;
-      break;
-    default:
-      rep.error   = E_VERBNF;
-      break;
+    async_reply rep;
+
+    if (answer == NULL) {
+	/* Report failure */
+	rep.success = AR_FAILURE;
+
+	switch (h_errno) {
+	case HOST_NOT_FOUND:
+	    rep.error = E_PROPNF;
+	    break;
+	case TRY_AGAIN:
+	    rep.error = E_MAXREC;
+	    break;
+	case NO_DATA:
+	    rep.error = E_INVIND;
+	    break;
+	default:
+	    rep.error = E_VERBNF;
+	    break;
+	}
+
+	write(to_parent, &rep, sizeof(rep));
+
+	_exit(1);
+    } else {
+	int x;
+
+	char **addr_list = answer->h_addr_list;
+	char **alias_list = answer->h_aliases;
+
+
+	/* Report success */
+	rep.success = AR_SUCCESS;
+	rep.error = E_NONE;
+
+	/* Count the number of aliases */
+	for (x = 0; alias_list[x]; x++);
+	rep.num_aliases = x;
+
+	/* Count the number of addresses */
+	for (x = 0; addr_list[x]; x++);
+	rep.num_addresses = x;
+
+	/* sleep(10); */
+	robust_write(to_parent, &rep, sizeof(rep));
+
+	/* Write the CNAME */
+	string_write(to_parent, answer->h_name);
+
+	/* Write the list of aliases */
+	for (x = 0; x < rep.num_aliases; x++)
+	    string_write(to_parent, alias_list[x]);
+
+	/* Write the list of addresses */
+	for (x = 0; x < rep.num_addresses; x++)
+	    robust_write(to_parent, addr_list[x], answer->h_length);
     }
- 
-    write(to_parent, &rep, sizeof(rep));
- 
-    _exit(1);
-  }
-  else
-  {
-    int x;
-
-    char ** addr_list = answer->h_addr_list;
-    char **alias_list = answer->h_aliases;
-
- 
-    /* Report success */
-    rep.success = AR_SUCCESS;
-    rep.error   = E_NONE;
- 
-    /* Count the number of aliases */
-    for (x=0; alias_list[x]; x++)
-      ;
-    rep.num_aliases = x;
- 
-    /* Count the number of addresses */
-    for (x=0; addr_list[x]; x++)
-      ;
-    rep.num_addresses = x;
-    
-    /* sleep(10); */
-    robust_write(to_parent, &rep, sizeof(rep));
-
-    /* Write the CNAME */
-    string_write(to_parent, answer->h_name);
-
-    /* Write the list of aliases */
-    for (x=0; x < rep.num_aliases; x++)
-      string_write(to_parent, alias_list[x]);
-
-    /* Write the list of addresses */
-    for (x=0; x < rep.num_addresses; x++)
-      robust_write(to_parent, addr_list[x], answer->h_length);
-  }
 
 }
 
 
-static void async_lookup_from_name_child(int to_parent, int from_parent)
+static void
+async_lookup_from_name_child(int to_parent, int from_parent)
 {
-  async_request req;
-  char *name, *cmdline;
-  struct hostent *answer;
- 
-  if (robust_read(from_parent, &req, sizeof(req)) != sizeof(req)) {
-    errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Read of request failed.\n");
-    _exit(1);
-  }
-  else if (req.kind != REQ_FROM_NAME) {
-    errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Unexpected request kind.\n");
-    _exit(1);
-  }
-  else if ((name = (char *)malloc(req.u.length + 1)) == NULL) {
-    errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Out of memory\n");
-    _exit(1);
-  }
-  else if (robust_read(from_parent, name, req.u.length) != (ssize_t) req.u.length) {
-    errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Read of name failed.\n");
-    _exit(1);
-  }
- 
-  name[req.u.length]='\0';
-
-  /* Set the command line while we're doing our lookup */
-  cmdline=(char *)malloc(50+req.u.length);
-  if (cmdline != NULL)
-  {
-    sprintf(cmdline, "(MOO async name lookup: %s)", name);
-    set_server_cmdline(cmdline);
-    free(cmdline);
-  }
- 
-  alarm(req.timeout);
- 
-  answer = gethostbyname(name);
+    async_request req;
+    char *name, *cmdline;
+    struct hostent *answer;
+
+    if (robust_read(from_parent, &req, sizeof(req)) != sizeof(req)) {
+	errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Read of request failed.\n");
+	_exit(1);
+    } else if (req.kind != REQ_FROM_NAME) {
+	errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Unexpected request kind.\n");
+	_exit(1);
+    } else if ((name = (char *) malloc(req.u.length + 1)) == NULL) {
+	errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Out of memory\n");
+	_exit(1);
+    } else if (robust_read(from_parent, name, req.u.length) !=
+	       (ssize_t) req.u.length) {
+	errlog("ASYNC_LOOKUP_FROM_NAME_CHILD: Read of name failed.\n");
+	_exit(1);
+    }
+
+    name[req.u.length] = '\0';
+
+    /* Set the command line while we're doing our lookup */
+    cmdline = (char *) malloc(50 + req.u.length);
+    if (cmdline != NULL) {
+	sprintf(cmdline, "(MOO async name lookup: %s)", name);
+	set_server_cmdline(cmdline);
+	free(cmdline);
+    }
+
+    alarm(req.timeout);
 
-  alarm(0);
+    answer = gethostbyname(name);
 
-  process_lookup_answer(to_parent, answer);
+    alarm(0);
 
-  return;
-}   
+    process_lookup_answer(to_parent, answer);
+
+    return;
+}
 
 
-static void async_lookup_from_addr_child(int to_parent, int from_parent)
+static void
+async_lookup_from_addr_child(int to_parent, int from_parent)
 {
-  async_request req;
-  char cmdline[50];
-  struct hostent *answer;
- 
-  if (robust_read(from_parent, &req, sizeof(req)) != sizeof(req)) {
-    errlog("ASYNC_LOOKUP_FROM_ADDR_CHILD: Read of request failed.\n");
-    _exit(1);
-  }
-  else if (req.kind != REQ_FROM_ADDR) {
-    errlog("ASYNC_LOOKUP_FROM_ADDR_CHILD: Unexpected request kind.\n");
-    _exit(1);
-  }
+    async_request req;
+    char cmdline[50];
+    struct hostent *answer;
+
+    if (robust_read(from_parent, &req, sizeof(req)) != sizeof(req)) {
+	errlog("ASYNC_LOOKUP_FROM_ADDR_CHILD: Read of request failed.\n");
+	_exit(1);
+    } else if (req.kind != REQ_FROM_ADDR) {
+	errlog("ASYNC_LOOKUP_FROM_ADDR_CHILD: Unexpected request kind.\n");
+	_exit(1);
+    }
 
-  /* Set the command line while we're doing our lookup */
-  sprintf(cmdline, "(MOO async name lookup: %s)", inet_ntoa(req.u.address));
-  set_server_cmdline(cmdline);
- 
-  alarm(req.timeout);
- 
-  answer = gethostbyaddr((void *) &(req.u.address.s_addr), sizeof(req.u.address.s_addr), AF_INET);
+    /* Set the command line while we're doing our lookup */
+    sprintf(cmdline, "(MOO async name lookup: %s)",
+	    inet_ntoa(req.u.address));
+    set_server_cmdline(cmdline);
 
-  alarm(0);
+    alarm(req.timeout);
 
-  process_lookup_answer(to_parent, answer);
+    answer =
+	gethostbyaddr((void *) &(req.u.address.s_addr),
+		      sizeof(req.u.address.s_addr), AF_INET);
 
-  return;
-}   
+    alarm(0);
 
+    process_lookup_answer(to_parent, answer);
 
+    return;
+}
diff --git a/server/client_bsd.c b/server/client_bsd.c
index 570db59..54796fe 100644
--- a/server/client_bsd.c
+++ b/server/client_bsd.c
@@ -84,7 +84,8 @@ main(int argc, char **argv)
     exit(0);
 }
 
-char rcsid_client_bsd[] = "$Id: client_bsd.c,v 1.2 1997-03-03 04:18:23 nop Exp $";
+char rcsid_client_bsd[] =
+    "$Id: client_bsd.c,v 1.2 1997-03-03 04:18:23 nop Exp $";
 
 /* $Log: not supported by cvs2svn $
  * Revision 1.1.1.1  1997/03/03 03:45:02  nop
diff --git a/server/client_sysv.c b/server/client_sysv.c
index c7e9102..e948181 100644
--- a/server/client_sysv.c
+++ b/server/client_sysv.c
@@ -175,7 +175,8 @@ main(int argc, char **argv)
     exit(1);
 }
 
-char rcsid_client_sysv[] = "$Id: client_sysv.c,v 1.2 1997-03-03 04:18:23 nop Exp $";
+char rcsid_client_sysv[] =
+    "$Id: client_sysv.c,v 1.2 1997-03-03 04:18:23 nop Exp $";
 
 /* $Log: not supported by cvs2svn $
  * Revision 1.1.1.1  1997/03/03 03:45:02  nop
diff --git a/server/code_gen.c b/server/code_gen.c
index 583bdbc..8b51fa9 100644
--- a/server/code_gen.c
+++ b/server/code_gen.c
@@ -42,7 +42,7 @@ struct fixup {
     unsigned pc;
     unsigned value;
     unsigned prev_literals, prev_forks, prev_var_refs, prev_labels,
-     prev_stacks;
+	prev_stacks;
     int next;			/* chain for compiling IF/ELSEIF arms */
 };
 typedef struct fixup Fixup;
@@ -131,14 +131,18 @@ init_state(State * state, GState * gstate)
 
     state->num_fixups = 0;
     state->max_fixups = 10;
-    state->fixups = (Fixup *) mymalloc(sizeof(Fixup) * state->max_fixups, M_CODE_GEN);
+    state->fixups =
+	(Fixup *) mymalloc(sizeof(Fixup) * state->max_fixups, M_CODE_GEN);
 
     state->num_bytes = 0;
     state->max_bytes = 50;
-    state->bytes = (Byte *) mymalloc(sizeof(Byte) * state->max_bytes, M_BYTECODES);
+    state->bytes =
+	(Byte *) mymalloc(sizeof(Byte) * state->max_bytes, M_BYTECODES);
 #ifdef BYTECODE_REDUCE_REF
-    state->pushmap = (Byte *) mymalloc(sizeof(Byte) * state->max_bytes, M_BYTECODES);
-    state->trymap = (Byte *) mymalloc(sizeof(Byte) * state->max_bytes, M_BYTECODES);
+    state->pushmap =
+	(Byte *) mymalloc(sizeof(Byte) * state->max_bytes, M_BYTECODES);
+    state->trymap =
+	(Byte *) mymalloc(sizeof(Byte) * state->max_bytes, M_BYTECODES);
     state->try_depth = 0;
 #endif				/* BYTECODE_REDUCE_REF */
 
@@ -147,7 +151,8 @@ init_state(State * state, GState * gstate)
 
     state->num_loops = 0;
     state->max_loops = 5;
-    state->loops = (Loop *) mymalloc(sizeof(Loop) * state->max_loops, M_CODE_GEN);
+    state->loops =
+	(Loop *) mymalloc(sizeof(Loop) * state->max_loops, M_CODE_GEN);
 
     state->gstate = gstate;
 }
@@ -169,13 +174,16 @@ emit_byte(Byte b, State * state)
 {
     if (state->num_bytes == state->max_bytes) {
 	unsigned new_max = 2 * state->max_bytes;
-	state->bytes = (Byte *) myrealloc(state->bytes, sizeof(Byte) * new_max,
-				 M_BYTECODES);
+	state->bytes =
+	    (Byte *) myrealloc(state->bytes, sizeof(Byte) * new_max,
+			       M_BYTECODES);
 #ifdef BYTECODE_REDUCE_REF
-	state->pushmap = (Byte *) myrealloc(state->pushmap, sizeof(Byte) * new_max,
-				   M_BYTECODES);
-	state->trymap = (Byte *) myrealloc(state->trymap, sizeof(Byte) * new_max,
-				  M_BYTECODES);
+	state->pushmap =
+	    (Byte *) myrealloc(state->pushmap, sizeof(Byte) * new_max,
+			       M_BYTECODES);
+	state->trymap =
+	    (Byte *) myrealloc(state->trymap, sizeof(Byte) * new_max,
+			       M_BYTECODES);
 #endif				/* BYTECODE_REDUCE_REF */
 	state->max_bytes = new_max;
     }
@@ -201,7 +209,7 @@ add_known_fixup(Fixup f, State * state)
     if (state->num_fixups == state->max_fixups) {
 	unsigned new_max = 2 * state->max_fixups;
 	Fixup *new_fixups = (Fixup *) mymalloc(sizeof(Fixup) * new_max,
-				     M_CODE_GEN);
+					       M_CODE_GEN);
 
 	for (i = 0; i < state->num_fixups; i++)
 	    new_fixups[i] = state->fixups[i];
@@ -219,7 +227,8 @@ add_known_fixup(Fixup f, State * state)
 }
 
 static int
-add_linked_fixup(enum fixup_kind kind, unsigned value, int next, State * state)
+add_linked_fixup(enum fixup_kind kind, unsigned value, int next,
+		 State * state)
 {
     Fixup f;
 
@@ -256,9 +265,9 @@ add_literal(Var v, State * state)
 	/* New literal to intern */
 	if (gstate->num_literals == gstate->max_literals) {
 	    unsigned new_max = gstate->max_literals == 0
-	    ? 5 : 2 * gstate->max_literals;
+		? 5 : 2 * gstate->max_literals;
 	    Var *new_literals = (Var *) mymalloc(sizeof(Var) * new_max,
-					 M_CODE_GEN);
+						 M_CODE_GEN);
 
 	    if (gstate->literals) {
 		for (i = 0; i < gstate->num_literals; i++)
@@ -273,7 +282,7 @@ add_literal(Var v, State * state)
 	    /* intern string if we can */
 	    Var nv;
 
-	    nv.type = (var_type)TYPE_STR;
+	    nv.type = (var_type) TYPE_STR;
 	    nv.v.str = str_intern(v.v.str);
 	    gstate->literals[i = gstate->num_literals++] = nv;
 	} else {
@@ -294,9 +303,10 @@ add_fork(Bytecodes b, State * state)
 
     if (gstate->num_fork_vectors == gstate->max_fork_vectors) {
 	unsigned new_max = gstate->max_fork_vectors == 0
-	? 1 : 2 * gstate->max_fork_vectors;
-	Bytecodes *new_fv = (Bytecodes *) mymalloc(sizeof(Bytecodes) * new_max,
-				     M_CODE_GEN);
+	    ? 1 : 2 * gstate->max_fork_vectors;
+	Bytecodes *new_fv =
+	    (Bytecodes *) mymalloc(sizeof(Bytecodes) * new_max,
+				   M_CODE_GEN);
 
 	if (gstate->fork_vectors) {
 	    for (i = 0; i < gstate->num_fork_vectors; i++)
@@ -454,7 +464,7 @@ enter_loop(int id, Fixup top_label, unsigned top_stack,
     if (state->num_loops == state->max_loops) {
 	unsigned new_max = 2 * state->max_loops;
 	Loop *new_loops = (Loop *) mymalloc(sizeof(Loop) * new_max,
-				   M_CODE_GEN);
+					    M_CODE_GEN);
 
 	for (i = 0; i < state->num_loops; i++)
 	    new_loops[i] = state->loops[i];
@@ -519,12 +529,14 @@ generate_arg_list(Arg_List * args, State * state)
 	emit_byte(OP_MAKE_EMPTY_LIST, state);
 	push_stack(1, state);
     } else {
-	Opcode normal_op = OP_MAKE_SINGLETON_LIST, splice_op = OP_CHECK_LIST_FOR_SPLICE;
+	Opcode normal_op = OP_MAKE_SINGLETON_LIST, splice_op =
+	    OP_CHECK_LIST_FOR_SPLICE;
 	unsigned pop = 0;
 
 	for (; args; args = args->next) {
 	    generate_expr(args->expr, state);
-	    emit_byte(args->kind == ARG_NORMAL ? normal_op : splice_op, state);
+	    emit_byte(args->kind == ARG_NORMAL ? normal_op : splice_op,
+		      state);
 	    pop_stack(pop, state);
 	    normal_op = OP_LIST_ADD_TAIL;
 	    splice_op = OP_LIST_APPEND;
@@ -991,7 +1003,8 @@ generate_stmt(Stmt * stmt, State * state)
 		emit_byte(OP_FORK_WITH_ID, state);
 	    else
 		emit_byte(OP_FORK, state);
-	    add_fork(stmt_to_code(stmt->s.fork.body, state->gstate), state);
+	    add_fork(stmt_to_code(stmt->s.fork.body, state->gstate),
+		     state);
 	    if (stmt->s.fork.id >= 0)
 		add_var_ref(stmt->s.fork.id, state);
 	    pop_stack(1, state);
@@ -1093,8 +1106,8 @@ generate_stmt(Stmt * stmt, State * state)
 		    add_known_label(loop->top_label, state);
 		} else {
 		    add_stack_ref(loop->bottom_stack, state);
-		    loop->bottom_label = add_linked_label(loop->bottom_label,
-							  state);
+		    loop->bottom_label =
+			add_linked_label(loop->bottom_label, state);
 		}
 	    }
 	    break;
@@ -1200,7 +1213,8 @@ stmt_to_code(Stmt * stmt, GState * gstate)
     n_bbd = 0;
     bbd[n_bbd++] = 0;
     bbd[n_bbd++] = state.num_bytes;
-    for (fixup = state.fixups, fix_i = 0; fix_i < state.num_fixups; ++fix_i, ++fixup)
+    for (fixup = state.fixups, fix_i = 0; fix_i < state.num_fixups;
+	 ++fix_i, ++fixup)
 	if (fixup->kind == FIXUP_LABEL || fixup->kind == FIXUP_FORK)
 	    bbd[n_bbd++] = fixup->pc;
     qsort(bbd, n_bbd, sizeof(*bbd), bbd_cmp);
@@ -1322,8 +1336,9 @@ generate_code(Stmt * stmt, DB_Version version)
     if (gstate.literals) {
 	unsigned i;
 
-	prog->literals = (Var *) mymalloc(sizeof(Var) * gstate.num_literals,
-				  M_LIT_LIST);
+	prog->literals =
+	    (Var *) mymalloc(sizeof(Var) * gstate.num_literals,
+			     M_LIT_LIST);
 	prog->num_literals = gstate.num_literals;
 	for (i = 0; i < gstate.num_literals; i++)
 	    prog->literals[i] = gstate.literals[i];
@@ -1336,8 +1351,9 @@ generate_code(Stmt * stmt, DB_Version version)
 	unsigned i;
 
 	prog->fork_vectors =
-          (Bytecodes *) mymalloc(sizeof(Bytecodes) * gstate.num_fork_vectors,
-		     M_FORK_VECTORS);
+	    (Bytecodes *) mymalloc(sizeof(Bytecodes) *
+				   gstate.num_fork_vectors,
+				   M_FORK_VECTORS);
 	prog->fork_vectors_size = gstate.num_fork_vectors;
 	for (i = 0; i < gstate.num_fork_vectors; i++)
 	    prog->fork_vectors[i] = gstate.fork_vectors[i];
@@ -1351,7 +1367,8 @@ generate_code(Stmt * stmt, DB_Version version)
     return prog;
 }
 
-char rcsid_code_gen[] = "$Id: code_gen.c,v 1.11 2002-09-15 23:21:01 xplat Exp $";
+char rcsid_code_gen[] =
+    "$Id: code_gen.c,v 1.11 2002-09-15 23:21:01 xplat Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/db.h b/server/db.h
index 5bbb7ca..bb4d032 100644
--- a/server/db.h
+++ b/server/db.h
@@ -127,9 +127,7 @@ extern void db_set_object_name(Objid oid, const char *name);
 
 extern Objid db_object_parent(Objid);
 extern int db_count_children(Objid);
-extern int db_for_all_children(Objid,
-			       int (*)(void *, Objid),
-			       void *);
+extern int db_for_all_children(Objid, int (*)(void *, Objid), void *);
 				/* The outcome is unspecified if any of the
 				 * following functions are called during a call
 				 * to db_for_all_children():
@@ -149,9 +147,7 @@ extern int db_change_parent(Objid oid, Objid parent);
 
 extern Objid db_object_location(Objid);
 extern int db_count_contents(Objid);
-extern int db_for_all_contents(Objid,
-			       int (*)(void *, Objid),
-			       void *);
+extern int db_for_all_contents(Objid, int (*)(void *, Objid), void *);
 				/* The outcome is unspecified if any of the
 				 * following functions are called during a call
 				 * to db_for_all_contects():
@@ -172,9 +168,9 @@ typedef enum {
     FLAG_OBSOLETE_2,
     FLAG_FERTILE,
     /* NOTE: New permanent flags must always be added here, rather
-     *	     than replacing one of the obsolete ones, since old
-     *	     databases might have old objects around that still have
-     *	     that flag set.
+     *       than replacing one of the obsolete ones, since old
+     *       databases might have old objects around that still have
+     *       that flag set.
      */
 
     /* Temporary flags.
@@ -182,17 +178,16 @@ typedef enum {
      * make sure FLAG_FIRST_TEMP > last permanent flag
      */
     FLAG_FIRST_TEMP = 14
-    /* allows space for the 2 needed by validate_hierarchies(),
-     * just in case int is only 16 bits
-     */
+	/* allows space for the 2 needed by validate_hierarchies(),
+	 * just in case int is only 16 bits
+	 */
 } db_object_flag;
 
 extern int db_object_has_flag(Objid, db_object_flag);
 extern void db_set_object_flag(Objid, db_object_flag);
 extern void db_clear_object_flag(Objid, db_object_flag);
 
-extern int db_object_allows(Objid oid, Objid progr,
-			    db_object_flag flag);
+extern int db_object_allows(Objid oid, Objid progr, db_object_flag flag);
 				/* Returns true iff either OID has FLAG or
 				 * PROGR either is a wizard or owns OID; that
 				 * is, iff PROGR's authority is sufficient to
@@ -221,8 +216,7 @@ typedef enum {
 } db_prop_flag;
 
 extern int db_add_propdef(Objid oid, const char *pname,
-			  Var value, Objid owner,
-			  unsigned flags);
+			  Var value, Objid owner, unsigned flags);
 				/* Returns true (and actually adds the property
 				 * to OID) iff (1) no property named PNAME
 				 * already exists on OID or one of its
@@ -235,8 +229,7 @@ extern int db_add_propdef(Objid oid, const char *pname,
 				 * zero or more elements of `db_prop_flag'.
 				 */
 
-extern int db_rename_propdef(Objid oid, const char *old,
-			     const char *_new);
+extern int db_rename_propdef(Objid oid, const char *old, const char *_new);
 				/* Returns true (and actually renames the
 				 * propdef on OID) iff (1) a propdef with the
 				 * name OLD existed on OID, (2) no property
@@ -255,8 +248,7 @@ extern int db_delete_propdef(Objid, const char *);
 
 extern int db_count_propdefs(Objid);
 extern int db_for_all_propdefs(Objid,
-			       int (*)(void *, const char *),
-			       void *);
+			       int (*)(void *, const char *), void *);
 				/* db_for_all_propdefs() does not change the
 				 * reference counts of the property names
 				 * passed to the given callback function.
@@ -335,8 +327,7 @@ extern void db_set_property_flags(db_prop_handle, unsigned);
 				 * properties.
 				 */
 
-extern int db_property_allows(db_prop_handle, Objid,
-			      db_prop_flag);
+extern int db_property_allows(db_prop_handle, Objid, db_prop_flag);
 				/* Returns true iff either the property has the
 				 * flag or the object either is a wizard or
 				 * owns the property; that is, iff the object's
@@ -402,10 +393,10 @@ extern const char *db_unparse_prep(db_prep_spec);
 				 * persistent.
 				 */
 
-extern int  db_add_verb(Objid oid, const char *vnames,
-			Objid owner, unsigned flags,
-			db_arg_spec dobj, db_prep_spec prep,
-			db_arg_spec iobj);
+extern int db_add_verb(Objid oid, const char *vnames,
+		       Objid owner, unsigned flags,
+		       db_arg_spec dobj, db_prep_spec prep,
+		       db_arg_spec iobj);
 				/* This function does not change the reference
 				 * count of the NAMES string it accepts.  Thus,
 				 * the caller should str_ref() it if it is to
@@ -413,9 +404,7 @@ extern int  db_add_verb(Objid oid, const char *vnames,
 				 */
 
 extern int db_count_verbs(Objid);
-extern int db_for_all_verbs(Objid,
-			    int (*)(void *, const char *),
-			    void *);
+extern int db_for_all_verbs(Objid, int (*)(void *, const char *), void *);
 				/* db_for_all_verbs() does not change the
 				 * reference counts of the verb names
 				 * passed to the given callback function.
@@ -428,7 +417,7 @@ typedef struct {
 } db_verb_handle;
 
 extern db_verb_handle db_find_command_verb(Objid oid, const char *verb,
-					 db_arg_spec dobj, unsigned prep,
+					   db_arg_spec dobj, unsigned prep,
 					   db_arg_spec iobj);
 				/* Returns a handle on the first matching
 				 * verb found defined on OID or one of its
@@ -510,12 +499,10 @@ extern void db_set_verb_program(db_verb_handle, Program *);
 
 extern void db_verb_arg_specs(db_verb_handle h,
 			      db_arg_spec * dobj,
-			      db_prep_spec * prep,
-			      db_arg_spec * iobj);
+			      db_prep_spec * prep, db_arg_spec * iobj);
 extern void db_set_verb_arg_specs(db_verb_handle h,
 				  db_arg_spec dobj,
-				  db_prep_spec prep,
-				  db_arg_spec iobj);
+				  db_prep_spec prep, db_arg_spec iobj);
 
 extern int db_verb_allows(db_verb_handle, Objid, db_verb_flag);
 				/* Returns true iff either the verb has the
diff --git a/server/db_file.c b/server/db_file.c
index 3f7ffae..033d777 100644
--- a/server/db_file.c
+++ b/server/db_file.c
@@ -43,7 +43,7 @@
 static char *input_db_name, *dump_db_name;
 static int dump_generation = 0;
 static const char *header_format_string
-= "** LambdaMOO Database, Format Version %u **\n";
+    = "** LambdaMOO Database, Format Version %u **\n";
 
 DB_Version dbio_input_version;
 
@@ -150,7 +150,8 @@ read_object(void)
     o->propdefs.max_length = 0;
     o->propdefs.l = 0;
     if ((i = dbio_read_num()) != 0) {
-	o->propdefs.l = (Propdef *) mymalloc(i * sizeof(Propdef), M_PROPDEF);
+	o->propdefs.l =
+	    (Propdef *) mymalloc(i * sizeof(Propdef), M_PROPDEF);
 	o->propdefs.cur_length = i;
 	o->propdefs.max_length = i;
 	for (i = 0; i < o->propdefs.cur_length; i++)
@@ -304,7 +305,7 @@ validate_hierarchies()
 #	    undef CHECK
 
 	    /* setup for phase 3:  set two temp flags on every object */
-	    o->flags |= (3<<FLAG_FIRST_TEMP);
+	    o->flags |= (3 << FLAG_FIRST_TEMP);
 	}
     }
 
@@ -340,8 +341,9 @@ validate_hierarchies()
 		}						\
 	    }
 
-	    CHECK(parent,   child,    "child",    sibling, FLAG_FIRST_TEMP);
-	    CHECK(location, contents, "contents", next,    FLAG_FIRST_TEMP+1);
+	    CHECK(parent, child, "child", sibling, FLAG_FIRST_TEMP);
+	    CHECK(location, contents, "contents", next,
+		  FLAG_FIRST_TEMP + 1);
 
 #	    undef CHECK
 	}
@@ -363,11 +365,11 @@ validate_hierarchies()
 		}							\
 	    }
 
-	    CHECK(parent,   "parent",   "child",    FLAG_FIRST_TEMP);
-	    CHECK(location, "location", "contents", FLAG_FIRST_TEMP+1);
+	    CHECK(parent, "parent", "child", FLAG_FIRST_TEMP);
+	    CHECK(location, "location", "contents", FLAG_FIRST_TEMP + 1);
 
 	    /* clear temp flags */
-	    o->flags &= ~(3<<FLAG_FIRST_TEMP);
+	    o->flags &= ~(3 << FLAG_FIRST_TEMP);
 
 #	    undef CHECK
 	}
@@ -380,7 +382,7 @@ validate_hierarchies()
 static const char *
 fmt_verb_name(void *data)
 {
-  db_verb_handle *h = (db_verb_handle *) data;
+    db_verb_handle *h = (db_verb_handle *) data;
     static Stream *s = 0;
 
     if (!s)
@@ -453,12 +455,14 @@ read_db_file(void)
 	}
 	h = db_find_indexed_verb(oid, vnum + 1);	/* DB file is 0-based. */
 	if (!h.ptr) {
-	    errlog("READ_DB_FILE: Unknown verb index: #%d:%d.\n", oid, vnum);
+	    errlog("READ_DB_FILE: Unknown verb index: #%d:%d.\n", oid,
+		   vnum);
 	    return 0;
 	}
 	program = dbio_read_program(dbio_input_version, fmt_verb_name, &h);
 	if (!program) {
-	    errlog("READ_DB_FILE: Unparsable program #%d:%d.\n", oid, vnum);
+	    errlog("READ_DB_FILE: Unparsable program #%d:%d.\n", oid,
+		   vnum);
 	    return 0;
 	}
 	db_set_verb_program(h, program);
@@ -485,120 +489,131 @@ read_db_file(void)
 static int
 write_db_file(const char *reason)
 {
-  Objid oid;
-  Objid max_oid = db_last_used_objid();
-  Verbdef *v;
-  Var user_list;
-  int i;
-  volatile int nprogs = 0;
-  volatile int success = 1;
-
-  for (oid = 0; oid <= max_oid; oid++) {
-    if (valid(oid))
-      for (v = dbpriv_find_object(oid)->verbdefs; v; v = v->next)
-        if (v->program)
-          nprogs++;
-  }
-
-  user_list = db_all_users();
-
-
-  // removed the TRY macro here, to get around a void * error. The
-  // macros TRY, CATCH, ENDTRY are only used in this file in this instance,
-  // so it seemed safe to remove them. The macro FINALLY was never used.
-  // I copied the macro bodies into the below block verbatim, though
-  // the resulting structure is kinda... nonobvious.
-  // --sw june 2009
-
-  //TRY {						
-  {						
-    ES_CtxBlock		ES_ctx;			
-    volatile ES_Value	ES_es = ES_Initialize;  
-							
-    ES_ctx.nx = 0;				
-    ES_ctx._finally = 0;			
-    ES_ctx.link = ES_exceptionStack;		
-    ES_exceptionStack = &ES_ctx;		
-	    						
-    if (setjmp(ES_ctx.jmp) != 0)	
-      ES_es = ES_Exception;			
-		    					
-    while (1) {					
-      if (ES_es == ES_EvalBody) {		
-        /* TRY body goes here */
-
-        {
-          dbio_printf(header_format_string, current_version);
-          dbio_printf("%d\n%d\n%d\n%d\n",
-                      max_oid + 1, nprogs, 0, user_list.v.list[0].v.num);
-          for (i = 1; i <= user_list.v.list[0].v.num; i++)
-	    dbio_write_objid(user_list.v.list[i].v.obj);
-          oklog("%s: Writing %d objects...\n", reason, max_oid + 1);
-          for (oid = 0; oid <= max_oid; oid++) {
-	    write_object(oid);
-	    if (oid == max_oid || log_report_progress())
-              oklog("%s: Done writing %d objects...\n", reason, oid + 1);
-          }
-          oklog("%s: Writing %d MOO verb programs...\n", reason, nprogs);
-          for (i = 0, oid = 0; oid <= max_oid; oid++)
-	    if (valid(oid)) {
-              int vcount = 0;
-
-              for (v = dbpriv_find_object(oid)->verbdefs; v; v = v->next) {
-                if (v->program) {
-                  dbio_printf("#%d:%d\n", oid, vcount);
-                  dbio_write_program(v->program);
-                  if (++i == nprogs || log_report_progress())
-                    oklog("%s: Done writing %d verb programs...\n",
-                          reason, i);
-                }
-                vcount++;
-              }
+    Objid oid;
+    Objid max_oid = db_last_used_objid();
+    Verbdef *v;
+    Var user_list;
+    int i;
+    volatile int nprogs = 0;
+    volatile int success = 1;
+
+    for (oid = 0; oid <= max_oid; oid++) {
+	if (valid(oid))
+	    for (v = dbpriv_find_object(oid)->verbdefs; v; v = v->next)
+		if (v->program)
+		    nprogs++;
+    }
+
+    user_list = db_all_users();
+
+
+    // removed the TRY macro here, to get around a void * error. The
+    // macros TRY, CATCH, ENDTRY are only used in this file in this instance,
+    // so it seemed safe to remove them. The macro FINALLY was never used.
+    // I copied the macro bodies into the below block verbatim, though
+    // the resulting structure is kinda... nonobvious.
+    // --sw june 2009
+
+    //TRY {                                               
+    {
+	ES_CtxBlock ES_ctx;
+	volatile ES_Value ES_es = ES_Initialize;
+
+	ES_ctx.nx = 0;
+	ES_ctx._finally = 0;
+	ES_ctx.link = ES_exceptionStack;
+	ES_exceptionStack = &ES_ctx;
+
+	if (setjmp(ES_ctx.jmp) != 0)
+	    ES_es = ES_Exception;
+
+	while (1) {
+	    if (ES_es == ES_EvalBody) {
+		/* TRY body goes here */
+
+		{
+		    dbio_printf(header_format_string, current_version);
+		    dbio_printf("%d\n%d\n%d\n%d\n",
+				max_oid + 1, nprogs, 0,
+				user_list.v.list[0].v.num);
+		    for (i = 1; i <= user_list.v.list[0].v.num; i++)
+			dbio_write_objid(user_list.v.list[i].v.obj);
+		    oklog("%s: Writing %d objects...\n", reason,
+			  max_oid + 1);
+		    for (oid = 0; oid <= max_oid; oid++) {
+			write_object(oid);
+			if (oid == max_oid || log_report_progress())
+			    oklog("%s: Done writing %d objects...\n",
+				  reason, oid + 1);
+		    }
+		    oklog("%s: Writing %d MOO verb programs...\n", reason,
+			  nprogs);
+		    for (i = 0, oid = 0; oid <= max_oid; oid++)
+			if (valid(oid)) {
+			    int vcount = 0;
+
+			    for (v = dbpriv_find_object(oid)->verbdefs; v;
+				 v = v->next) {
+				if (v->program) {
+				    dbio_printf("#%d:%d\n", oid, vcount);
+				    dbio_write_program(v->program);
+				    if (++i == nprogs
+					|| log_report_progress())
+					oklog
+					    ("%s: Done writing %d verb programs...\n",
+					     reason, i);
+				}
+				vcount++;
+			    }
+			}
+		    oklog("%s: Writing forked and suspended tasks...\n",
+			  reason);
+		    write_task_queue();
+		    oklog
+			("%s: Writing list of formerly active connections...\n",
+			 reason);
+		    write_active_connections();
+		}
+		//EXCEPT(dbpriv_dbio_failed)
+		/* TRY body or handler goes here */
+		if (ES_es == ES_EvalBody)
+		    ES_exceptionStack = ES_ctx.link;
+		break;
 	    }
-          oklog("%s: Writing forked and suspended tasks...\n", reason);
-          write_task_queue();
-          oklog("%s: Writing list of formerly active connections...\n", reason);
-          write_active_connections();
-        }
-        //EXCEPT(dbpriv_dbio_failed)
-        /* TRY body or handler goes here */                                         
-        if (ES_es == ES_EvalBody)                                                   
-          ES_exceptionStack = ES_ctx.link;                                        
-        break;                                                                      
-      }                                                                               
-      if (ES_es == ES_Initialize) {                                                   
-        if (ES_ctx.nx >= ES_MaxExceptionsPerScope)                                  
-          panic("Too many EXCEPT clauses!");                                      
-        ES_ctx.array[ES_ctx.nx++] = &dbpriv_dbio_failed;                            
-      } else if (ES_ctx.id == &dbpriv_dbio_failed  ||  &dbpriv_dbio_failed == &ANY) {	
-        int	exception_value = ES_ctx.value;                                         
-                                                                                                
-        ES_exceptionStack = ES_ctx.link;                                            
-        exception_value = exception_value;                                          
-        /* avoid warnings */                                                    
-        /* handler goes here */
+	    if (ES_es == ES_Initialize) {
+		if (ES_ctx.nx >= ES_MaxExceptionsPerScope)
+		    panic("Too many EXCEPT clauses!");
+		ES_ctx.array[ES_ctx.nx++] = &dbpriv_dbio_failed;
+	    } else if (ES_ctx.id == &dbpriv_dbio_failed
+		       || &dbpriv_dbio_failed == &ANY) {
+		int exception_value = ES_ctx.value;
+
+		ES_exceptionStack = ES_ctx.link;
+		exception_value = exception_value;
+		/* avoid warnings */
+		/* handler goes here */
 
-	success = 0;
-        //ENDTRY;
-        /* FINALLY body or handler goes here */		
-        if (ES_ctx._finally  &&  ES_es == ES_Exception)  	
-          ES_RaiseException((Exception *) ES_ctx.id,	
-                            (int) ES_ctx.value);		
-        break;						
-      }							
-      ES_es = ES_EvalBody;					
-    }								
-  }
-
-
-  return success;
+		success = 0;
+		//ENDTRY;
+		/* FINALLY body or handler goes here */
+		if (ES_ctx._finally && ES_es == ES_Exception)
+		    ES_RaiseException((Exception *) ES_ctx.id,
+				      (int) ES_ctx.value);
+		break;
+	    }
+	    ES_es = ES_EvalBody;
+	}
+    }
+
+
+    return success;
 }
 
 typedef enum {
     DUMP_SHUTDOWN, DUMP_CHECKPOINT, DUMP_PANIC
 } Dump_Reason;
 const char *reason_names[] =
-{"DUMPING", "CHECKPOINTING", "PANIC-DUMPING"};
+    { "DUMPING", "CHECKPOINTING", "PANIC-DUMPING" };
 
 static int
 dump_database(Dump_Reason reason)
@@ -628,7 +643,7 @@ dump_database(Dump_Reason reason)
 #else
     if (reason == DUMP_CHECKPOINT) {
 /* bg_name_lookup */
-        switch (fork_server("checkpointer", &checkpoint_pid)) {
+	switch (fork_server("checkpointer", &checkpoint_pid)) {
 /* !bg_name_lookup */
 	case FORK_PARENT:
 	    reset_command_history();
@@ -788,7 +803,8 @@ db_shutdown()
     dump_database(DUMP_SHUTDOWN);
 }
 
-char rcsid_db_file[] = "$Id: db_file.c,v 1.6 2007-11-12 11:17:03 wrog Exp $";
+char rcsid_db_file[] =
+    "$Id: db_file.c,v 1.6 2007-11-12 11:17:03 wrog Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/db_io.c b/server/db_io.c
index 3fc0b46..18100fd 100644
--- a/server/db_io.c
+++ b/server/db_io.c
@@ -57,7 +57,7 @@ dbio_read_line(char *s, int n)
 }
 
 int
-dbio_scanf(const char *format,...)
+dbio_scanf(const char *format, ...)
 {
     va_list args;
     int count;
@@ -108,11 +108,11 @@ dbio_scanf(const char *format,...)
 		n = fscanf(input, "%u", up);
 		goto finish;
 	    case 'l':
-		if ((*(ptr+1)) && (*(ptr+1) == 'f')) {
-			ptr++;
-			dp = va_arg(args, double *);
-			n = fscanf(input, "%lf", dp);
-			goto finish;
+		if ((*(ptr + 1)) && (*(ptr + 1) == 'f')) {
+		    ptr++;
+		    dp = va_arg(args, double *);
+		    n = fscanf(input, "%lf", dp);
+		    goto finish;
 		}
 		panic("DBIO_SCANF: Unsupported directive!");
 	    case 'c':
@@ -231,7 +231,7 @@ dbio_read_var(void)
 	break;
     case _TYPE_STR:
 	r.v.str = dbio_read_string_intern();
-	r.type = (var_type) ( r.type | 128 );
+	r.type = (var_type) (r.type | 128);
 	break;
     case TYPE_OBJ:
     case TYPE_ERR:
@@ -268,7 +268,7 @@ static const char *
 program_name(struct state *s)
 {
     if (!s->fmtr)
-      return (char *)s->data;
+	return (char *) s->data;
     else
 	return (*s->fmtr) (s->data);
 }
@@ -276,21 +276,21 @@ program_name(struct state *s)
 static void
 my_error(void *data, const char *msg)
 {
-  errlog("PARSER: Error in %s:\n", program_name((state *)data));
+    errlog("PARSER: Error in %s:\n", program_name((state *) data));
     errlog("           %s\n", msg);
 }
 
 static void
 my_warning(void *data, const char *msg)
 {
-  oklog("PARSER: Warning in %s:\n", program_name((state *)data));
+    oklog("PARSER: Warning in %s:\n", program_name((state *) data));
     oklog("           %s\n", msg);
 }
 
 static int
 my_getc(void *data)
 {
-  struct state *s = (state *)data;
+    struct state *s = (state *) data;
     int c;
 
     c = fgetc(input);
@@ -305,11 +305,11 @@ my_getc(void *data)
     return c;
 }
 
-static Parser_Client parser_client =
-{my_error, my_warning, my_getc};
+static Parser_Client parser_client = { my_error, my_warning, my_getc };
 
 Program *
-dbio_read_program(DB_Version version, const char *(*fmtr) (void *), void *data)
+dbio_read_program(DB_Version version, const char *(*fmtr) (void *),
+		  void *data)
 {
     struct state s;
 
@@ -333,7 +333,7 @@ dbpriv_set_dbio_output(FILE * f)
 }
 
 void
-dbio_printf(const char *format,...)
+dbio_printf(const char *format, ...)
 {
     va_list args;
 
diff --git a/server/db_io.h b/server/db_io.h
index 5409580..cca2408 100644
--- a/server/db_io.h
+++ b/server/db_io.h
@@ -34,7 +34,7 @@ extern void dbio_read_line(char *s, int n);
 				 * null.  (Like the `fgets()' function.)
 				 */
 
-extern int dbio_scanf(const char *format,...);
+extern int dbio_scanf(const char *format, ...);
 
 extern int dbio_read_num(void);
 extern Objid dbio_read_objid(void);
@@ -80,7 +80,7 @@ extern Program *dbio_read_program(DB_Version version,
  * event.
  */
 
-extern void dbio_printf(const char *format,...);
+extern void dbio_printf(const char *format, ...);
 
 extern void dbio_write_num(int);
 extern void dbio_write_objid(Objid);
diff --git a/server/db_objects.c b/server/db_objects.c
index 090c354..8bd6bdf 100644
--- a/server/db_objects.c
+++ b/server/db_objects.c
@@ -69,13 +69,17 @@ ensure_new_object(void)
 {
     if (max_objects == 0) {
 	max_objects = 100;
-	objects = (Object **) mymalloc(max_objects * sizeof(Object *), M_OBJECT_TABLE);
+	objects =
+	    (Object **) mymalloc(max_objects * sizeof(Object *),
+				 M_OBJECT_TABLE);
     }
     if (num_objects >= max_objects) {
 	int i;
 	Object **_new;
 
-	_new = (Object **) mymalloc(max_objects * 2 * sizeof(Object *), M_OBJECT_TABLE);
+	_new =
+	    (Object **) mymalloc(max_objects * 2 * sizeof(Object *),
+				 M_OBJECT_TABLE);
 	for (i = 0; i < max_objects; i++)
 	    _new[i] = objects[i];
 	myfree(objects, M_OBJECT_TABLE);
@@ -90,7 +94,8 @@ dbpriv_new_object(void)
     Object *o;
 
     ensure_new_object();
-    o = objects[num_objects] = (Object *) mymalloc(sizeof(Object), M_OBJECT);
+    o = objects[num_objects] =
+	(Object *) mymalloc(sizeof(Object), M_OBJECT);
     o->id = num_objects;
     num_objects++;
 
@@ -206,8 +211,7 @@ db_renumber_object(Objid old)
 		    *oidp = _new;
 		}
 		for (oid = o->child;
-		     oid != NOTHING;
-		     oid = objects[oid]->sibling)
+		     oid != NOTHING; oid = objects[oid]->sibling)
 		    objects[oid]->parent = _new;
 	    }
 
@@ -224,8 +228,7 @@ db_renumber_object(Objid old)
 		    *oidp = _new;
 		}
 		for (oid = o->contents;
-		     oid != NOTHING;
-		     oid = objects[oid]->next)
+		     oid != NOTHING; oid = objects[oid]->next)
 		    objects[oid]->location = _new;
 	    }
 
@@ -550,7 +553,8 @@ dbpriv_set_all_users(Var v)
     all_users = v;
 }
 
-char rcsid_db_objects[] = "$Id: db_objects.c,v 1.5 2006-09-07 00:55:02 bjj Exp $";
+char rcsid_db_objects[] =
+    "$Id: db_objects.c,v 1.5 2006-09-07 00:55:02 bjj Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/db_private.h b/server/db_private.h
index 696054b..0ba252e 100644
--- a/server/db_private.h
+++ b/server/db_private.h
@@ -86,15 +86,15 @@ typedef struct Object {
  */
 
 #ifdef RONG
-#define db_priv_affected_callable_verb_lookup() (db_verb_generation++)  
-                                 /* The choice of a new generation. */
+#define db_priv_affected_callable_verb_lookup() (db_verb_generation++)
+				 /* The choice of a new generation. */
 extern unsigned int db_verb_generation;
 #endif
 
 extern void db_priv_affected_callable_verb_lookup(void);
 
-#else /* no cache */
-#define db_priv_affected_callable_verb_lookup() 
+#else				/* no cache */
+#define db_priv_affected_callable_verb_lookup()
 #endif
 
 /*********** Objects ***********/
diff --git a/server/db_properties.c b/server/db_properties.c
index 5fe7ecc..759ad29 100644
--- a/server/db_properties.c
+++ b/server/db_properties.c
@@ -64,8 +64,7 @@ property_defined_at_or_below(const char *pname, int phash, Objid oid)
 	    return 1;
 
     for (c = dbpriv_find_object(oid)->child;
-	 c != NOTHING;
-	 c = dbpriv_find_object(c)->sibling)
+	 c != NOTHING; c = dbpriv_find_object(c)->sibling)
 	if (property_defined_at_or_below(pname, phash, c))
 	    return 1;
 
@@ -109,8 +108,7 @@ insert_prop_recursively(Objid root, int root_pos, Pval pv)
     pv.var.type = TYPE_CLEAR;	/* do after initial insert_prop so only
 				   children will be TYPE_CLEAR */
     for (c = dbpriv_find_object(root)->child;
-	 c != NOTHING;
-	 c = dbpriv_find_object(c)->sibling) {
+	 c != NOTHING; c = dbpriv_find_object(c)->sibling) {
 	int new_prop_count = dbpriv_find_object(c)->propdefs.cur_length;
 
 	insert_prop_recursively(c, new_prop_count + root_pos, pv);
@@ -137,7 +135,8 @@ db_add_propdef(Objid oid, const char *pname, Var value, Objid owner,
 	int new_size = (o->propdefs.max_length == 0
 			? 8 : 2 * o->propdefs.max_length);
 
-	o->propdefs.l = (Propdef *) mymalloc(new_size * sizeof(Propdef), M_PROPDEF);
+	o->propdefs.l =
+	    (Propdef *) mymalloc(new_size * sizeof(Propdef), M_PROPDEF);
 	for (i = 0; i < o->propdefs.max_length; i++)
 	    o->propdefs.l[i] = old_props[i];
 	o->propdefs.max_length = new_size;
@@ -173,7 +172,8 @@ db_rename_propdef(Objid oid, const char *old, const char *_new)
 	    if (mystrcasecmp(old, _new) != 0) {	/* Not changing just the case */
 		h = db_find_property(oid, _new, 0);
 		if (h.ptr
-		|| property_defined_at_or_below(_new, str_hash(_new), oid))
+		    || property_defined_at_or_below(_new, str_hash(_new),
+						    oid))
 		    return 0;
 	    }
 	    free_str(props->l[i].name);
@@ -220,8 +220,7 @@ remove_prop_recursively(Objid root, int root_pos)
 
     remove_prop(root, root_pos);
     for (c = dbpriv_find_object(root)->child;
-	 c != NOTHING;
-	 c = dbpriv_find_object(c)->sibling) {
+	 c != NOTHING; c = dbpriv_find_object(c)->sibling) {
 	int new_prop_count = dbpriv_find_object(c)->propdefs.cur_length;
 
 	remove_prop_recursively(c, new_prop_count + root_pos);
@@ -249,7 +248,9 @@ db_delete_propdef(Objid oid, const char *pname)
 		int new_size = max / 2;
 		Propdef *new_props;
 
-		new_props = (Propdef *) mymalloc(new_size * sizeof(Propdef), M_PROPDEF);
+		new_props =
+		    (Propdef *) mymalloc(new_size * sizeof(Propdef),
+					 M_PROPDEF);
 
 		for (j = 0; j < i; j++)
 		    new_props[j] = props->l[j];
@@ -280,7 +281,8 @@ db_count_propdefs(Objid oid)
 }
 
 int
-db_for_all_propdefs(Objid oid, int (*func) (void *, const char *), void *data)
+db_for_all_propdefs(Objid oid, int (*func) (void *, const char *),
+		    void *data)
 {
     int i;
     Object *o = dbpriv_find_object(oid);
@@ -301,7 +303,7 @@ struct contents_data {
 static int
 add_to_list(void *data, Objid c)
 {
-  struct contents_data *d = (contents_data *)data;
+    struct contents_data *d = (contents_data *) data;
 
     d->i++;
     d->r.v.list[d->i].type = TYPE_OBJ;
@@ -317,7 +319,7 @@ get_bi_value(db_prop_handle h, Var * value)
 
     switch (h.built_in) {
     case BP_NAME:
-      value->type = (var_type)TYPE_STR;
+	value->type = (var_type) TYPE_STR;
 	value->v.str = str_ref(db_object_name(oid));
 	break;
     case BP_OWNER:
@@ -373,32 +375,15 @@ db_find_property(Objid oid, const char *name, Var * value)
 	int hash;
     } ptable[] = {
 	{
-	    "name", BP_NAME, 0
-	},
-	{
-	    "owner", BP_OWNER, 0
-	},
-	{
-	    "programmer", BP_PROGRAMMER, 0
-	},
-	{
-	    "wizard", BP_WIZARD, 0
-	},
-	{
-	    "r", BP_R, 0
-	},
-	{
-	    "w", BP_W, 0
-	},
-	{
-	    "f", BP_F, 0
-	},
-	{
-	    "location", BP_LOCATION, 0
-	},
-	{
-	    "contents", BP_CONTENTS, 0
-	}
+	"name", BP_NAME, 0}, {
+	"owner", BP_OWNER, 0}, {
+	"programmer", BP_PROGRAMMER, 0}, {
+	"wizard", BP_WIZARD, 0}, {
+	"r", BP_R, 0}, {
+	"w", BP_W, 0}, {
+	"f", BP_F, 0}, {
+	"location", BP_LOCATION, 0}, {
+	"contents", BP_CONTENTS, 0}
     };
     static int ptable_init = 0;
     unsigned int i;
@@ -434,14 +419,13 @@ db_find_property(Objid oid, const char *name, Var * value)
 	int length = props->cur_length;
 
 	for (p = 0; p < length; p++, n++) {
-	    if (defs[p].hash == hash
-		&& !mystrcasecmp(defs[p].name, name)) {
+	    if (defs[p].hash == hash && !mystrcasecmp(defs[p].name, name)) {
 		Pval *prop;
 
 		h.definer = o->id;
 		o = dbpriv_find_object(oid);
-		prop  = (Pval *)o->propval + n;
-                h.ptr = (Pval *)o->propval + n;
+		prop = (Pval *) o->propval + n;
+		h.ptr = (Pval *) o->propval + n;
 
 		if (value) {
 		    while (prop->var.type == TYPE_CLEAR) {
@@ -468,7 +452,7 @@ db_property_value(db_prop_handle h)
     if (h.built_in)
 	get_bi_value(h, &value);
     else {
-      Pval *prop = (Pval *)h.ptr;
+	Pval *prop = (Pval *) h.ptr;
 
 	value = prop->var;
     }
@@ -480,7 +464,7 @@ void
 db_set_property_value(db_prop_handle h, Var value)
 {
     if (!h.built_in) {
-      Pval *prop = (Pval *)h.ptr;
+	Pval *prop = (Pval *) h.ptr;
 
 	free_var(prop->var);
 	prop->var = value;
@@ -538,7 +522,7 @@ db_property_owner(db_prop_handle h)
 	panic("Built-in property in DB_PROPERTY_OWNER!");
 	return NOTHING;
     } else {
-      Pval *prop = (Pval *)h.ptr;
+	Pval *prop = (Pval *) h.ptr;
 
 	return prop->owner;
     }
@@ -550,7 +534,7 @@ db_set_property_owner(db_prop_handle h, Objid oid)
     if (h.built_in)
 	panic("Built-in property in DB_SET_PROPERTY_OWNER!");
     else {
-	Pval *prop = (Pval *)h.ptr;
+	Pval *prop = (Pval *) h.ptr;
 
 	prop->owner = oid;
     }
@@ -563,7 +547,7 @@ db_property_flags(db_prop_handle h)
 	panic("Built-in property in DB_PROPERTY_FLAGS!");
 	return 0;
     } else {
-	Pval *prop = (Pval *)h.ptr;
+	Pval *prop = (Pval *) h.ptr;
 
 	return prop->perms;
     }
@@ -575,7 +559,7 @@ db_set_property_flags(db_prop_handle h, unsigned flags)
     if (h.built_in)
 	panic("Built-in property in DB_SET_PROPERTY_FLAGS!");
     else {
-	Pval *prop = (Pval *)h.ptr;
+	Pval *prop = (Pval *) h.ptr;
 
 	prop->perms = flags;
     }
@@ -605,7 +589,9 @@ fix_props(Objid oid, int parent_local, int old, int _new, int common)
 	free_var(me->propval[i].var);
 
     if (local + _new + common != 0) {
-	new_propval = (Pval *) mymalloc((local + _new + common) * sizeof(Pval), M_PVAL);
+	new_propval =
+	    (Pval *) mymalloc((local + _new + common) * sizeof(Pval),
+			      M_PVAL);
 	for (i = 0; i < local; i++)
 	    new_propval[i] = me->propval[i];
 	for (i = 0; i < _new; i++) {
@@ -637,14 +623,12 @@ dbpriv_check_properties_for_chparent(Objid oid, Objid new_parent)
     int i;
 
     for (o = dbpriv_find_object(new_parent);
-	 o;
-	 o = dbpriv_find_object(o->parent)) {
+	 o; o = dbpriv_find_object(o->parent)) {
 	Proplist *props = &o->propdefs;
 
 	for (i = 0; i < props->cur_length; i++)
 	    if (property_defined_at_or_below(props->l[i].name,
-					     props->l[i].hash,
-					     oid))
+					     props->l[i].hash, oid))
 		return 0;
     }
 
@@ -679,7 +663,8 @@ dbpriv_fix_properties_after_chparent(Objid oid, Objid old_parent)
     fix_props(oid, 0, old_props, new_props, common_props);
 }
 
-char rcsid_db_properties[] = "$Id: db_properties.c,v 1.3 1998-12-14 13:17:38 nop Exp $";
+char rcsid_db_properties[] =
+    "$Id: db_properties.c,v 1.3 1998-12-14 13:17:38 nop Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/db_verbs.c b/server/db_verbs.c
index 68ef585..0869f75 100644
--- a/server/db_verbs.c
+++ b/server/db_verbs.c
@@ -43,8 +43,7 @@
  * end, never in the middle, and no entries should every be removed from this
  * list; the list indices are stored raw in the DB file.
  */
-static const char *prep_list[] =
-{
+static const char *prep_list[] = {
     "with/using",
     "at/to",
     "in front of",
@@ -102,7 +101,8 @@ dbpriv_build_prep_table(void)
 	     */
 	    words = parse_into_words(cprep, &nwords);
 
-	    current_alias = (pt_entry *)mymalloc(sizeof(struct pt_entry), M_PREP);
+	    current_alias =
+		(pt_entry *) mymalloc(sizeof(struct pt_entry), M_PREP);
 	    current_alias->nwords = nwords;
 	    current_alias->next = 0;
 	    for (j = 0; j < nwords; j++)
@@ -158,7 +158,7 @@ db_match_prep(const char *prepname)
     first = s[0];
     if (first == '#')
 	first = (++s)[0];
-    prep = (db_prep_spec)strtol(s, &ptr, 10);
+    prep = (db_prep_spec) strtol(s, &ptr, 10);
     if (*ptr == '\0') {
 	free_str(s);
 	if (!isdigit(first) || prep >= NPREPS)
@@ -249,8 +249,7 @@ db_count_verbs(Objid oid)
 
 int
 db_for_all_verbs(Objid oid,
-		 int (*func) (void *data, const char *vname),
-		 void *data)
+		 int (*func) (void *data, const char *vname), void *data)
 {
     Object *o = dbpriv_find_object(oid);
     Verbdef *v;
@@ -305,10 +304,10 @@ db_find_command_verb(Objid oid, const char *verb,
 
     for (o = dbpriv_find_object(oid); o; o = dbpriv_find_object(o->parent))
 	for (v = o->verbdefs; v; v = v->next) {
-          //db_arg_spec vdobj = (v->perms >> DOBJSHIFT) & OBJMASK;
-          //db_arg_spec viobj = (v->perms >> IOBJSHIFT) & OBJMASK;
-          int vdobj = (v->perms >> DOBJSHIFT) & OBJMASK;
-          int viobj = (v->perms >> IOBJSHIFT) & OBJMASK;
+	    //db_arg_spec vdobj = (v->perms >> DOBJSHIFT) & OBJMASK;
+	    //db_arg_spec viobj = (v->perms >> IOBJSHIFT) & OBJMASK;
+	    int vdobj = (v->perms >> DOBJSHIFT) & OBJMASK;
+	    int viobj = (v->perms >> IOBJSHIFT) & OBJMASK;
 
 	    if (verbcasecmp(v->name, verb)
 		&& (vdobj == ASPEC_ANY || vdobj == dobj)
@@ -382,7 +381,8 @@ make_vc_table(int size)
     int i;
 
     vc_size = size;
-    vc_table = (vc_entry **)mymalloc(size * sizeof(vc_entry *), M_VC_TABLE);
+    vc_table =
+	(vc_entry **) mymalloc(size * sizeof(vc_entry *), M_VC_TABLE);
     for (i = 0; i < size; i++) {
 	vc_table[i] = NULL;
     }
@@ -487,7 +487,7 @@ db_find_callable_verb(Objid oid, const char *verb)
 	first_parent_with_verbs = NOTHING;
     }
 
-    hash = str_hash(verb) ^ (~first_parent_with_verbs);		/* ewww, but who cares */
+    hash = str_hash(verb) ^ (~first_parent_with_verbs);	/* ewww, but who cares */
     bucket = hash % vc_size;
 
     for (vc = vc_table[bucket]; vc; vc = vc->next) {
@@ -561,8 +561,7 @@ db_find_defined_verb(Objid oid, const char *vname, int allow_numbers)
     db_verb_handle vh;
 
     if (!allow_numbers ||
-	(num = strtol(vname, &p, 10),
-	 (isspace(*vname) || *p != '\0')))
+	(num = strtol(vname, &p, 10), (isspace(*vname) || *p != '\0')))
 	num = -1;
 
     for (i = 0, v = o->verbdefs; v; v = v->next, i++)
@@ -724,23 +723,25 @@ db_set_verb_program(db_verb_handle vh, Program * program)
 
 void
 db_verb_arg_specs(db_verb_handle vh,
-	     db_arg_spec * dobj, db_prep_spec * prep, db_arg_spec * iobj)
+		  db_arg_spec * dobj, db_prep_spec * prep,
+		  db_arg_spec * iobj)
 {
     handle *h = (handle *) vh.ptr;
     short foo;
 
     if (h) {
-      *dobj = (db_arg_spec) ((h->verbdef->perms >> DOBJSHIFT) & OBJMASK);
-      *prep = (db_prep_spec) h->verbdef->prep;
-      foo = (h->verbdef->perms >> IOBJSHIFT) & OBJMASK;
-      *iobj = (db_arg_spec)foo;
+	*dobj = (db_arg_spec) ((h->verbdef->perms >> DOBJSHIFT) & OBJMASK);
+	*prep = (db_prep_spec) h->verbdef->prep;
+	foo = (h->verbdef->perms >> IOBJSHIFT) & OBJMASK;
+	*iobj = (db_arg_spec) foo;
     } else
 	panic("DB_VERB_ARG_SPECS: Null handle!");
 }
 
 void
 db_set_verb_arg_specs(db_verb_handle vh,
-		   db_arg_spec dobj, db_prep_spec prep, db_arg_spec iobj)
+		      db_arg_spec dobj, db_prep_spec prep,
+		      db_arg_spec iobj)
 {
     handle *h = (handle *) vh.ptr;
 
@@ -764,7 +765,8 @@ db_verb_allows(db_verb_handle h, Objid progr, db_verb_flag flag)
 }
 
 
-char rcsid_db_verbs[] = "$Id: db_verbs.c,v 1.6 2001-01-29 08:38:44 bjj Exp $";
+char rcsid_db_verbs[] =
+    "$Id: db_verbs.c,v 1.6 2001-01-29 08:38:44 bjj Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/decompile.c b/server/decompile.c
index 1fe8830..45879c6 100644
--- a/server/decompile.c
+++ b/server/decompile.c
@@ -149,12 +149,12 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 
     while (ptr < end) {
 	int op_hot = (ptr == hot_byte);
-	Opcode op = (Opcode)*ptr++;
+	Opcode op = (Opcode) * ptr++;
 
 	if (IS_PUSH_n(op)) {
 	    e = alloc_expr(EXPR_ID);
 	    e->e.id = PUSH_n_INDEX(op);
-	    push_expr((Expr *)HOT_OP(e));
+	    push_expr((Expr *) HOT_OP(e));
 	    continue;
 #ifdef BYTECODE_REDUCE_REF
 	} else if (IS_PUSH_CLEAR_n(op)) {
@@ -167,12 +167,12 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 	    e = alloc_expr(EXPR_ID);
 	    e->e.id = PUT_n_INDEX(op);
 	    e = alloc_binary(EXPR_ASGN, e, pop_expr());
-	    push_expr((Expr *)HOT_OP1(e->e.bin.rhs, e));
+	    push_expr((Expr *) HOT_OP1(e->e.bin.rhs, e));
 	    continue;
 	} else if (IS_OPTIM_NUM_OPCODE(op)) {
 	    e = alloc_var(TYPE_INT);
 	    e->e.var.v.num = OPCODE_TO_OPTIM_NUM(op);
-	    push_expr((Expr *)HOT_OP(e));
+	    push_expr((Expr *) HOT_OP(e));
 	    continue;
 	}
 	switch (op) {
@@ -186,13 +186,15 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		int jump_hot;
 
 		s = alloc_stmt(STMT_COND);
-		DECOMPILE(bc, ptr, bc.vector + next - jump_len, &arm_stmts, 0);
-		arm = s->s.cond.arms = alloc_cond_arm(condition, arm_stmts);
+		DECOMPILE(bc, ptr, bc.vector + next - jump_len, &arm_stmts,
+			  0);
+		arm = s->s.cond.arms =
+		    alloc_cond_arm(condition, arm_stmts);
 		HOT_OP1(condition, arm);
 		done = READ_JUMP(jump_hot);
 		HOT_BOTTOM(jump_hot, arm);
-		DECOMPILE(bc, ptr, bc.vector + done, &(s->s.cond.otherwise),
-			  &(arm->next));
+		DECOMPILE(bc, ptr, bc.vector + done,
+			  &(s->s.cond.otherwise), &(arm->next));
 
 		ADD_STMT(s);
 	    }
@@ -206,7 +208,8 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		unsigned done;
 		int jump_hot;
 
-		DECOMPILE(bc, ptr, bc.vector + next - jump_len, &arm_stmts, 0);
+		DECOMPILE(bc, ptr, bc.vector + next - jump_len, &arm_stmts,
+			  0);
 		ADD_ARM(arm = alloc_cond_arm(condition, arm_stmts));
 		HOT_OP1(condition, arm);
 		done = READ_JUMP(jump_hot);
@@ -239,7 +242,7 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		if (top != READ_JUMP(jump_hot))
 		    panic("FOR_LIST jumps to wrong place in DECOMPILE!");
 		HOT_BOTTOM(jump_hot, s);
-		ADD_STMT((Stmt *)HOT_OP2(one, list, s));
+		ADD_STMT((Stmt *) HOT_OP2(one, list, s));
 	    }
 	    break;
 	case OP_FOR_RANGE:
@@ -260,7 +263,7 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		if (top != READ_JUMP(jump_hot))
 		    panic("FOR_RANGE jumps to wrong place in DECOMPILE!");
 		HOT_BOTTOM(jump_hot, s);
-		ADD_STMT((Stmt *)HOT_OP2(from, to, s));
+		ADD_STMT((Stmt *) HOT_OP2(from, to, s));
 	    }
 	    break;
 	case OP_WHILE:
@@ -279,7 +282,7 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		if (top != READ_JUMP(jump_hot))
 		    panic("WHILE jumps to wrong place in DECOMPILE!");
 		HOT_BOTTOM(jump_hot, s);
-		ADD_STMT((Stmt *)HOT_OP1(condition, s));
+		ADD_STMT((Stmt *) HOT_OP1(condition, s));
 	    }
 	    break;
 	case OP_FORK:
@@ -297,19 +300,19 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		(void) decompile(fbc, fbc.vector, fbc.vector + fbc.size,
 				 &(s->s.fork.body), 0);
 		HOT_BOTTOM(hot_byte == fbc.vector + fbc.size - 1, s);
-		ADD_STMT((Stmt *)HOT_OP1(time, s));
+		ADD_STMT((Stmt *) HOT_OP1(time, s));
 	    }
 	    break;
 	case OP_POP:
 	    s = alloc_stmt(STMT_EXPR);
 	    e = s->s.expr = pop_expr();
-	    ADD_STMT((Stmt *)HOT_OP1(e, s));
+	    ADD_STMT((Stmt *) HOT_OP1(e, s));
 	    break;
 	case OP_RETURN:
 	case OP_RETURN0:
 	    s = alloc_stmt(STMT_RETURN);
 	    e = s->s.expr = (op == OP_RETURN ? pop_expr() : 0);
-	    ADD_STMT((Stmt *)HOT(op_hot || (e && e == hot_node), s));
+	    ADD_STMT((Stmt *) HOT(op_hot || (e && e == hot_node), s));
 	    break;
 	case OP_DONE:
 	    if (ptr != end)
@@ -318,12 +321,12 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 	case OP_IMM:
 	    e = alloc_expr(EXPR_VAR);
 	    e->e.var = var_ref(READ_LITERAL());
-	    push_expr((Expr *)HOT_OP(e));
+	    push_expr((Expr *) HOT_OP(e));
 	    break;
 	case OP_G_PUSH:
 	    e = alloc_expr(EXPR_ID);
 	    e->e.id = READ_ID();
-	    push_expr((Expr *)HOT_OP(e));
+	    push_expr((Expr *) HOT_OP(e));
 	    break;
 	case OP_AND:
 	case OP_OR:
@@ -336,14 +339,14 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		    panic("AND/OR jumps to wrong place in DECOMPILE!");
 		e = alloc_binary(op == OP_AND ? EXPR_AND : EXPR_OR,
 				 e, pop_expr());
-		push_expr((Expr *)HOT_OP2(e->e.bin.lhs, e->e.bin.rhs, e));
+		push_expr((Expr *) HOT_OP2(e->e.bin.lhs, e->e.bin.rhs, e));
 	    }
 	    break;
 	case OP_UNARY_MINUS:
 	case OP_NOT:
 	    e = alloc_expr(op == OP_NOT ? EXPR_NOT : EXPR_NEGATE);
 	    e->e.expr = pop_expr();
-	    push_expr((Expr *)HOT_OP1(e->e.expr, e));
+	    push_expr((Expr *) HOT_OP1(e->e.expr, e));
 	    break;
 	case OP_GET_PROP:
 	case OP_PUSH_GET_PROP:
@@ -391,7 +394,7 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 	  finish_binary:
 	    e = pop_expr();
 	    e = alloc_binary(kind, pop_expr(), e);
-	    push_expr((Expr *)HOT_OP2(e->e.bin.lhs, e->e.bin.rhs, e));
+	    push_expr((Expr *) HOT_OP2(e->e.bin.lhs, e->e.bin.rhs, e));
 	    break;
 	case OP_RANGE_REF:
 	    {
@@ -402,7 +405,7 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		e->e.range.base = pop_expr();
 		e->e.range.from = e2;
 		e->e.range.to = e1;
-		push_expr((Expr *)HOT_OP3(e1, e2, e->e.range.base, e));
+		push_expr((Expr *) HOT_OP3(e1, e2, e->e.range.base, e));
 	    }
 	    break;
 	case OP_BI_FUNC_CALL:
@@ -410,12 +413,13 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		Expr *a = pop_expr();
 
 		if (a->kind != EXPR_LIST)
-		    panic("Missing arglist for BI_FUNC_CALL in DECOMPILE!");
+		    panic
+			("Missing arglist for BI_FUNC_CALL in DECOMPILE!");
 		e = alloc_expr(EXPR_CALL);
 		e->e.call.args = a->e.list;
 		dealloc_node(a);
 		e->e.call.func = READ_BYTES(1);
-		push_expr((Expr *)HOT_OP1(a, e));
+		push_expr((Expr *) HOT_OP1(a, e));
 	    }
 	    break;
 	case OP_CALL_VERB:
@@ -427,7 +431,7 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		    panic("Missing arglist for CALL_VERB in DECOMPILE!");
 		e = alloc_verb(pop_expr(), e2, a->e.list);
 		dealloc_node(a);
-		push_expr((Expr *)HOT_OP3(e->e.verb.obj, a, e2, e));
+		push_expr((Expr *) HOT_OP3(e->e.verb.obj, a, e2, e));
 	    }
 	    break;
 	case OP_IF_QUES:
@@ -444,7 +448,9 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		if (ptr != bc.vector + label)
 		    panic("THEN jumps to wrong place in DECOMPILE!");
 		e->e.cond.alternate = pop_expr();
-		push_expr((Expr *)HOT3(op_hot || jump_hot, e->e.cond.condition,
+		push_expr((Expr *)
+			  HOT3(op_hot
+			       || jump_hot, e->e.cond.condition,
 			       e->e.cond.consequent, e->e.cond.alternate,
 			       e));
 	    }
@@ -463,9 +469,10 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		Expr *index = pop_expr();
 
 		e = alloc_binary(EXPR_INDEX, pop_expr(), index);
-		push_expr((Expr *)HOT3(op_hot || asgn_hot,
-			       e->e.bin.lhs, index, rvalue,
-			       alloc_binary(EXPR_ASGN, e, rvalue)));
+		push_expr((Expr *) HOT3(op_hot || asgn_hot,
+					e->e.bin.lhs, index, rvalue,
+					alloc_binary(EXPR_ASGN, e,
+						     rvalue)));
 	    }
 	  finish_indexed_assignment:
 	    /* The remainder of this complex assignment code sequence is
@@ -483,7 +490,7 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 	    e = alloc_expr(EXPR_ID);
 	    e->e.id = READ_ID();
 	    e = alloc_binary(EXPR_ASGN, e, pop_expr());
-	    push_expr((Expr *)HOT_OP1(e->e.bin.rhs, e));
+	    push_expr((Expr *) HOT_OP1(e->e.bin.rhs, e));
 	    break;
 	case OP_PUT_PROP:
 	    {
@@ -491,24 +498,25 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 
 		e = pop_expr();
 		e = alloc_binary(EXPR_PROP, pop_expr(), e);
-		push_expr((Expr *)HOT_OP3(e->e.bin.lhs, e->e.bin.rhs, rvalue,
+		push_expr((Expr *)
+			  HOT_OP3(e->e.bin.lhs, e->e.bin.rhs, rvalue,
 				  alloc_binary(EXPR_ASGN, e, rvalue)));
 	    }
 	    break;
 	case OP_MAKE_EMPTY_LIST:
 	    e = alloc_expr(EXPR_LIST);
 	    e->e.list = 0;
-	    push_expr((Expr *)HOT_OP(e));
+	    push_expr((Expr *) HOT_OP(e));
 	    break;
 	case OP_MAKE_SINGLETON_LIST:
 	    e = alloc_expr(EXPR_LIST);
 	    e->e.list = alloc_arg_list(ARG_NORMAL, pop_expr());
-	    push_expr((Expr *)HOT_OP1(e->e.list->expr, e));
+	    push_expr((Expr *) HOT_OP1(e->e.list->expr, e));
 	    break;
 	case OP_CHECK_LIST_FOR_SPLICE:
 	    e = alloc_expr(EXPR_LIST);
 	    e->e.list = alloc_arg_list(ARG_SPLICE, pop_expr());
-	    push_expr((Expr *)HOT_OP1(e->e.list->expr, e));
+	    push_expr((Expr *) HOT_OP1(e->e.list->expr, e));
 	    break;
 	case OP_LIST_ADD_TAIL:
 	case OP_LIST_APPEND:
@@ -523,7 +531,7 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		for (a = list->e.list; a->next; a = a->next);
 		a->next = alloc_arg_list(op == OP_LIST_APPEND ? ARG_SPLICE
 					 : ARG_NORMAL, e);
-		push_expr((Expr *)HOT_OP1(e, list));
+		push_expr((Expr *) HOT_OP1(e, list));
 	    }
 	    break;
 	case OP_PUSH_TEMP:
@@ -532,7 +540,7 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 	    break;
 	case OP_EXTENDED:
 	    {
-              Extended_Opcode eop = (Extended_Opcode)*ptr++;
+		Extended_Opcode eop = (Extended_Opcode) * ptr++;
 
 		switch (eop) {
 		case EOP_RANGESET:
@@ -546,16 +554,18 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 			e->e.range.to = pop_expr();
 			e->e.range.from = pop_expr();
 			e->e.range.base = pop_expr();
-			push_expr((Expr *)HOT4(op_hot || asgn_hot,
-				       e->e.range.base, e->e.range.from,
-				       e->e.range.to, rvalue,
-				    alloc_binary(EXPR_ASGN, e, rvalue)));
+			push_expr((Expr *) HOT4(op_hot || asgn_hot,
+						e->e.range.base,
+						e->e.range.from,
+						e->e.range.to, rvalue,
+						alloc_binary(EXPR_ASGN, e,
+							     rvalue)));
 		    }
 		    goto finish_indexed_assignment;
 		case EOP_LENGTH:
 		    READ_STACK();
 		    e = alloc_expr(EXPR_LENGTH);
-		    push_expr((Expr *)HOT_OP(e));
+		    push_expr((Expr *) HOT_OP(e));
 		    break;
 		case EOP_EXP:
 		    kind = EXPR_EXP;
@@ -569,15 +579,13 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 			int i, done, is_hot = op_hot;
 
 			for (i = 1, scp = &sc;
-			     i <= nargs;
-			     i++, scp = &((*scp)->next)) {
+			     i <= nargs; i++, scp = &((*scp)->next)) {
 			    int id = READ_ID();
 			    int label = READ_LABEL();
 
 			    *scp = alloc_scatter(i == rest ? SCAT_REST :
-					       label == 0 ? SCAT_REQUIRED
-						 : SCAT_OPTIONAL,
-						 id, 0);
+						 label == 0 ? SCAT_REQUIRED
+						 : SCAT_OPTIONAL, id, 0);
 			    if (label > 1) {
 				(*scp)->label = label;
 				if (next_label)
@@ -596,7 +604,8 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 				Expr *defallt;
 
 				if (ptr != bc.vector + sc->label)
-				    panic("Misplaced default in DECOMPILE!");
+				    panic
+					("Misplaced default in DECOMPILE!");
 				DECOMPILE(bc, ptr,
 					  bc.vector + sc->next_label - 1,
 					  0, 0);
@@ -611,10 +620,13 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 				dealloc_node(defallt);
 				is_hot = (is_hot || ptr == hot_byte);
 				if (*ptr++ != OP_POP)
-				    panic("Missing default POP in DECOMPILE!");
+				    panic
+					("Missing default POP in DECOMPILE!");
 			    }
 			e = alloc_binary(EXPR_ASGN, e, pop_expr());
-			push_expr((Expr *)HOT2(is_hot, e->e.bin.lhs, e->e.bin.rhs, e));
+			push_expr((Expr *)
+				  HOT2(is_hot, e->e.bin.lhs, e->e.bin.rhs,
+				       e));
 			if (ptr != bc.vector + done)
 			    panic("Not at end of scatter in DECOMPILE!");
 		    }
@@ -622,7 +634,7 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		case EOP_PUSH_LABEL:
 		    e = alloc_var(TYPE_INT);
 		    e->e.var.v.num = READ_LABEL();
-		    push_expr((Expr *)HOT_OP(e));
+		    push_expr((Expr *) HOT_OP(e));
 		    break;
 		case EOP_CATCH:
 		    {
@@ -656,7 +668,7 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 			if (ptr != bc.vector + label)
 			    panic("Misplaced handler in DECOMPILE!");
 			is_hot = (is_hot || ptr == hot_byte);
-			op = (Opcode)*ptr++;
+			op = (Opcode) * ptr++;
 			if (op == OPTIM_NUM_TO_OPCODE(1)) {
 			    /* No default expression */
 			    is_hot = (is_hot || ptr == hot_byte);
@@ -670,15 +682,17 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 			} else
 			    panic("Bad default expression in DECOMPILE!");
 			if (ptr != bc.vector + done)
-			    panic("CATCH ends in wrong place in DECOMPILE!");
+			    panic
+				("CATCH ends in wrong place in DECOMPILE!");
 			e = alloc_expr(EXPR_CATCH);
 			e->e._catch._try = try_expr;
 			e->e._catch.codes = a;
 			e->e._catch.except = default_expr;
-			push_expr((Expr *)HOT3(is_hot || (default_expr
-					    && default_expr == hot_node),
-				       label_expr, codes, try_expr,
-				       e));
+			push_expr((Expr *) HOT3(is_hot || (default_expr
+							   && default_expr
+							   == hot_node),
+						label_expr, codes,
+						try_expr, e));
 		    }
 		    break;
 		case EOP_END_CATCH:
@@ -692,7 +706,7 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 			int count = *ptr++, label;
 			unsigned done;
 
-			s = (Stmt *)HOT_OP(alloc_stmt(STMT_TRY_EXCEPT));
+			s = (Stmt *) HOT_OP(alloc_stmt(STMT_TRY_EXCEPT));
 			s->s._catch.excepts = 0;
 			while (count--) {
 			    label_expr = pop_expr();
@@ -709,7 +723,8 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 				     && e->e.var.v.num == 0)
 				a = 0;
 			    else
-				panic("Not a codes expression in DECOMPILE!");
+				panic
+				    ("Not a codes expression in DECOMPILE!");
 			    dealloc_node(e);
 			    ex = alloc_except(-1, a, 0);
 			    ex->label = label;
@@ -727,21 +742,23 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 			    int jump_hot = 0;
 
 			    if (ex->label != ptr - bc.vector)
-				panic("Not at start of handler in DECOMPILE!");
+				panic
+				    ("Not at start of handler in DECOMPILE!");
 			    op_hot = (ptr == hot_byte);
-			    op = (Opcode)*ptr++;
+			    op = (Opcode) * ptr++;
 			    if (op == OP_G_PUT) {
 				ex->id = READ_ID();
-				op = (Opcode)*ptr++;
+				op = (Opcode) * ptr++;
 			    } else if (IS_PUT_n(op)) {
 				ex->id = PUT_n_INDEX(op);
-				op = (Opcode)*ptr++;
+				op = (Opcode) * ptr++;
 			    }
 			    HOT(op_hot || ptr - 1 == hot_byte, ex);
 			    if (op != OP_POP)
 				panic("Missing POP in DECOMPILE!");
 			    if (ex->next)
-				stop = bc.vector + ex->next->label - jump_len;
+				stop =
+				    bc.vector + ex->next->label - jump_len;
 			    else
 				stop = bc.vector + done;
 			    DECOMPILE(bc, ptr, stop, &(ex->stmt), 0);
@@ -751,7 +768,8 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 			    HOT_BOTTOM(jump_hot, ex);
 			}
 			if (ptr - bc.vector != done)
-			    panic("EXCEPTS end in wrong place in DECOMPILE!");
+			    panic
+				("EXCEPTS end in wrong place in DECOMPILE!");
 			ADD_STMT(s);
 		    }
 		    break;
@@ -762,7 +780,7 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		    {
 			int label = READ_LABEL();
 
-			s = (Stmt *)HOT_OP(alloc_stmt(STMT_TRY_FINALLY));
+			s = (Stmt *) HOT_OP(alloc_stmt(STMT_TRY_FINALLY));
 			DECOMPILE(bc, ptr, end, &(s->s.finally.body), 0);
 			HOT_POS(ptr++ == hot_byte, s, ENDBODY);
 			if (*ptr++ != EOP_END_FINALLY)
@@ -770,7 +788,8 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 			if (ptr - bc.vector != label)
 			    panic("FINALLY handler in wrong place in "
 				  "DECOMPILE!");
-			DECOMPILE(bc, ptr, end, &(s->s.finally.handler), 0);
+			DECOMPILE(bc, ptr, end, &(s->s.finally.handler),
+				  0);
 			HOT_BOTTOM(ptr++ == hot_byte, s);
 			if (*ptr++ != EOP_CONTINUE)
 			    panic("Missing CONTINUE in DECOMPILE!");
@@ -795,7 +814,7 @@ decompile(Bytecodes bc, Byte * start, Byte * end, Stmt ** stmt_sink,
 		    READ_STACK();
 		    if (READ_LABEL() < ptr - bc.vector)
 			s->kind = STMT_CONTINUE;
-		    ADD_STMT((Stmt *)HOT_OP(s));
+		    ADD_STMT((Stmt *) HOT_OP(s));
 		    break;
 		default:
 		    panic("Unknown extended opcode in DECOMPILE!");
@@ -822,8 +841,7 @@ program_to_tree(Program * prog, int vector, int pc_vector, int pc)
 
     program = prog;
     bc = (pc_vector == MAIN_VECTOR
-	  ? program->main_vector
-	  : program->fork_vectors[pc_vector]);
+	  ? program->main_vector : program->fork_vectors[pc_vector]);
 
     if (pc < 0)
 	hot_byte = 0;
@@ -842,8 +860,7 @@ program_to_tree(Program * prog, int vector, int pc_vector, int pc)
     top_expr_stack = 0;
 
     bc = (vector == MAIN_VECTOR
-	  ? program->main_vector
-	  : program->fork_vectors[vector]);
+	  ? program->main_vector : program->fork_vectors[vector]);
 
     begin_code_allocation();
     decompile(bc, bc.vector, bc.vector + bc.size, &result, 0);
@@ -991,7 +1008,8 @@ find_line_number(Program * prog, int vector, int pc)
     return lineno;
 }
 
-char rcsid_decompile[] = "$Id: decompile.c,v 1.7 2006-12-06 23:51:31 wrog Exp $";
+char rcsid_decompile[] =
+    "$Id: decompile.c,v 1.7 2006-12-06 23:51:31 wrog Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/disassemble.c b/server/disassemble.c
index 4f49797..cb2b511 100644
--- a/server/disassemble.c
+++ b/server/disassemble.c
@@ -37,8 +37,7 @@ struct mapping {
     const char *name;
 };
 
-struct mapping mappings[] =
-{
+struct mapping mappings[] = {
     {OP_IF, "IF"},
     {OP_WHILE, "WHILE"},
     {OP_EIF, "ELSEIF"},
@@ -77,7 +76,7 @@ struct mapping mappings[] =
     {OP_G_PUSH, "PUSH"},
 #ifdef BYTECODE_REDUCE_REF
     {OP_G_PUSH_CLEAR, "PUSH_CLEAR"},
-#endif /* BYTECODE_REDUCE_REF */
+#endif				/* BYTECODE_REDUCE_REF */
     {OP_IMM, "PUSH_LITERAL"},
     {OP_MAKE_EMPTY_LIST, "MAKE_EMPTY_LIST"},
     {OP_LIST_ADD_TAIL, "LIST_ADD_TAIL"},
@@ -89,10 +88,10 @@ struct mapping mappings[] =
     {OP_RETURN, "RETURN"},
     {OP_RETURN0, "RETURN 0"},
     {OP_DONE, "DONE"},
-    {OP_POP, "POP"}};
+    {OP_POP, "POP"}
+};
 
-struct mapping ext_mappings[] =
-{
+struct mapping ext_mappings[] = {
     {EOP_RANGESET, "RANGESET"},
     {EOP_LENGTH, "LENGTH"},
     {EOP_PUSH_LABEL, "PUSH_LABEL"},
@@ -107,7 +106,8 @@ struct mapping ext_mappings[] =
     {EOP_CONTINUE, "CONTINUE"},
     {EOP_WHILE_ID, "WHILE_ID"},
     {EOP_EXIT, "EXIT"},
-    {EOP_EXIT_ID, "EXIT_ID"}};
+    {EOP_EXIT_ID, "EXIT_ID"}
+};
 
 static void
 initialize_tables(void)
@@ -248,8 +248,9 @@ disassemble(Program * prog, Printer p, void *data)
 		stream_printf(insn, "NUM %d", OPCODE_TO_OPTIM_NUM(b));
 #ifdef BYTECODE_REDUCE_REF
 	    else if (IS_PUSH_CLEAR_n(b))
-		stream_printf(insn, "PUSH_CLEAR %s", NAMES(PUSH_CLEAR_n_INDEX(b)));
-#endif /* BYTECODE_REDUCE_REF */
+		stream_printf(insn, "PUSH_CLEAR %s",
+			      NAMES(PUSH_CLEAR_n_INDEX(b)));
+#endif				/* BYTECODE_REDUCE_REF */
 	    else if (IS_PUSH_n(b))
 		stream_printf(insn, "PUSH %s", NAMES(PUSH_n_INDEX(b)));
 	    else if (IS_PUT_n(b))
@@ -277,13 +278,15 @@ disassemble(Program * prog, Printer p, void *data)
 		case EOP_END_CATCH:
 		case EOP_END_EXCEPT:
 		case EOP_TRY_FINALLY:
-		    stream_printf(insn, " %d", ADD_BYTES(bc.numbytes_label));
+		    stream_printf(insn, " %d",
+				  ADD_BYTES(bc.numbytes_label));
 		    break;
 		case EOP_TRY_EXCEPT:
 		    stream_printf(insn, " %d", ADD_BYTES(1));
 		    break;
 		case EOP_LENGTH:
-		    stream_printf(insn, " %d", ADD_BYTES(bc.numbytes_stack));
+		    stream_printf(insn, " %d",
+				  ADD_BYTES(bc.numbytes_stack));
 		    break;
 		case EOP_SCATTER:
 		    {
@@ -314,10 +317,12 @@ disassemble(Program * prog, Printer p, void *data)
 		case OP_OR:
 		case OP_JUMP:
 		case OP_WHILE:
-		    stream_printf(insn, " %d", ADD_BYTES(bc.numbytes_label));
+		    stream_printf(insn, " %d",
+				  ADD_BYTES(bc.numbytes_label));
 		    break;
 		case OP_FORK:
-		    stream_printf(insn, " %d", ADD_BYTES(bc.numbytes_fork));
+		    stream_printf(insn, " %d",
+				  ADD_BYTES(bc.numbytes_fork));
 		    break;
 		case OP_FORK_WITH_ID:
 		    a1 = ADD_BYTES(bc.numbytes_fork);
@@ -333,7 +338,7 @@ disassemble(Program * prog, Printer p, void *data)
 		case OP_G_PUSH:
 #ifdef BYTECODE_REDUCE_REF
 		case OP_G_PUSH_CLEAR:
-#endif /* BYTECODE_REDUCE_REF */
+#endif				/* BYTECODE_REDUCE_REF */
 		case OP_G_PUT:
 		    stream_printf(insn, " %s",
 				  NAMES(ADD_BYTES(bc.numbytes_var_name)));
@@ -360,7 +365,8 @@ disassemble(Program * prog, Printer p, void *data)
 			    stream_add_char(insn, '"');
 			    break;
 			case TYPE_ERR:
-			    stream_printf(insn, " %s", error_name(v.v.err));
+			    stream_printf(insn, " %s",
+					  error_name(v.v.err));
 			    break;
 			default:
 			    stream_printf(insn, " <literal type = %d>",
@@ -370,7 +376,8 @@ disassemble(Program * prog, Printer p, void *data)
 		    }
 		    break;
 		case OP_BI_FUNC_CALL:
-		    stream_printf(insn, " %s", name_func_by_num(ADD_BYTES(1)));
+		    stream_printf(insn, " %s",
+				  name_func_by_num(ADD_BYTES(1)));
 		default:
 		    break;
 		}
@@ -387,7 +394,7 @@ disassemble(Program * prog, Printer p, void *data)
 static void
 print_line(const char *line, void *data)
 {
-  FILE *f = (FILE *)data;
+    FILE *f = (FILE *) data;
 
     fprintf(f, "%s\n", line);
 }
@@ -412,11 +419,12 @@ struct data {
 static void
 add_line(const char *line, void *passed_in_data)
 {
-  struct data *d = (data *)passed_in_data;
+    struct data *d = (data *) passed_in_data;
 
     if (d->used >= d->max) {
 	int new_max = (d->max == 0 ? 20 : d->max * 2);
-	char **_new = (char **) mymalloc(sizeof(char **) * new_max, M_DISASSEMBLE);
+	char **_new =
+	    (char **) mymalloc(sizeof(char **) * new_max, M_DISASSEMBLE);
 	int i;
 
 	for (i = 0; i < d->used; i++)
@@ -458,7 +466,7 @@ bf_disassemble(Var arglist, Byte next, void *vdata, Objid progr)
     disassemble(db_verb_program(h), add_line, &data);
     r = new_list(data.used);
     for (i = 1; i <= data.used; i++) {
-      r.v.list[i].type = (var_type)TYPE_STR;
+	r.v.list[i].type = (var_type) TYPE_STR;
 	r.v.list[i].v.str = data.lines[i - 1];
     }
     if (data.lines)
@@ -469,7 +477,8 @@ bf_disassemble(Var arglist, Byte next, void *vdata, Objid progr)
 void
 register_disassemble(void)
 {
-    register_function("disassemble", 2, 2, bf_disassemble, TYPE_OBJ, TYPE_ANY);
+    register_function("disassemble", 2, 2, bf_disassemble, TYPE_OBJ,
+		      TYPE_ANY);
 }
 
 char rcsid_disassemble[] = "$Id";
diff --git a/server/eval_env.c b/server/eval_env.c
index 9fee244..b770540 100644
--- a/server/eval_env.c
+++ b/server/eval_env.c
@@ -38,7 +38,9 @@ new_rt_env(unsigned size)
 	ret = ready_size_rt_envs;
 	ready_size_rt_envs = ret[0].v.list;
     } else
-	ret = (Var *) mymalloc(MAX(size, NUM_READY_VARS) * sizeof(Var), M_RT_ENV);
+	ret =
+	    (Var *) mymalloc(MAX(size, NUM_READY_VARS) * sizeof(Var),
+			     M_RT_ENV);
 
     for (i = 0; i < size; i++)
 	ret[i].type = TYPE_NONE;
@@ -110,7 +112,7 @@ void
 set_rt_env_str(Var * env, int slot, const char *s)
 {
     Var v;
-    v.type = (var_type)TYPE_STR;
+    v.type = (var_type) TYPE_STR;
     v.v.str = s;
     env[slot] = v;
 }
@@ -121,7 +123,8 @@ set_rt_env_var(Var * env, int slot, Var v)
     env[slot] = v;
 }
 
-char rcsid_rt_env[] = "$Id: eval_env.c,v 1.5 1998-12-14 13:17:44 nop Exp $";
+char rcsid_rt_env[] =
+    "$Id: eval_env.c,v 1.5 1998-12-14 13:17:44 nop Exp $";
 
 
 /* 
diff --git a/server/eval_vm.c b/server/eval_vm.c
index f428e8d..8b2799e 100644
--- a/server/eval_vm.c
+++ b/server/eval_vm.c
@@ -34,7 +34,8 @@ new_vm(int task_id, int stack_size)
     vm the_vm = (vmstruct *) mymalloc(sizeof(vmstruct), M_VM);
 
     the_vm->task_id = task_id;
-    the_vm->activ_stack = (activation *) mymalloc(sizeof(activation) * stack_size, M_VM);
+    the_vm->activ_stack =
+	(activation *) mymalloc(sizeof(activation) * stack_size, M_VM);
 
     return the_vm;
 }
@@ -71,8 +72,7 @@ suspended_lineno_of_vm(vm the_vm)
     top = top_activ(the_vm);
     return find_line_number(top.prog, (the_vm->top_activ_stack == 0
 				       ? the_vm->root_activ_vector
-				       : MAIN_VECTOR),
-			    top.error_pc);
+				       : MAIN_VECTOR), top.error_pc);
 }
 
 /**** read/write data base ****/
@@ -120,7 +120,8 @@ read_vm(int task_id)
     return the_vm;
 }
 
-char rcsid_eval_vm[] = "$Id: eval_vm.c,v 1.4 2002-08-18 09:47:26 bjj Exp $";
+char rcsid_eval_vm[] =
+    "$Id: eval_vm.c,v 1.4 2002-08-18 09:47:26 bjj Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/exceptions.c b/server/exceptions.c
index b20e137..88efac3 100644
--- a/server/exceptions.c
+++ b/server/exceptions.c
@@ -63,7 +63,8 @@ ES_RaiseException(Exception * exception, int value)
     longjmp(cb->jmp, 1);
 }
 
-char rcsid_exceptions[] = "$Id: exceptions.c,v 1.3 1998-12-14 13:17:48 nop Exp $";
+char rcsid_exceptions[] =
+    "$Id: exceptions.c,v 1.3 1998-12-14 13:17:48 nop Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/execute.c b/server/execute.c
index 80583a2..8bd9013 100644
--- a/server/execute.c
+++ b/server/execute.c
@@ -94,7 +94,9 @@ alloc_rt_stack(activation * a, int size)
 	res = rt_stack_quick;
 	rt_stack_quick = rt_stack_quick[0].v.list;
     } else {
-	res = (Var *) mymalloc(MAX(size, RT_STACK_QUICKSIZE) * sizeof(Var), M_RT_STACK);
+	res =
+	    (Var *) mymalloc(MAX(size, RT_STACK_QUICKSIZE) * sizeof(Var),
+			     M_RT_STACK);
     }
     a->base_rt_stack = a->top_rt_stack = res;
     a->rt_stack_size = size;
@@ -160,7 +162,7 @@ output_to_list(const char *line)
 {
     Var str;
 
-    str.type = (var_type)TYPE_STR;
+    str.type = (var_type) TYPE_STR;
     str.v.str = str_dup(line);
     backtrace_list = listappend(backtrace_list, str);
 }
@@ -265,8 +267,7 @@ unwind_stack(Finally_Reason why, Var value, enum outcome *outcome)
 	if (top_activ_stack == 0) {	/* done */
 	    if (outcome)
 		*outcome = (why == FIN_RETURN
-			    ? OUTCOME_DONE
-			    : OUTCOME_ABORTED);
+			    ? OUTCOME_DONE : OUTCOME_ABORTED);
 	    return 1;
 	}
 	top_activ_stack--;
@@ -325,8 +326,8 @@ unwind_stack(Finally_Reason why, Var value, enum outcome *outcome)
 		 * the future.
 		 */
 		do {
-		    p = call_bi_func(bi_func_id, zero, bi_func_pc, a->progr,
-				     bi_func_data);
+		    p = call_bi_func(bi_func_id, zero, bi_func_pc,
+				     a->progr, bi_func_data);
 		    switch (p.kind) {
 		    case package::BI_RETURN:
 			free_var(p.u.ret);
@@ -340,14 +341,15 @@ unwind_stack(Finally_Reason why, Var value, enum outcome *outcome)
 		    case package::BI_KILL:
 			break;
 		    case package::BI_CALL:
-			free_activation(&activ_stack[top_activ_stack--], 0);
+			free_activation(&activ_stack[top_activ_stack--],
+					0);
 			bi_func_pc = p.u.call.pc;
 			bi_func_data = p.u.call.data;
 			break;
 		    }
-		} while (p.kind == p.BI_CALL && bi_func_pc != 0);		/* !tailcall */
+		} while (p.kind == p.BI_CALL && bi_func_pc != 0);	/* !tailcall */
 	    }
-	} else if (why == FIN_RETURN) {		/* Push the value on the stack & go */
+	} else if (why == FIN_RETURN) {	/* Push the value on the stack & go */
 	    a = &(activ_stack[top_activ_stack]);
 	    *(a->top_rt_stack++) = value;
 	    return 0;
@@ -402,7 +404,7 @@ make_stack_list(activation * stack, int start, int end, int include_end,
 	    v = r.v.list[j++] = new_list(line_numbers_too ? 6 : 5);
 	    v.v.list[1].type = TYPE_OBJ;
 	    v.v.list[1].v.obj = stack[i].self;
-	    v.v.list[2].type = (var_type)TYPE_STR;
+	    v.v.list[2].type = (var_type) TYPE_STR;
 	    v.v.list[2].v.str = str_ref(stack[i].verb);
 	    v.v.list[3].type = TYPE_OBJ;
 	    v.v.list[3].v.obj = stack[i].progr;
@@ -422,8 +424,9 @@ make_stack_list(activation * stack, int start, int end, int include_end,
 	    v = r.v.list[j++] = new_list(line_numbers_too ? 6 : 5);
 	    v.v.list[1].type = TYPE_OBJ;
 	    v.v.list[1].v.obj = NOTHING;
-	    v.v.list[2].type = (var_type)TYPE_STR;
-	    v.v.list[2].v.str = str_dup(name_func_by_num(stack[i].bi_func_id));
+	    v.v.list[2].type = (var_type) TYPE_STR;
+	    v.v.list[2].v.str =
+		str_dup(name_func_by_num(stack[i].bi_func_id));
 	    v.v.list[3].type = TYPE_OBJ;
 	    v.v.list[3].v.obj = NOTHING;
 	    v.v.list[4].type = TYPE_OBJ;
@@ -466,7 +469,7 @@ raise_error(package p, enum outcome *outcome)
 	handler_activ = 0;	/* get entire stack in list */
     }
     value.v.list[1] = p.u.raise.code;
-    value.v.list[2].type = (var_type)TYPE_STR;
+    value.v.list[2].type = (var_type) TYPE_STR;
     value.v.list[2].v.str = p.u.raise.msg;
     value.v.list[3] = p.u.raise.value;
     value.v.list[4] = make_stack_list(activ_stack, handler_activ,
@@ -488,7 +491,7 @@ abort_task(int is_ticks)
 		       : "Task ran out of seconds");
 
     value = new_list(3);
-    value.v.list[1].type = (var_type)TYPE_STR;
+    value.v.list[1].type = (var_type) TYPE_STR;
     value.v.list[1].v.str = str_dup(is_ticks ? "ticks" : "seconds");
     value.v.list[2] = make_stack_list(activ_stack, 0, top_activ_stack, 1,
 				      root_activ_vector, 1);
@@ -534,7 +537,8 @@ free_activation(activation * ap, char data_too)
 /** Set up another activation for calling a verb
   does not change the vm in case of any error **/
 
-enum error call_verb2(Objid self, const char *vname, Var args, int do_pass);
+enum error call_verb2(Objid self, const char *vname, Var args,
+		      int do_pass);
 
 /*
  * Historical interface for things which want to call with vname not
@@ -628,7 +632,7 @@ call_verb2(Objid self, const char *vname, Var args, int do_pass)
 
 #undef ENV_COPY
 
-    v.type = (var_type)TYPE_STR;
+    v.type = (var_type) TYPE_STR;
     v.v.str = str_ref(vname);
     set_rt_env_var(env, SLOT_VERB, v);	/* no var_dup */
     set_rt_env_var(env, SLOT_ARGS, args);	/* no var_dup */
@@ -785,7 +789,7 @@ do {    						    	\
     for (;;) {
       next_opcode:
 	error_bv = bv;
-	op = (Opcode)*bv++;
+	op = (Opcode) * bv++;
 
 	if (COUNT_TICK(op)) {
 	    if (--ticks_remaining <= 0) {
@@ -813,8 +817,7 @@ do {    						    	\
 		if (!is_true(cond)) {	/* jump if false */
 		    unsigned lab = READ_BYTES(bv, bc.numbytes_label);
 		    JUMP(lab);
-		}
-		else {
+		} else {
 		    SKIP_BYTES(bv, bc.numbytes_label);
 		}
 		free_var(cond);
@@ -847,7 +850,8 @@ do {    						    	\
 		    JUMP(lab);
 		} else {
 		    free_var(RUN_ACTIV.rt_env[id]);
-		    RUN_ACTIV.rt_env[id] = var_ref(list.v.list[count.v.num]);
+		    RUN_ACTIV.rt_env[id] =
+			var_ref(list.v.list[count.v.num]);
 		    count.v.num++;	/* increment count */
 		    TOP_RT_VALUE = count;
 		}
@@ -956,16 +960,18 @@ do {    						    	\
 		/* whole thing should mean list[index] = value */
 		if ((list.type != TYPE_LIST && list.type != TYPE_STR)
 		    || index.type != TYPE_INT
-		  || (list.type == TYPE_STR && value.type != TYPE_STR)) {
+		    || (list.type == TYPE_STR && value.type != TYPE_STR)) {
 		    free_var(value);
 		    free_var(index);
 		    free_var(list);
 		    PUSH_ERROR(E_TYPE);
 		} else if (index.v.num < 1
 			   || (list.type == TYPE_LIST
-		       && index.v.num > list.v.list[0].v.num /* size */ )
+			       && index.v.num >
+			       list.v.list[0].v.num /* size */ )
 			   || (list.type == TYPE_STR
-			    && index.v.num > (int) memo_strlen(list.v.str))) {
+			       && index.v.num >
+			       (int) memo_strlen(list.v.str))) {
 		    free_var(value);
 		    free_var(index);
 		    free_var(list);
@@ -1032,8 +1038,7 @@ do {    						    	\
 		rhs = POP();
 		lhs = POP();
 		ans.type = TYPE_INT;
-		ans.v.num = (op == OP_EQ
-			     ? equality(rhs, lhs, 0)
+		ans.v.num = (op == OP_EQ ? equality(rhs, lhs, 0)
 			     : !equality(rhs, lhs, 0));
 		PUSH(ans);
 		free_var(rhs);
@@ -1069,10 +1074,12 @@ do {    						    	\
 		} else {
 		    switch (rhs.type) {
 		    case TYPE_INT:
-			comparison = compare_integers(lhs.v.num, rhs.v.num);
+			comparison =
+			    compare_integers(lhs.v.num, rhs.v.num);
 			break;
 		    case TYPE_OBJ:
-			comparison = compare_integers(lhs.v.obj, rhs.v.obj);
+			comparison =
+			    compare_integers(lhs.v.obj, rhs.v.obj);
 			break;
 		    case TYPE_ERR:
 			comparison = ((int) lhs.v.err) - ((int) rhs.v.err);
@@ -1102,7 +1109,8 @@ do {    						    	\
 			ans.v.num = (comparison >= 0);
 			break;
 		    default:
-			errlog("RUN: Imposible opcode in comparison: %d\n", op);
+			errlog("RUN: Imposible opcode in comparison: %d\n",
+			       op);
 			break;
 		    }
 		    PUSH(ans);
@@ -1157,7 +1165,8 @@ do {    						    	\
 			ans = do_modulus(lhs, rhs);
 			break;
 		    default:
-			errlog("RUN: Impossible opcode in arith ops: %d\n", op);
+			errlog("RUN: Impossible opcode in arith ops: %d\n",
+			       op);
 			break;
 		    }
 		} else {
@@ -1186,10 +1195,12 @@ do {    						    	\
 		    char *str;
 		    int llen = memo_strlen(lhs.v.str);
 
-		    str = (char *) mymalloc(llen + memo_strlen(rhs.v.str) + 1, M_STRING);
+		    str =
+			(char *) mymalloc(llen + memo_strlen(rhs.v.str) +
+					  1, M_STRING);
 		    strcpy(str, lhs.v.str);
 		    strcpy(str + llen, rhs.v.str);
-		    ans.type = (var_type)TYPE_STR;
+		    ans.type = (var_type) TYPE_STR;
 		    ans.v.str = str;
 		} else {
 		    ans.type = TYPE_ERR;
@@ -1267,7 +1278,8 @@ do {    						    	\
 		    free_var(list);
 		    PUSH_ERROR(E_TYPE);
 		} else if (list.type == TYPE_LIST) {
-		    if (index.v.num <= 0 || index.v.num > list.v.list[0].v.num) {
+		    if (index.v.num <= 0
+			|| index.v.num > list.v.list[0].v.num) {
 			free_var(index);
 			free_var(list);
 			PUSH_ERROR(E_RANGE);
@@ -1322,8 +1334,9 @@ do {    						    	\
 		    free_var(from);
 		    PUSH_ERROR(E_TYPE);
 		} else {
-		    int len = (base.type == TYPE_STR ? memo_strlen(base.v.str)
-			       : base.v.list[0].v.num);
+		    int len =
+			(base.type == TYPE_STR ? memo_strlen(base.v.str)
+			 : base.v.list[0].v.num);
 		    if (from.v.num <= to.v.num
 			&& (from.v.num <= 0 || from.v.num > len
 			    || to.v.num <= 0 || to.v.num > len)) {
@@ -1355,7 +1368,8 @@ do {    						    	\
 	    {
 		Var value;
 
-		value = RUN_ACTIV.rt_env[READ_BYTES(bv, bc.numbytes_var_name)];
+		value =
+		    RUN_ACTIV.rt_env[READ_BYTES(bv, bc.numbytes_var_name)];
 		if (value.type == TYPE_NONE)
 		    PUSH_ERROR(E_VARNF);
 		else
@@ -1386,8 +1400,10 @@ do {    						    	\
 		    if (!h.ptr)
 			PUSH_ERROR(E_PROPNF);
 		    else if (h.built_in
-			 ? bi_prop_protected(h.built_in, RUN_ACTIV.progr)
-		      : !db_property_allows(h, RUN_ACTIV.progr, PF_READ))
+			     ? bi_prop_protected(h.built_in,
+						 RUN_ACTIV.progr)
+			     : !db_property_allows(h, RUN_ACTIV.progr,
+						   PF_READ))
 			PUSH_ERROR(E_PERM);
 		    else if (h.built_in)
 			PUSH(prop);	/* it's already freshly allocated */
@@ -1414,8 +1430,10 @@ do {    						    	\
 		    if (!h.ptr)
 			PUSH_ERROR(E_PROPNF);
 		    else if (h.built_in
-			 ? bi_prop_protected(h.built_in, RUN_ACTIV.progr)
-		      : !db_property_allows(h, RUN_ACTIV.progr, PF_READ))
+			     ? bi_prop_protected(h.built_in,
+						 RUN_ACTIV.progr)
+			     : !db_property_allows(h, RUN_ACTIV.progr,
+						   PF_READ))
 			PUSH_ERROR(E_PERM);
 		    else if (h.built_in)
 			PUSH(prop);
@@ -1461,7 +1479,8 @@ do {    						    	\
 				err = E_TYPE;
 			    else if (!is_wizard(progr)
 				     && (is_user(obj.v.obj)
-				 || progr != db_object_owner(obj.v.obj)))
+					 || progr !=
+					 db_object_owner(obj.v.obj)))
 				err = E_PERM;
 			    break;
 			case BP_OWNER:
@@ -1475,17 +1494,19 @@ do {    						    	\
 			    if (!is_wizard(progr))
 				err = E_PERM;
 			    else if (h.built_in == BP_WIZARD
-			     && !is_true(rhs) != !is_wizard(obj.v.obj)) {
+				     && !is_true(rhs) !=
+				     !is_wizard(obj.v.obj)) {
 				/* Notify only on changes in state; the !'s above
 				 * serve to canonicalize the truth values.
 				 */
 				/* First make sure traceback will be accurate. */
 				STORE_STATE_VARIABLES();
-				oklog("%sWIZARDED: #%d by programmer #%d\n",
-				      is_wizard(obj.v.obj) ? "DE" : "",
-				      obj.v.obj, progr);
+				oklog
+				    ("%sWIZARDED: #%d by programmer #%d\n",
+				     is_wizard(obj.v.obj) ? "DE" : "",
+				     obj.v.obj, progr);
 				print_error_backtrace(is_wizard(obj.v.obj)
-						    ? "Wizard bit unset."
+						      ? "Wizard bit unset."
 						      : "Wizard bit set.",
 						      output_to_log);
 			    }
@@ -1502,7 +1523,8 @@ do {    						    	\
 			    err = E_PERM;
 			    break;
 			default:
-			    panic("Unknown built-in property in OP_PUT_PROP!");
+			    panic
+				("Unknown built-in property in OP_PUT_PROP!");
 			}
 		    }
 
@@ -1538,8 +1560,10 @@ do {    						    	\
 		} else {
 		    enum error e;
 
-		    e = enqueue_forked_task2(RUN_ACTIV, f_index, time.v.num,
-					op == OP_FORK_WITH_ID ? id : -1);
+		    e = enqueue_forked_task2(RUN_ACTIV, f_index,
+					     time.v.num,
+					     op ==
+					     OP_FORK_WITH_ID ? id : -1);
 		    if (e != E_NONE)
 			RAISE_ERROR(e);
 		}
@@ -1664,7 +1688,7 @@ do {    						    	\
 
 	case OP_EXTENDED:
 	    {
-              register enum Extended_Opcode eop = (Extended_Opcode)*bv;
+		register enum Extended_Opcode eop = (Extended_Opcode) * bv;
 		bv++;
 		if (COUNT_EOP_TICK(eop))
 		    ticks_remaining--;
@@ -1679,8 +1703,10 @@ do {    						    	\
 			base = POP();	/* lhs (list or string) */
 			/* base[from..to] = value */
 			if (to.type != TYPE_INT || from.type != TYPE_INT
-			    || (base.type != TYPE_LIST && base.type != TYPE_STR)
-			    || (value.type != TYPE_LIST && value.type != TYPE_STR)
+			    || (base.type != TYPE_LIST
+				&& base.type != TYPE_STR)
+			    || (value.type != TYPE_LIST
+				&& value.type != TYPE_STR)
 			    || (base.type != value.type)) {
 			    free_var(base);
 			    free_var(to);
@@ -1697,9 +1723,11 @@ do {    						    	\
 			    free_var(value);
 			    PUSH_ERROR(E_RANGE);
 			} else if (base.type == TYPE_LIST)
-			    PUSH(listrangeset(base, from.v.num, to.v.num, value));
+			    PUSH(listrangeset
+				 (base, from.v.num, to.v.num, value));
 			else	/* TYPE_STR */
-			    PUSH(strrangeset(base, from.v.num, to.v.num, value));
+			    PUSH(strrangeset
+				 (base, from.v.num, to.v.num, value));
 		    }
 		    break;
 
@@ -1764,17 +1792,20 @@ do {    						    	\
 			    }
 			} else {
 			    nopt_avail = len - nreq;
-			    nrest = (have_rest && len >= nargs ? len - nargs + 1
-				     : 0);
+			    nrest = (have_rest
+				     && len >=
+				     nargs ? len - nargs + 1 : 0);
 			    for (offset = 0, i = 1; i <= nargs; i++) {
-				int id = READ_BYTES(bv, bc.numbytes_var_name);
-				int label = READ_BYTES(bv, bc.numbytes_label);
+				int id =
+				    READ_BYTES(bv, bc.numbytes_var_name);
+				int label =
+				    READ_BYTES(bv, bc.numbytes_label);
 
 				if (i == rest) {	/* rest */
 				    free_var(RUN_ACTIV.rt_env[id]);
-				    RUN_ACTIV.rt_env[id] = sublist(var_ref(list),
-								   i,
-							  i + nrest - 1);
+				    RUN_ACTIV.rt_env[id] =
+					sublist(var_ref(list), i,
+						i + nrest - 1);
 				    offset += nrest - 1;
 				} else if (label == 0) {	/* required */
 				    free_var(RUN_ACTIV.rt_env[id]);
@@ -1785,7 +1816,8 @@ do {    						    	\
 					nopt_avail--;
 					free_var(RUN_ACTIV.rt_env[id]);
 					RUN_ACTIV.rt_env[id] =
-					    var_ref(list.v.list[i + offset]);
+					    var_ref(list.v.
+						    list[i + offset]);
 				    } else {
 					offset--;
 					if (where == 0 && label != 1)
@@ -1808,7 +1840,9 @@ do {    						    	\
 		    {
 			Var v;
 
-			v.type = (eop == EOP_PUSH_LABEL ? TYPE_INT : TYPE_FINALLY);
+			v.type =
+			    (eop ==
+			     EOP_PUSH_LABEL ? TYPE_INT : TYPE_FINALLY);
 			v.v.num = READ_BYTES(bv, bc.numbytes_label);
 			PUSH(v);
 		    }
@@ -1820,7 +1854,8 @@ do {    						    	\
 			Var v;
 
 			v.type = TYPE_CATCH;
-			v.v.num = (eop == EOP_CATCH ? 1 : READ_BYTES(bv, 1));
+			v.v.num =
+			    (eop == EOP_CATCH ? 1 : READ_BYTES(bv, 1));
 			PUSH(v);
 		    }
 		    break;
@@ -1880,8 +1915,9 @@ do {    						    	\
 			case FIN_RETURN:
 			case FIN_UNCAUGHT:
 			    STORE_STATE_VARIABLES();
-                            //unwind_stack(Finally_Reason why, Var value, enum outcome *outcome)
-			    if (unwind_stack((Finally_Reason)why.v.num, v, &outcome))
+			    //unwind_stack(Finally_Reason why, Var value, enum outcome *outcome)
+			    if (unwind_stack
+				((Finally_Reason) why.v.num, v, &outcome))
 				return outcome;
 			    LOAD_STATE_VARIABLES();
 			    break;
@@ -1908,9 +1944,11 @@ do {    						    	\
 
 			v = new_list(2);
 			v.v.list[1].type = TYPE_INT;
-			v.v.list[1].v.num = READ_BYTES(bv, bc.numbytes_stack);
+			v.v.list[1].v.num =
+			    READ_BYTES(bv, bc.numbytes_stack);
 			v.v.list[2].type = TYPE_INT;
-			v.v.list[2].v.num = READ_BYTES(bv, bc.numbytes_label);
+			v.v.list[2].v.num =
+			    READ_BYTES(bv, bc.numbytes_label);
 			STORE_STATE_VARIABLES();
 			unwind_stack(FIN_EXIT, v, 0);
 			LOAD_STATE_VARIABLES();
@@ -2111,11 +2149,11 @@ run_interpreter(char raise, enum error e,
     enum outcome ret;
 
     setup_task_execution_limits(is_fg ? server_int_option("fg_seconds",
-						      DEFAULT_FG_SECONDS)
+							  DEFAULT_FG_SECONDS)
 				: server_int_option("bg_seconds",
 						    DEFAULT_BG_SECONDS),
 				is_fg ? server_int_option("fg_ticks",
-							DEFAULT_FG_TICKS)
+							  DEFAULT_FG_TICKS)
 				: server_int_option("bg_ticks",
 						    DEFAULT_BG_TICKS));
 
@@ -2129,7 +2167,7 @@ run_interpreter(char raise, enum error e,
 
     if (ret == OUTCOME_ABORTED && handler_verb_name) {
 	db_verb_handle h;
-        enum outcome hret;
+	enum outcome hret;
 	Var args, handled, traceback;
 	int i;
 
@@ -2139,12 +2177,12 @@ run_interpreter(char raise, enum error e,
 	    hret = do_server_verb_task(SYSTEM_OBJECT, handler_verb_name,
 				       var_ref(handler_verb_args), h,
 				       activ_stack[0].player, "", &handled,
-				       0/*no-traceback*/);
+				       0 /*no-traceback */ );
 	    if ((hret == OUTCOME_DONE && is_true(handled))
 		|| hret == OUTCOME_BLOCKED) {
 		/* Assume the in-DB code handled it */
 		free_var(args);
-		return OUTCOME_ABORTED;		/* original ret value */
+		return OUTCOME_ABORTED;	/* original ret value */
 	    }
 	}
 	i = args.v.list[0].v.num;
@@ -2170,7 +2208,8 @@ check_activ_stack_size(int max)
 	if (activ_stack)
 	    myfree(activ_stack, M_VM);
 
-	activ_stack = (activation *) mymalloc(sizeof(activation) * max, M_VM);
+	activ_stack =
+	    (activation *) mymalloc(sizeof(activation) * max, M_VM);
 	max_stack_size = max;
     }
 }
@@ -2178,7 +2217,8 @@ check_activ_stack_size(int max)
 static int
 current_max_stack_size(void)
 {
-    int max = server_int_option("max_stack_depth", DEFAULT_MAX_STACK_DEPTH);
+    int max =
+	server_int_option("max_stack_depth", DEFAULT_MAX_STACK_DEPTH);
 
     if (max < DEFAULT_MAX_STACK_DEPTH)
 	max = DEFAULT_MAX_STACK_DEPTH;
@@ -2193,7 +2233,8 @@ current_max_stack_size(void)
 /* procedure to create a new task */
 
 static enum outcome
-do_task(Program * prog, int which_vector, Var * result, int is_fg, int do_db_tracebacks)
+do_task(Program * prog, int which_vector, Var * result, int is_fg,
+	int do_db_tracebacks)
 {				/* which vector determines the vector for the root_activ.
 				   a forked task can also have which_vector == MAIN_VECTOR.
 				   this happens iff it is recovered from a read from disk,
@@ -2205,7 +2246,8 @@ do_task(Program * prog, int which_vector, Var * result, int is_fg, int do_db_tra
     root_activ_vector = which_vector;	/* main or which of the forked */
     alloc_rt_stack(&RUN_ACTIV, (which_vector == MAIN_VECTOR
 				? prog->main_vector.max_stack
-			  : prog->fork_vectors[which_vector].max_stack));
+				: prog->fork_vectors[which_vector].
+				max_stack));
 
     RUN_ACTIV.pc = 0;
     RUN_ACTIV.error_pc = 0;
@@ -2231,12 +2273,14 @@ resume_from_previous_vm(vm the_vm, Var v)
     free_vm(the_vm, 0);
 
     if (v.type == TYPE_ERR)
-	return run_interpreter(1, v.v.err, 0, 0/*bg*/, 1/*traceback*/);
+	return run_interpreter(1, v.v.err, 0, 0 /*bg */ ,
+			       1 /*traceback */ );
     else {
 	/* PUSH_REF(v) */
 	*(RUN_ACTIV.top_rt_stack++) = var_ref(v);
 
-	return run_interpreter(0, E_NONE, 0, 0/*bg*/, 1/*traceback*/);
+	return run_interpreter(0, E_NONE, 0, 0 /*bg */ ,
+			       1 /*traceback */ );
     }
 }
 
@@ -2244,22 +2288,24 @@ resume_from_previous_vm(vm the_vm, Var v)
 /*** external functions ***/
 
 enum outcome
-do_server_verb_task(Objid self, const char *verb, Var args, db_verb_handle h,
-		    Objid player, const char *argstr, Var * result,
-		    int do_db_tracebacks)
+do_server_verb_task(Objid self, const char *verb, Var args,
+		    db_verb_handle h, Objid player, const char *argstr,
+		    Var * result, int do_db_tracebacks)
 {
     return do_server_program_task(self, verb, args, db_verb_definer(h),
 				  db_verb_names(h), db_verb_program(h),
 				  db_verb_owner(h),
 				  db_verb_flags(h) & VF_DEBUG,
-			       player, argstr, result, do_db_tracebacks);
+				  player, argstr, result,
+				  do_db_tracebacks);
 }
 
 enum outcome
 do_server_program_task(Objid self, const char *verb, Var args, Objid vloc,
-		    const char *verbname, Program * program, Objid progr,
-		       int debug, Objid player, const char *argstr,
-		       Var * result, int do_db_tracebacks)
+		       const char *verbname, Program * program,
+		       Objid progr, int debug, Objid player,
+		       const char *argstr, Var * result,
+		       int do_db_tracebacks)
 {
     Var *env;
 
@@ -2287,11 +2333,13 @@ do_server_program_task(Objid self, const char *verb, Var args, Objid vloc,
     set_rt_env_str(env, SLOT_VERB, str_ref(RUN_ACTIV.verb));
     set_rt_env_var(env, SLOT_ARGS, args);
 
-    return do_task(program, MAIN_VECTOR, result, 1/*fg*/, do_db_tracebacks);
+    return do_task(program, MAIN_VECTOR, result, 1 /*fg */ ,
+		   do_db_tracebacks);
 }
 
 enum outcome
-do_input_task(Objid user, Parsed_Command * pc, Objid self, db_verb_handle vh)
+do_input_task(Objid user, Parsed_Command * pc, Objid self,
+	      db_verb_handle vh)
 {
     Program *prog = db_verb_program(vh);
     Var *env;
@@ -2320,7 +2368,7 @@ do_input_task(Objid user, Parsed_Command * pc, Objid self, db_verb_handle vh)
     set_rt_env_str(env, SLOT_VERB, str_ref(pc->verb));
     set_rt_env_var(env, SLOT_ARGS, var_ref(pc->args));
 
-    return do_task(prog, MAIN_VECTOR, 0, 1/*fg*/, 1/*traceback*/);
+    return do_task(prog, MAIN_VECTOR, 0, 1 /*fg */ , 1 /*traceback */ );
 }
 
 enum outcome
@@ -2332,7 +2380,7 @@ do_forked_task(Program * prog, Var * rt_env, activation a, int f_id)
     RUN_ACTIV = a;
     RUN_ACTIV.rt_env = rt_env;
 
-    return do_task(prog, f_id, 0, 0/*bg*/, 1/*traceback*/);
+    return do_task(prog, f_id, 0, 0 /*bg */ , 1 /*traceback */ );
 }
 
 /* this is called from bf_eval to set up stack for an eval call */
@@ -2402,14 +2450,14 @@ bf_call_function(Var arglist, Byte next, void *vdata, Objid progr)
 	    p = call_bi_func(fnum, arglist, next, progr, vdata);
 	}
     } else {			/* return to function */
-      s = (cf_state *)vdata;
+	s = (cf_state *) vdata;
 	fnum = s->fnum;
 	p = call_bi_func(fnum, arglist, next, progr, s->data);
 	free_data(s);
     }
 
     if (p.kind == p.BI_CALL) {
-      s = (cf_state *)alloc_data(sizeof(struct cf_state));
+	s = (cf_state *) alloc_data(sizeof(struct cf_state));
 	s->fnum = fnum;
 	s->data = p.u.call.data;
 	p.u.call.data = s;
@@ -2420,7 +2468,7 @@ bf_call_function(Var arglist, Byte next, void *vdata, Objid progr)
 static void
 bf_call_function_write(void *data)
 {
-  struct cf_state *s = (cf_state *)data;
+    struct cf_state *s = (cf_state *) data;
 
     dbio_printf("bf_call_function data: fname = %s\n",
 		name_func_by_num(s->fnum));
@@ -2430,7 +2478,7 @@ bf_call_function_write(void *data)
 static void *
 bf_call_function_read(void)
 {
-  struct cf_state *s = (cf_state *)alloc_data(sizeof(struct cf_state));
+    struct cf_state *s = (cf_state *) alloc_data(sizeof(struct cf_state));
     const char *line = dbio_read_string();
     const char *hdr = "bf_call_function data: fname = ";
     int hlen = strlen(hdr);
@@ -2439,7 +2487,8 @@ bf_call_function_read(void)
 	line += hlen;
 	if ((s->fnum = number_func_by_name(line)) == FUNC_NOT_FOUND)
 	    errlog("CALL_FUNCTION: Unknown built-in function: %s\n", line);
-	else if (read_bi_func_data(s->fnum, &s->data, pc_for_bi_func_data()))
+	else if (read_bi_func_data
+		 (s->fnum, &s->data, pc_for_bi_func_data()))
 	    return s;
     }
     return 0;
@@ -2451,8 +2500,7 @@ bf_raise(Var arglist, Byte next, void *vdata, Objid progr)
     package p;
     int nargs = arglist.v.list[0].v.num;
     Var code = var_ref(arglist.v.list[1]);
-    const char *msg = (nargs >= 2
-		       ? str_ref(arglist.v.list[2].v.str)
+    const char *msg = (nargs >= 2 ? str_ref(arglist.v.list[2].v.str)
 		       : str_dup(value2str(code)));
     Var value;
 
@@ -2472,14 +2520,12 @@ bf_suspend(Var arglist, Byte next, void *vdata, Objid progr)
     static double seconds;
     int nargs = arglist.v.list[0].v.num;
 
-    if (nargs >= 1)
-    {
-        if (arglist.v.list[1].type == TYPE_INT)
+    if (nargs >= 1) {
+	if (arglist.v.list[1].type == TYPE_INT)
 	    seconds = (double) arglist.v.list[1].v.num;
 	else
 	    seconds = *arglist.v.list[1].v.fnum;
-    }
-    else
+    } else
 	seconds = -1.0;
     free_var(arglist);
 
@@ -2494,8 +2540,7 @@ bf_read(Var arglist, Byte next, void *vdata, Objid progr)
 {
     int argc = arglist.v.list[0].v.num;
     static Objid connection;
-    int non_blocking = (argc >= 2
-			&& is_true(arglist.v.list[2]));
+    int non_blocking = (argc >= 2 && is_true(arglist.v.list[2]));
 
     if (argc >= 1)
 	connection = arglist.v.list[1].v.obj;
@@ -2596,8 +2641,10 @@ bf_callers(Var arglist, Byte next, void *vdata, Objid progr)
 	line_numbers_too = is_true(arglist.v.list[1]);
     free_var(arglist);
 
-    return make_var_pack(make_stack_list(activ_stack, 0, top_activ_stack, 0,
-				   root_activ_vector, line_numbers_too));
+    return
+	make_var_pack(make_stack_list
+		      (activ_stack, 0, top_activ_stack, 0,
+		       root_activ_vector, line_numbers_too));
 }
 
 static package
@@ -2624,11 +2671,12 @@ bf_task_stack(Var arglist, Byte next, void *vdata, Objid progr)
 void
 register_execute(void)
 {
-    register_function_with_read_write("call_function", 1, -1, bf_call_function,
+    register_function_with_read_write("call_function", 1, -1,
+				      bf_call_function,
 				      bf_call_function_read,
-				      bf_call_function_write,
-				      TYPE_STR);
-    register_function("raise", 1, 3, bf_raise, TYPE_ANY, TYPE_STR, TYPE_ANY);
+				      bf_call_function_write, TYPE_STR);
+    register_function("raise", 1, 3, bf_raise, TYPE_ANY, TYPE_STR,
+		      TYPE_ANY);
     register_function("suspend", 0, 1, bf_suspend, TYPE_NUMERIC);
     register_function("read", 0, 2, bf_read, TYPE_OBJ, TYPE_ANY);
 
@@ -2638,7 +2686,8 @@ register_execute(void)
     register_function("set_task_perms", 1, 1, bf_set_task_perms, TYPE_OBJ);
     register_function("caller_perms", 0, 0, bf_caller_perms);
     register_function("callers", 0, 1, bf_callers, TYPE_ANY);
-    register_function("task_stack", 1, 2, bf_task_stack, TYPE_INT, TYPE_ANY);
+    register_function("task_stack", 1, 2, bf_task_stack, TYPE_INT,
+		      TYPE_ANY);
 }
 
 
@@ -2654,7 +2703,8 @@ write_activ_as_pi(activation a)
     dbio_write_var(dummy);
 
     dbio_printf("%d %d %d %d %d %d %d %d %d\n",
-	    a.self, -7, -8, a.player, -9, a.progr, a.vloc, -10, a.debug);
+		a.self, -7, -8, a.player, -9, a.progr, a.vloc, -10,
+		a.debug);
     dbio_write_string("No");
     dbio_write_string("More");
     dbio_write_string("Parse");
@@ -2678,9 +2728,8 @@ read_activ_as_pi(activation * a)
      * of `scanf'...
      */
     if (dbio_scanf("%d %d %d %d %d %d %d %d %d%c",
-		 &a->self, &dummy, &dummy, &a->player, &dummy, &a->progr,
-		   &a->vloc, &dummy, &a->debug, &c) != 10
-	|| c != '\n') {
+		   &a->self, &dummy, &dummy, &a->player, &dummy, &a->progr,
+		   &a->vloc, &dummy, &a->debug, &c) != 10 || c != '\n') {
 	errlog("READ_A: Bad numbers.\n");
 	return 0;
     }
@@ -2816,8 +2865,7 @@ read_activ(activation * a, int which_vector)
 	errlog("READ_ACTIV: Malformed language version\n");
 	return 0;
     } else if (!check_version(version)) {
-	errlog("READ_ACTIV: Unrecognized language version: %d\n",
-	       version);
+	errlog("READ_ACTIV: Unrecognized language version: %d\n", version);
 	return 0;
     }
     if (!(a->prog = dbio_read_program(version,
@@ -2851,7 +2899,8 @@ read_activ(activation * a, int which_vector)
     a->temp = dbio_read_var();
 
     if (dbio_scanf("%u %u%c", &a->pc, &i, &c) != 3) {
-	errlog("READ_ACTIV: bad pc, next. stack_in_use = %d\n", stack_in_use);
+	errlog("READ_ACTIV: bad pc, next. stack_in_use = %d\n",
+	       stack_in_use);
 	return 0;
     }
     a->bi_func_pc = i;
@@ -2869,14 +2918,16 @@ read_activ(activation * a, int which_vector)
     if (a->bi_func_pc != 0) {
 	func_name = dbio_read_string();
 	if ((i = number_func_by_name(func_name)) == FUNC_NOT_FOUND) {
-	    errlog("READ_ACTIV: Unknown built-in function `%s'\n", func_name);
+	    errlog("READ_ACTIV: Unknown built-in function `%s'\n",
+		   func_name);
 	    return 0;
 	}
 	a->bi_func_id = i;
 	if (!read_bi_func_data(a->bi_func_id, &a->bi_func_data,
 			       &a->bi_func_pc)) {
-	    errlog("READ_ACTIV: Bad saved state for built-in function `%s'\n",
-		   func_name);
+	    errlog
+		("READ_ACTIV: Bad saved state for built-in function `%s'\n",
+		 func_name);
 	    return 0;
 	}
     }
@@ -2884,7 +2935,8 @@ read_activ(activation * a, int which_vector)
 }
 
 
-char rcsid_execute[] = "$Id: execute.c,v 1.19 2006-12-06 23:54:53 wrog Exp $";
+char rcsid_execute[] =
+    "$Id: execute.c,v 1.19 2006-12-06 23:54:53 wrog Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/execute.h b/server/execute.h
index 50a2f36..a6a6bd8 100644
--- a/server/execute.h
+++ b/server/execute.h
@@ -98,7 +98,8 @@ extern enum outcome do_input_task(Objid user, Parsed_Command * pc,
 extern enum outcome do_server_verb_task(Objid self, const char *verb,
 					Var args, db_verb_handle h,
 					Objid player, const char *argstr,
-					Var * result, int do_db_tracebacks);
+					Var * result,
+					int do_db_tracebacks);
 extern enum outcome do_server_program_task(Objid self, const char *verb,
 					   Var args, Objid vloc,
 					   const char *verbname,
@@ -117,10 +118,8 @@ extern Objid caller();
 
 extern void write_activ_as_pi(activation);
 extern int read_activ_as_pi(activation *);
-void write_rt_env(const char **var_names, Var * rt_env,
-		  unsigned size);
-int read_rt_env(const char ***old_names, Var ** rt_env,
-		int *old_size);
+void write_rt_env(const char **var_names, Var * rt_env, unsigned size);
+int read_rt_env(const char ***old_names, Var ** rt_env, int *old_size);
 Var *reorder_rt_env(Var * old_rt_env, const char **old_names,
 		    int old_size, Program * prog);
 extern void write_activ(activation a);
diff --git a/server/ext-FUP-1.8/ext-FUP.c b/server/ext-FUP-1.8/ext-FUP.c
index 52cfbd4..162de56 100644
--- a/server/ext-FUP-1.8/ext-FUP.c
+++ b/server/ext-FUP-1.8/ext-FUP.c
@@ -47,26 +47,26 @@
 
 extern int fputs();
 extern struct passwd *getpwuid();
-extern struct group  *getgrgid();
+extern struct group *getgrgid();
 extern int system();
 extern int access();
 extern int atoi();
 
 extern Var do_match(Var arglist, int reverse);
 
-const char     *FUP_version = "1.8";
+const char *FUP_version = "1.8";
 
 int
 matches(char *subject, const char *pattern)
 {
     Var ans, req;
-    int  result;
-    
+    int result;
+
     req = new_list(2);
     req.v.list[1].type = TYPE_STR;
     req.v.list[2].type = TYPE_STR;
-    req.v.list[1].v.str  = str_dup(subject);
-    req.v.list[2].v.str  = str_dup(pattern);
+    req.v.list[1].v.str = str_dup(subject);
+    req.v.list[2].v.str = str_dup(pattern);
     ans = do_match(req, 0);
     result = is_true(ans);
     free_var(ans);
@@ -76,684 +76,693 @@ matches(char *subject, const char *pattern)
 
 void
 remove_LAST_character(theStr)
-char    *theStr;
+    char *theStr;
 {
- theStr[strlen(theStr)-1] = '\0';
+    theStr[strlen(theStr) - 1] = '\0';
 }
 
 void
 remove_special_characters(theStr)
-char	*theStr;
+    char *theStr;
 {
-    register char *cp,*cp2;
+    register char *cp, *cp2;
     char buf[BUF_LEN];
     int currlen = 0;
 
     cp = theStr;
     cp2 = buf;
-    while (( *cp ) && (currlen < BUF_LEN)) {
-        switch (*cp) {
-        case '&':
-        case '|':
-        case ';':
-        case '<':
-        case '>':
-        case '(':
-        case ')':
-        case '\'':
-        case '\\':
-        case '"':
-        case '`':
-        case ':':
-        case '$':
-        case '!':
-        case ' ':
-            cp++;
-            break;
-        default: {
-            *cp2++ = *cp++;
-            currlen++;
-            }
-        }
+    while ((*cp) && (currlen < BUF_LEN)) {
+	switch (*cp) {
+	case '&':
+	case '|':
+	case ';':
+	case '<':
+	case '>':
+	case '(':
+	case ')':
+	case '\'':
+	case '\\':
+	case '"':
+	case '`':
+	case ':':
+	case '$':
+	case '!':
+	case ' ':
+	    cp++;
+	    break;
+	default:{
+		*cp2++ = *cp++;
+		currlen++;
+	    }
+	}
     }
     *cp2 = '\0';
-    strcpy( theStr, buf);
+    strcpy(theStr, buf);
 }
 
 int
 build_dir_name(thePathStr, theDirName, spec)
-char *thePathStr;
-char *theDirName;
-char spec;
+    char *thePathStr;
+    char *theDirName;
+    char spec;
 {
-    char external_files  [BUF_LEN];
-    char localthePathStr [BUF_LEN];
+    char external_files[BUF_LEN];
+    char localthePathStr[BUF_LEN];
     struct stat st;
 
-    if (strlen(thePathStr) > BUF_LEN)  return E_INVARG;
+    if (strlen(thePathStr) > BUF_LEN)
+	return E_INVARG;
 
     strcpy(localthePathStr, thePathStr);
     remove_special_characters(localthePathStr);
-    if (( strstr(localthePathStr,"/.")) ||
-       (!strncmp(localthePathStr,".",1))) {
-     return E_PERM;
+    if ((strstr(localthePathStr, "/.")) ||
+	(!strncmp(localthePathStr, ".", 1))) {
+	return E_PERM;
     }
-    strcpy(external_files,EXTERN_FILES_DIR);
-    sprintf(theDirName,"%s%s", external_files, localthePathStr);
-    
-    if (stat(theDirName, &st) != 0) return E_INVARG;
+    strcpy(external_files, EXTERN_FILES_DIR);
+    sprintf(theDirName, "%s%s", external_files, localthePathStr);
+
+    if (stat(theDirName, &st) != 0)
+	return E_INVARG;
 
     errno = 0;
-    switch (spec)
-	    {
-	    case 'd':
-	      if (!(st.st_mode & S_IFDIR)) return E_INVIND; 	      
-	      break;
-	    case 'r':
-	      if ((access (theDirName, R_OK)) !=0) return E_PERM;
-	      break;
-	    case 'w':
-	      if ((access (theDirName, W_OK)) !=0) return E_PERM;
-	      break;
-	    case 'x':
-	      if ((access (theDirName, X_OK)) !=0) return E_PERM;
-	      break;
-	    default:
-	        return E_ARGS;
-	    }
-     return E_NONE;
+    switch (spec) {
+    case 'd':
+	if (!(st.st_mode & S_IFDIR))
+	    return E_INVIND;
+	break;
+    case 'r':
+	if ((access(theDirName, R_OK)) != 0)
+	    return E_PERM;
+	break;
+    case 'w':
+	if ((access(theDirName, W_OK)) != 0)
+	    return E_PERM;
+	break;
+    case 'x':
+	if ((access(theDirName, X_OK)) != 0)
+	    return E_PERM;
+	break;
+    default:
+	return E_ARGS;
+    }
+    return E_NONE;
 }
 
 int
 build_file_name(thePathStr, theNameStr, theFileName, spec)
-char *thePathStr;
-char *theNameStr;
-char *theFileName;
-char spec;
+    char *thePathStr;
+    char *theNameStr;
+    char *theFileName;
+    char spec;
 {
-    char external_files  [BUF_LEN];
-    char localthePathStr [BUF_LEN];
-    char localtheNameStr [BUF_LEN];
+    char external_files[BUF_LEN];
+    char localthePathStr[BUF_LEN];
+    char localtheNameStr[BUF_LEN];
     struct stat st;
 
 #ifdef EXTERN_FILES_DIR_READ_ONLY
     if (strlen(thePathStr) == 0) {
-       switch (spec)
-       {
-        case 'w':
-        case 'd':
-           return E_PERM;
-           break;
-       }
+	switch (spec) {
+	case 'w':
+	case 'd':
+	    return E_PERM;
+	    break;
+	}
     }
 #endif
 
-    if ((strlen(thePathStr) > BUF_LEN) || 
-        (strlen(theNameStr) > BUF_LEN))  return E_INVARG;
+    if ((strlen(thePathStr) > BUF_LEN) || (strlen(theNameStr) > BUF_LEN))
+	return E_INVARG;
 
     strcpy(localthePathStr, thePathStr);
     strcpy(localtheNameStr, theNameStr);
     remove_special_characters(localthePathStr);
     remove_special_characters(localtheNameStr);
-    
-    if (( strstr(localthePathStr,"/.")) ||
-       (!strncmp(localthePathStr,".",1)) ||
-       (strstr(localtheNameStr,"/"))) {
-     return E_PERM;
-    }
-    strcpy(external_files,EXTERN_FILES_DIR);
-    sprintf(theFileName,"%s%s/%s", external_files, localthePathStr, 
-                                   localtheNameStr);
-    
-    if (stat(theFileName, &st) != 0) return E_INVARG;
+
+    if ((strstr(localthePathStr, "/.")) ||
+	(!strncmp(localthePathStr, ".", 1)) ||
+	(strstr(localtheNameStr, "/"))) {
+	return E_PERM;
+    }
+    strcpy(external_files, EXTERN_FILES_DIR);
+    sprintf(theFileName, "%s%s/%s", external_files, localthePathStr,
+	    localtheNameStr);
+
+    if (stat(theFileName, &st) != 0)
+	return E_INVARG;
 
     errno = 0;
-    switch (spec)
-	    {
-	    case 'd':
-	      if (!(st.st_mode & S_IFDIR)) return E_INVIND; 	      
-	      break;
-	    case 'r':
-	      if ((access (theFileName, R_OK)) !=0) return E_PERM;
-	      break;
-	    case 'w':
-	      if ((access (theFileName, W_OK)) !=0) return E_PERM;
-	      break;
-	    case 'x':
-	      if ((access (theFileName, X_OK)) !=0) return E_PERM;
-	      break;
-	    default:
-	        return E_ARGS;
-	    }
-     return E_NONE;
+    switch (spec) {
+    case 'd':
+	if (!(st.st_mode & S_IFDIR))
+	    return E_INVIND;
+	break;
+    case 'r':
+	if ((access(theFileName, R_OK)) != 0)
+	    return E_PERM;
+	break;
+    case 'w':
+	if ((access(theFileName, W_OK)) != 0)
+	    return E_PERM;
+	break;
+    case 'x':
+	if ((access(theFileName, X_OK)) != 0)
+	    return E_PERM;
+	break;
+    default:
+	return E_ARGS;
+    }
+    return E_NONE;
 }
 
 static package
 bf_fileexists(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename) */
-        char infileName[BUF_LEN];
-        Var ret;
-        
-        ret.type = TYPE_INT;
-        ret.v.num = 1;
-        if (build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,'r') != E_NONE) {
-			ret.v.num = 0;        
-		}
-        free_var(arglist);
-        return make_var_pack(ret);
+{				/* (directory, filename) */
+    char infileName[BUF_LEN];
+    Var ret;
+
+    ret.type = TYPE_INT;
+    ret.v.num = 1;
+    if (build_file_name(arglist.v.list[1].v.str,
+			arglist.v.list[2].v.str,
+			infileName, 'r') != E_NONE) {
+	ret.v.num = 0;
+    }
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 static package
 bf_filelength(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename) */
-        FILE *f ;
-        char infileName[BUF_LEN];
-        int num_lines = -1;
-        char buffer[BUF_LEN];
-        Var ret;
-        int result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,
-                            'r');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-		f = fopen(infileName, "r");
-        for (num_lines = 0; fgets(buffer, BUF_LEN, f); num_lines++);
-        fclose(f);
-        free_var(arglist);
-        ret.type = TYPE_INT;
-        ret.v.num = num_lines;
-        return make_var_pack(ret);
+{				/* (directory, filename) */
+    FILE *f;
+    char infileName[BUF_LEN];
+    int num_lines = -1;
+    char buffer[BUF_LEN];
+    Var ret;
+    int result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, infileName, 'r');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+    f = fopen(infileName, "r");
+    for (num_lines = 0; fgets(buffer, BUF_LEN, f); num_lines++);
+    fclose(f);
+    free_var(arglist);
+    ret.type = TYPE_INT;
+    ret.v.num = num_lines;
+    return make_var_pack(ret);
 }
 
 static package
 bf_filesize(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename) */
-        char infileName[BUF_LEN];
-        struct stat st;
-        Var ret;
-        int result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,
-                            'r');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-	    if (stat(infileName, &st) != 0) {
-	        free_var(arglist);
-	        return make_error_pack(E_INVARG);
-	    }
-        ret.type = TYPE_INT;
-        ret.v.num = (long)st.st_size;
-        free_var(arglist);
-        return make_var_pack(ret);
+{				/* (directory, filename) */
+    char infileName[BUF_LEN];
+    struct stat st;
+    Var ret;
+    int result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, infileName, 'r');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+    if (stat(infileName, &st) != 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+    ret.type = TYPE_INT;
+    ret.v.num = (long) st.st_size;
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 static package
 bf_filewrite(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename, list, [start, end]) */
-
-        FILE *inFile = NULL;
-        FILE *outFile = NULL;
-        char infileName[BUF_LEN];
-        char outfileName[BUF_LEN];
-        int i, thelength;
-        int index;
-        int start_line = 1;
-        int end_line   = MAX_INT;
-        char buffer[BUF_LEN];
-        Var ret, theline;
-        int result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,
-                            'w');
-        if (result == E_PERM) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-        ret.type = TYPE_INT;
-        ret.v.num = 1;
-        theline.type = TYPE_STR;
-
-        sprintf(outfileName,"%s.%li", infileName,time(0));
-
-        if (arglist.v.list[0].v.num > 3) 
-           start_line = arglist.v.list[4].v.num;
-
-       thelength = arglist.v.list[3].v.list[0].v.num;
-
-        if (arglist.v.list[0].v.num > 4) {
-              end_line = arglist.v.list[5].v.num;
-           } else {
-              end_line = arglist.v.list[4].v.num + thelength - 1;
-           }
-
-        if ((outFile = fopen(outfileName, "w")) == 0) {
-           free_var(arglist);
-           return make_error_pack(E_INVARG);
-         }
-
-        inFile = fopen(infileName, "r");
-        index = 1;
-        if (inFile) {
-            while ((index < start_line) && (!feof(inFile))) {
-               fgets(buffer, BUF_LEN, inFile);
-               fputs(buffer,outFile);
-               index++;
-                }
-            while ((index <= end_line) && (!feof(inFile))) {
-               fgets(buffer, BUF_LEN, inFile);
-               index++;
-                }
-         }
+{				/* (directory, filename, list, [start, end]) */
+
+    FILE *inFile = NULL;
+    FILE *outFile = NULL;
+    char infileName[BUF_LEN];
+    char outfileName[BUF_LEN];
+    int i, thelength;
+    int index;
+    int start_line = 1;
+    int end_line = MAX_INT;
+    char buffer[BUF_LEN];
+    Var ret, theline;
+    int result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, infileName, 'w');
+    if (result == E_PERM) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    ret.type = TYPE_INT;
+    ret.v.num = 1;
+    theline.type = TYPE_STR;
+
+    sprintf(outfileName, "%s.%li", infileName, time(0));
+
+    if (arglist.v.list[0].v.num > 3)
+	start_line = arglist.v.list[4].v.num;
+
+    thelength = arglist.v.list[3].v.list[0].v.num;
+
+    if (arglist.v.list[0].v.num > 4) {
+	end_line = arglist.v.list[5].v.num;
+    } else {
+	end_line = arglist.v.list[4].v.num + thelength - 1;
+    }
+
+    if ((outFile = fopen(outfileName, "w")) == 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    inFile = fopen(infileName, "r");
+    index = 1;
+    if (inFile) {
+	while ((index < start_line) && (!feof(inFile))) {
+	    fgets(buffer, BUF_LEN, inFile);
+	    fputs(buffer, outFile);
+	    index++;
+	}
+	while ((index <= end_line) && (!feof(inFile))) {
+	    fgets(buffer, BUF_LEN, inFile);
+	    index++;
+	}
+    }
 
     for (i = 1; i <= thelength; i++) {
-        switch (arglist.v.list[3].v.list[i].type) {
-          case TYPE_INT:
-            fprintf (outFile, "%d\n",  arglist.v.list[3].v.list[i].v.num);
-            break;
-          case TYPE_FLOAT:
-            fprintf (outFile, "%g\n",  *(arglist.v.list[3].v.list[i].v.fnum));
-            break;
-          case TYPE_OBJ:
-            fprintf (outFile, "#%d\n",  arglist.v.list[3].v.list[i].v.obj);
-            break;
-          case TYPE_STR:
-            fprintf (outFile, "%s\n",  arglist.v.list[3].v.list[i].v.str);
-            break;
-          case TYPE_ERR:
-              fprintf (outFile, "%s\n", unparse_error( arglist.v.list[3].v.list[i].v.err));
-            break;
-          case TYPE_LIST:
-            fprintf (outFile,  "%s\n", "{list}");
-            break;
-          default:
-            fprintf (outFile,  "%s\n", "*** unrecognized VAR TYPE (this should never happen) ***");
-        }
-      }
-
-        if (inFile) {
-            while (!feof(inFile)) {
-               fgets(buffer, BUF_LEN, inFile);
-               if (!feof(inFile)) {fputs(buffer,outFile);}
-                }
-        }
-
-        if (outFile) {fclose(outFile);}
-        if (inFile)  {fclose(inFile);} 
-        rename(outfileName,infileName);
-        free_var(arglist);
-        return make_var_pack(ret);
+	switch (arglist.v.list[3].v.list[i].type) {
+	case TYPE_INT:
+	    fprintf(outFile, "%d\n", arglist.v.list[3].v.list[i].v.num);
+	    break;
+	case TYPE_FLOAT:
+	    fprintf(outFile, "%g\n",
+		    *(arglist.v.list[3].v.list[i].v.fnum));
+	    break;
+	case TYPE_OBJ:
+	    fprintf(outFile, "#%d\n", arglist.v.list[3].v.list[i].v.obj);
+	    break;
+	case TYPE_STR:
+	    fprintf(outFile, "%s\n", arglist.v.list[3].v.list[i].v.str);
+	    break;
+	case TYPE_ERR:
+	    fprintf(outFile, "%s\n",
+		    unparse_error(arglist.v.list[3].v.list[i].v.err));
+	    break;
+	case TYPE_LIST:
+	    fprintf(outFile, "%s\n", "{list}");
+	    break;
+	default:
+	    fprintf(outFile, "%s\n",
+		    "*** unrecognized VAR TYPE (this should never happen) ***");
+	}
+    }
+
+    if (inFile) {
+	while (!feof(inFile)) {
+	    fgets(buffer, BUF_LEN, inFile);
+	    if (!feof(inFile)) {
+		fputs(buffer, outFile);
+	    }
+	}
+    }
+
+    if (outFile) {
+	fclose(outFile);
+    }
+    if (inFile) {
+	fclose(inFile);
+    }
+    rename(outfileName, infileName);
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 static package
 bf_fileread(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename [start, end]) */
-
-        FILE *f;
-        char infileName[BUF_LEN];
-        char buffer[BUF_LEN];
-        Var ret, theline;
-        int index;
-        int start_line = 1;
-        int end_line   = MAX_INT;
-         int result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,
-                            'r');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-        if (arglist.v.list[0].v.num > 2)
-                start_line = arglist.v.list[3].v.num;
-
-        if (arglist.v.list[0].v.num > 3)
-                end_line = arglist.v.list[4].v.num;
-     
-        if ((f = fopen(infileName, "r")) == 0) {
-           free_var(arglist);
-           return make_error_pack(E_INVARG);
-        }
-
-        ret.type = TYPE_LIST;
-        ret = new_list(0);
-        theline.type = TYPE_STR;
-
-        index = 1;
-        while ((index < start_line) && (!feof(f))) {
-                fgets(buffer, BUF_LEN, f);
-                index++;
-                }
-
-        while ((index <= end_line) && (!feof(f))) {
-                fgets(buffer, BUF_LEN, f);
-                if (!feof(f)) {
-                   buffer[strlen(buffer)-1] = '\0';
-                   theline.v.str = str_dup(buffer);
-                   ret = listappend(ret, theline);
-                   }
-                index++;
-                }
-
-        fclose(f);
-        free_var(arglist);
-        return make_var_pack(ret);
+{				/* (directory, filename [start, end]) */
+
+    FILE *f;
+    char infileName[BUF_LEN];
+    char buffer[BUF_LEN];
+    Var ret, theline;
+    int index;
+    int start_line = 1;
+    int end_line = MAX_INT;
+    int result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, infileName, 'r');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    if (arglist.v.list[0].v.num > 2)
+	start_line = arglist.v.list[3].v.num;
+
+    if (arglist.v.list[0].v.num > 3)
+	end_line = arglist.v.list[4].v.num;
+
+    if ((f = fopen(infileName, "r")) == 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    ret.type = TYPE_LIST;
+    ret = new_list(0);
+    theline.type = TYPE_STR;
+
+    index = 1;
+    while ((index < start_line) && (!feof(f))) {
+	fgets(buffer, BUF_LEN, f);
+	index++;
+    }
+
+    while ((index <= end_line) && (!feof(f))) {
+	fgets(buffer, BUF_LEN, f);
+	if (!feof(f)) {
+	    buffer[strlen(buffer) - 1] = '\0';
+	    theline.v.str = str_dup(buffer);
+	    ret = listappend(ret, theline);
+	}
+	index++;
+    }
+
+    fclose(f);
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 static package
 bf_fileappend(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename, list) */
-
-        FILE *outFile = NULL;
-        char outfileName[BUF_LEN];
-        int i, thelength;
-        Var ret, theline;
-        int result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            outfileName,
-                            'w');
-        if (result == E_PERM) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-        ret.type = TYPE_INT;
-        ret.v.num = 1;
-        theline.type = TYPE_STR;
-
-        if ((outFile = fopen(outfileName, "a")) == 0) {
-            free_var(arglist);
-            return make_error_pack(E_INVARG);
-        }
-
-      thelength = arglist.v.list[3].v.list[0].v.num;
+{				/* (directory, filename, list) */
+
+    FILE *outFile = NULL;
+    char outfileName[BUF_LEN];
+    int i, thelength;
+    Var ret, theline;
+    int result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, outfileName, 'w');
+    if (result == E_PERM) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    ret.type = TYPE_INT;
+    ret.v.num = 1;
+    theline.type = TYPE_STR;
+
+    if ((outFile = fopen(outfileName, "a")) == 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    thelength = arglist.v.list[3].v.list[0].v.num;
 
     for (i = 1; i <= thelength; i++) {
-        switch (arglist.v.list[3].v.list[i].type) {
-          case TYPE_INT:
-            fprintf (outFile, "%d\n",  arglist.v.list[3].v.list[i].v.num);
-            break;
-          case TYPE_FLOAT:
-            fprintf (outFile, "%g\n",  *(arglist.v.list[3].v.list[i].v.fnum));
-            break;
-          case TYPE_OBJ:
-            fprintf (outFile, "#%d\n",  arglist.v.list[3].v.list[i].v.obj);
-            break;
-          case TYPE_STR:
-            fprintf (outFile, "%s\n",  arglist.v.list[3].v.list[i].v.str);
-            break;
-          case TYPE_ERR:
-              fprintf (outFile, "%s\n", unparse_error( arglist.v.list[3].v.list[i].v.err));
-            break;
-          case TYPE_LIST:
-            fprintf (outFile,  "%s\n", "{list}");
-            break;
-          default:
-            fprintf (outFile,  "%s\n", "*** unrecognized VAR TYPE (this should never happen) ***");
-        }
-      }
-
-        if (outFile) {fclose(outFile);}
-        free_var(arglist);
-        return make_var_pack(ret);
+	switch (arglist.v.list[3].v.list[i].type) {
+	case TYPE_INT:
+	    fprintf(outFile, "%d\n", arglist.v.list[3].v.list[i].v.num);
+	    break;
+	case TYPE_FLOAT:
+	    fprintf(outFile, "%g\n",
+		    *(arglist.v.list[3].v.list[i].v.fnum));
+	    break;
+	case TYPE_OBJ:
+	    fprintf(outFile, "#%d\n", arglist.v.list[3].v.list[i].v.obj);
+	    break;
+	case TYPE_STR:
+	    fprintf(outFile, "%s\n", arglist.v.list[3].v.list[i].v.str);
+	    break;
+	case TYPE_ERR:
+	    fprintf(outFile, "%s\n",
+		    unparse_error(arglist.v.list[3].v.list[i].v.err));
+	    break;
+	case TYPE_LIST:
+	    fprintf(outFile, "%s\n", "{list}");
+	    break;
+	default:
+	    fprintf(outFile, "%s\n",
+		    "*** unrecognized VAR TYPE (this should never happen) ***");
+	}
+    }
+
+    if (outFile) {
+	fclose(outFile);
+    }
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 static package
 bf_filedelete(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename) */
-        char infileName[BUF_LEN];
-        Var ret;
-         int result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,
-                            'w');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
+{				/* (directory, filename) */
+    char infileName[BUF_LEN];
+    Var ret;
+    int result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, infileName, 'w');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
 
     if ((remove(infileName)) != 0) {
-        free_var(arglist);
-        return make_error_pack(E_INVARG);
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
     }
 
-        free_var(arglist);
-        ret.type = TYPE_INT;
-        ret.v.num = 1;
-        return make_var_pack(ret);
+    free_var(arglist);
+    ret.type = TYPE_INT;
+    ret.v.num = 1;
+    return make_var_pack(ret);
 }
 
 
 static package
 bf_filelist(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory) */
-
-        typedef struct dirent MYDIRENT ;
-        DIR *dirp;
-        DIR *subdir;
-        MYDIRENT *dp;
-        char rootDir [BUF_LEN];
-        char dirName [BUF_LEN];
-        Var ret, listOfDirs, listOfFiles, theline;
-        int srchlen = 0;
-        int result;
-        result = build_dir_name(arglist.v.list[1].v.str,
-                            rootDir,
-                            'd');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-        if (!(dirp = opendir (rootDir))) {
-           free_var(arglist);
-           return make_error_pack(E_INVARG);
-        }
-
-       if (arglist.v.list[0].v.num > 1) {
-           srchlen = strlen(arglist.v.list[2].v.str);
-        }
-        ret.type = TYPE_LIST;
-        ret = new_list(0);
-        listOfDirs.type = TYPE_LIST;
-        listOfDirs = new_list(0);
-        listOfFiles.type = TYPE_LIST;
-        listOfFiles = new_list(0);
-        theline.type = TYPE_STR;
-
-        while ((dp = readdir (dirp)) != 0) {
-           if (strncmp(dp->d_name,".",1)) {
-               sprintf(dirName,"%s/%s", rootDir,dp->d_name);
-               if ((subdir = opendir(dirName))) {
-                    closedir(subdir);
-                    theline.v.str = str_dup(dp->d_name);
-                    listOfDirs = listappend(listOfDirs, theline);
-                }
-                else {
-                  if ((srchlen == 0) || 
-                      (matches(dp->d_name,arglist.v.list[2].v.str))) {
-                      theline.v.str = str_dup(dp->d_name);
-                      listOfFiles = listappend(listOfFiles, theline);
-                  } 
-                }
-            }
-        }
-        closedir (dirp);
-        ret = listappend(ret, listOfFiles);
-        ret = listappend(ret, listOfDirs);
-        free_var(arglist);
-        return make_var_pack(ret);
+{				/* (directory) */
+
+    typedef struct dirent MYDIRENT;
+    DIR *dirp;
+    DIR *subdir;
+    MYDIRENT *dp;
+    char rootDir[BUF_LEN];
+    char dirName[BUF_LEN];
+    Var ret, listOfDirs, listOfFiles, theline;
+    int srchlen = 0;
+    int result;
+    result = build_dir_name(arglist.v.list[1].v.str, rootDir, 'd');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    if (!(dirp = opendir(rootDir))) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    if (arglist.v.list[0].v.num > 1) {
+	srchlen = strlen(arglist.v.list[2].v.str);
+    }
+    ret.type = TYPE_LIST;
+    ret = new_list(0);
+    listOfDirs.type = TYPE_LIST;
+    listOfDirs = new_list(0);
+    listOfFiles.type = TYPE_LIST;
+    listOfFiles = new_list(0);
+    theline.type = TYPE_STR;
+
+    while ((dp = readdir(dirp)) != 0) {
+	if (strncmp(dp->d_name, ".", 1)) {
+	    sprintf(dirName, "%s/%s", rootDir, dp->d_name);
+	    if ((subdir = opendir(dirName))) {
+		closedir(subdir);
+		theline.v.str = str_dup(dp->d_name);
+		listOfDirs = listappend(listOfDirs, theline);
+	    } else {
+		if ((srchlen == 0) ||
+		    (matches(dp->d_name, arglist.v.list[2].v.str))) {
+		    theline.v.str = str_dup(dp->d_name);
+		    listOfFiles = listappend(listOfFiles, theline);
+		}
+	    }
+	}
+    }
+    closedir(dirp);
+    ret = listappend(ret, listOfFiles);
+    ret = listappend(ret, listOfDirs);
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 static package
 bf_filegrep(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename, pattern, [option]) */
-
-        FILE *f;
-        char infileName[BUF_LEN];
-        char buffer[BUF_LEN];
-        int line_num = 0;
-        Var ret, theline, anum, slist, nlist;
-        int strings = TRUE;
-        int numbers = FALSE;
-        int showfound = TRUE;
-        int result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,
-                            'r');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-        
-        if(arglist.v.list[0].v.num == 4) {
-          if(strstr(arglist.v.list[4].v.str,"n")) {
-             numbers = TRUE;
-             if(!(strstr(arglist.v.list[4].v.str,"s"))) {strings = FALSE;}
-          }
-          if(strstr(arglist.v.list[4].v.str,"v")) {showfound = FALSE;}
-        }
-
-        if ((f = fopen(infileName, "r")) == 0) {
-           free_var(arglist);
-           return make_error_pack(E_INVARG);
-        }
-
-        slist.type = TYPE_LIST;
-        slist = new_list(0);
-        nlist.type = TYPE_LIST;
-        nlist = new_list(0);
-        ret.type = TYPE_LIST;
-        ret = new_list(0);
-
-        theline.type = TYPE_STR;
-        anum.type = TYPE_INT;
-        while (!feof(f)) {
-            fgets(buffer, BUF_LEN, f);
-            line_num++;
-            
-            if (matches(buffer,arglist.v.list[3].v.str) == showfound) {
-                    if ((strings == TRUE) && (!feof(f))) {
-                      buffer[strlen(buffer)-1] = '\0';
-                      theline.v.str = str_dup(buffer);
-                      slist = listappend(slist, theline);
-                    }
-                    if ((numbers == TRUE) && (!feof(f))) {
-                      anum.v.num = line_num;
-                      nlist = listappend(nlist, anum);
-                    }
-                 }
-              }
-
-        fclose(f);
-        free_var(arglist);
-        ret = listappend(ret, slist);
-        ret = listappend(ret, nlist);
-        return make_var_pack(ret);
+{				/* (directory, filename, pattern, [option]) */
+
+    FILE *f;
+    char infileName[BUF_LEN];
+    char buffer[BUF_LEN];
+    int line_num = 0;
+    Var ret, theline, anum, slist, nlist;
+    int strings = TRUE;
+    int numbers = FALSE;
+    int showfound = TRUE;
+    int result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, infileName, 'r');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    if (arglist.v.list[0].v.num == 4) {
+	if (strstr(arglist.v.list[4].v.str, "n")) {
+	    numbers = TRUE;
+	    if (!(strstr(arglist.v.list[4].v.str, "s"))) {
+		strings = FALSE;
+	    }
+	}
+	if (strstr(arglist.v.list[4].v.str, "v")) {
+	    showfound = FALSE;
+	}
+    }
+
+    if ((f = fopen(infileName, "r")) == 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    slist.type = TYPE_LIST;
+    slist = new_list(0);
+    nlist.type = TYPE_LIST;
+    nlist = new_list(0);
+    ret.type = TYPE_LIST;
+    ret = new_list(0);
+
+    theline.type = TYPE_STR;
+    anum.type = TYPE_INT;
+    while (!feof(f)) {
+	fgets(buffer, BUF_LEN, f);
+	line_num++;
+
+	if (matches(buffer, arglist.v.list[3].v.str) == showfound) {
+	    if ((strings == TRUE) && (!feof(f))) {
+		buffer[strlen(buffer) - 1] = '\0';
+		theline.v.str = str_dup(buffer);
+		slist = listappend(slist, theline);
+	    }
+	    if ((numbers == TRUE) && (!feof(f))) {
+		anum.v.num = line_num;
+		nlist = listappend(nlist, anum);
+	    }
+	}
+    }
+
+    fclose(f);
+    free_var(arglist);
+    ret = listappend(ret, slist);
+    ret = listappend(ret, nlist);
+    return make_var_pack(ret);
 }
 
 static package
 bf_fileextract(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename, start_pattern, end_pattern [,extra_pattern]) */
-
-        FILE *f;
-        char infileName[BUF_LEN];
-        char buffer[BUF_LEN];
-        Var ret, theline;
-        Var startList, endList;
-        Var startLine, endLine;
-        int numOfLine = 0;
-        int status = 1;
-        int requiredPattern = (arglist.v.list[0].v.num > 4);
-        int result;
-        
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,
-                            'r');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-        if ((strlen(arglist.v.list[2].v.str) == 0) ||
-            (strlen(arglist.v.list[3].v.str) == 0) ||
-            (strlen(arglist.v.list[4].v.str) == 0) ||
-            (strlen(arglist.v.list[arglist.v.list[0].v.num].v.str) == 0)) {
-          free_var(arglist);
-          return make_error_pack(E_INVARG); 
-        }
-
-         if ((f = fopen(infileName, "r")) == 0) {
-           free_var(arglist);
-           return make_error_pack(E_INVARG);
-        }
-
-       ret.type = TYPE_LIST;
-        ret = new_list(0);
-        theline.type = TYPE_STR;
-
-        startList = new_list(0);
-        startList.type = TYPE_LIST;
-
-        endList = new_list(0);
-        endList.type = TYPE_LIST;
-        
-        startLine.type = TYPE_INT;
-        endLine.type = TYPE_INT;
- 
-        while (!feof(f)) {
-            fgets(buffer, BUF_LEN, f);
-            numOfLine++;
-            
-            if (status == 1) {
-               if (matches(buffer,arglist.v.list[3].v.str)) {
-	                startLine.v.num = numOfLine;
-                        if (requiredPattern == TRUE) {
-	            	    status = 2;}
-                        else {
-                            status = 3;}
-	            }
-            }
-            
-            if (status == 2) {
-               if (matches(buffer,arglist.v.list[arglist.v.list[0].v.num].v.str)) {
-	            	status = 3;
-	            }
-            }
-            
-            if ((status == 2) || (status == 3)) {
-              if (matches(buffer,arglist.v.list[4].v.str)) {
-                        if (status == 3) {
-                          startList = listappend(startList, startLine);
-                          endLine.v.num = numOfLine;
-                          endList = listappend(endList, endLine);
-                        }
-                        status = 1;
-                     }
-            }
-        }
-
-        ret = listappend(ret,startList);
-        ret = listappend(ret,endList);        
-        fclose(f);
-        free_var(arglist);
-        return make_var_pack(ret);
+{				/* (directory, filename, start_pattern, end_pattern [,extra_pattern]) */
+
+    FILE *f;
+    char infileName[BUF_LEN];
+    char buffer[BUF_LEN];
+    Var ret, theline;
+    Var startList, endList;
+    Var startLine, endLine;
+    int numOfLine = 0;
+    int status = 1;
+    int requiredPattern = (arglist.v.list[0].v.num > 4);
+    int result;
+
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, infileName, 'r');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    if ((strlen(arglist.v.list[2].v.str) == 0) ||
+	(strlen(arglist.v.list[3].v.str) == 0) ||
+	(strlen(arglist.v.list[4].v.str) == 0) ||
+	(strlen(arglist.v.list[arglist.v.list[0].v.num].v.str) == 0)) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    if ((f = fopen(infileName, "r")) == 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    ret.type = TYPE_LIST;
+    ret = new_list(0);
+    theline.type = TYPE_STR;
+
+    startList = new_list(0);
+    startList.type = TYPE_LIST;
+
+    endList = new_list(0);
+    endList.type = TYPE_LIST;
+
+    startLine.type = TYPE_INT;
+    endLine.type = TYPE_INT;
+
+    while (!feof(f)) {
+	fgets(buffer, BUF_LEN, f);
+	numOfLine++;
+
+	if (status == 1) {
+	    if (matches(buffer, arglist.v.list[3].v.str)) {
+		startLine.v.num = numOfLine;
+		if (requiredPattern == TRUE) {
+		    status = 2;
+		} else {
+		    status = 3;
+		}
+	    }
+	}
+
+	if (status == 2) {
+	    if (matches
+		(buffer, arglist.v.list[arglist.v.list[0].v.num].v.str)) {
+		status = 3;
+	    }
+	}
+
+	if ((status == 2) || (status == 3)) {
+	    if (matches(buffer, arglist.v.list[4].v.str)) {
+		if (status == 3) {
+		    startList = listappend(startList, startLine);
+		    endLine.v.num = numOfLine;
+		    endList = listappend(endList, endLine);
+		}
+		status = 1;
+	    }
+	}
+    }
+
+    ret = listappend(ret, startList);
+    ret = listappend(ret, endList);
+    fclose(f);
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 static package
@@ -768,317 +777,311 @@ bf_fileversion(Var arglist, Byte next, void *vdata, Objid progr)
 
 static package
 bf_filerename(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, oldFilename, newFilename) */
-        char oldFilename[BUF_LEN];
-        char newFilename[BUF_LEN];
-        Var ret;
-        int result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            oldFilename,
-                            'w');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[3].v.str,
-                            newFilename,
-                            'w');
-        if ((result != E_NONE) && (result != E_INVARG)){
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-    if ((rename(oldFilename,newFilename)) != 0) {
-        return make_error_pack(E_INVARG);
-        }
-        ret.type = TYPE_INT;
-        ret.v.num = 1;
-        free_var(arglist);
-        return make_var_pack(ret);
+{				/* (directory, oldFilename, newFilename) */
+    char oldFilename[BUF_LEN];
+    char newFilename[BUF_LEN];
+    Var ret;
+    int result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, oldFilename, 'w');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[3].v.str, newFilename, 'w');
+    if ((result != E_NONE) && (result != E_INVARG)) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    if ((rename(oldFilename, newFilename)) != 0) {
+	return make_error_pack(E_INVARG);
+    }
+    ret.type = TYPE_INT;
+    ret.v.num = 1;
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 #ifdef INCLUDE_FILECHMOD
 
 static package
 bf_filechmod(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename, filemode) */
-        char theRequestedAction[BUF_LEN];
-        char filename[BUF_LEN];
-        char external_files  [BUF_LEN];
-        Var ret;
-        struct stat st;
-        mode_t  mode;
-        char filemode[BUF_LEN];
-        int r1, r2; 
-        int result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            filename,
-                            'w');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-        remove_special_characters(arglist.v.list[3].v.str);
-        if (strlen(arglist.v.list[3].v.str) == 0) {
-                   free_var(arglist);
-                   return make_error_pack(E_INVARG); }
-
-        strcpy(external_files,EXTERN_FILES_DIR);
-        sprintf(theRequestedAction,"chmod %s %s%s/%s\n",
-                                   arglist.v.list[3].v.str,
-                                   external_files,
-                                   arglist.v.list[1].v.str,
-                                   arglist.v.list[2].v.str);
+{				/* (directory, filename, filemode) */
+    char theRequestedAction[BUF_LEN];
+    char filename[BUF_LEN];
+    char external_files[BUF_LEN];
+    Var ret;
+    struct stat st;
+    mode_t mode;
+    char filemode[BUF_LEN];
+    int r1, r2;
+    int result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, filename, 'w');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    remove_special_characters(arglist.v.list[3].v.str);
+    if (strlen(arglist.v.list[3].v.str) == 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    strcpy(external_files, EXTERN_FILES_DIR);
+    sprintf(theRequestedAction, "chmod %s %s%s/%s\n",
+	    arglist.v.list[3].v.str,
+	    external_files,
+	    arglist.v.list[1].v.str, arglist.v.list[2].v.str);
 
     if ((system(theRequestedAction)) == 0) {
-          return make_error_pack(E_INVARG);
-        }
-
-	stat(filename, &st);
-        ret.type = TYPE_STR;
-        mode = st.st_mode;
-        if (S_ISREG(st.st_mode))  mode = st.st_mode - 32768;
-        if (S_ISDIR(st.st_mode))  mode = st.st_mode - 16384;
-        if (S_ISCHR(st.st_mode))  mode = st.st_mode -  8192;
-        if (S_ISBLK(st.st_mode))  mode = st.st_mode - 24576;
-        if (S_ISSOCK(st.st_mode)) mode = st.st_mode - 49152;
-        if (mode != st.st_mode) {
-           r1 = mode / 8;
-           r1 = r1 - ((r1 / 8) * 8);
-           r2 = mode - ((mode/8) * 8);
-           sprintf(filemode,"%ld%d%d",(long)mode/64,r1,r2);
-           ret.v.str = str_dup(filemode);
-           }
-        else ret.v.str = str_dup("????");
-        free_var(arglist);
-        return make_var_pack(ret);
+	return make_error_pack(E_INVARG);
+    }
+
+    stat(filename, &st);
+    ret.type = TYPE_STR;
+    mode = st.st_mode;
+    if (S_ISREG(st.st_mode))
+	mode = st.st_mode - 32768;
+    if (S_ISDIR(st.st_mode))
+	mode = st.st_mode - 16384;
+    if (S_ISCHR(st.st_mode))
+	mode = st.st_mode - 8192;
+    if (S_ISBLK(st.st_mode))
+	mode = st.st_mode - 24576;
+    if (S_ISSOCK(st.st_mode))
+	mode = st.st_mode - 49152;
+    if (mode != st.st_mode) {
+	r1 = mode / 8;
+	r1 = r1 - ((r1 / 8) * 8);
+	r2 = mode - ((mode / 8) * 8);
+	sprintf(filemode, "%ld%d%d", (long) mode / 64, r1, r2);
+	ret.v.str = str_dup(filemode);
+    } else
+	ret.v.str = str_dup("????");
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 #endif
 
 static package
 bf_fileinfo(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename) */
-        char filename[BUF_LEN];
-        Var ret, atime, mtime, ctime, fsize, ftype, fmode, fuid, fgid;
-        struct stat st;
-        struct passwd *pw;
-        struct group *grp;
-        mode_t  mode;
-        int r0, r1, r2; 
-        char filemode[BUF_LEN];
-        int result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            filename,
-                            'r');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-        if (stat(filename, &st) != 0) {
-           free_var(arglist);
-           return make_error_pack(E_INVARG);
-        }
-
-        fsize.type = TYPE_INT;
-        fsize.v.num = (long)st.st_size;
-
-        ftype.type = TYPE_STR;
-        ftype.v.str = str_dup("???");
-        mode = st.st_mode;
-        if (S_ISREG(st.st_mode)) {
-           ftype.v.str = str_dup("reg");
-           mode = st.st_mode - 32768;
-           }
-        if (S_ISDIR(st.st_mode)) {
-           ftype.v.str = str_dup("dir");
-           mode = st.st_mode - 16384;
-           }
-
-        if (S_ISFIFO(st.st_mode)) { oklog("FIFO %ld\n",(long)st.st_mode);
-           }
-
-        if (S_ISCHR(st.st_mode)) {
-           ftype.v.str = str_dup("chr");
-           mode = st.st_mode - 8192;
-           }
-
-        if (S_ISBLK(st.st_mode)) {
-           ftype.v.str = str_dup("blk");
-           mode = st.st_mode - 24576;
-           }
-
-        if (S_ISLNK(st.st_mode)) { oklog("LNK  %ld\n",(long)st.st_mode);
-           }
-
-        if (S_ISSOCK(st.st_mode)) {
-           ftype.v.str = str_dup("sck");
-           mode = st.st_mode - 49152;
-           }
-
-        fmode.type = TYPE_STR;
-        fmode.v.str = str_dup("????");
-        if (mode != st.st_mode) {
-           r0 = mode / 512;
-           r1 = mode / 8;
-           r1 = r1 - ((r1 / 8) * 8);
-           r2 = mode - ((mode/8) * 8);
-           sprintf(filemode,"%ld%d%d",(long)mode/64,r1,r2);
-           fmode.v.str = str_dup(filemode);
-           }
-
-        pw = getpwuid((short)st.st_uid);
-        fuid.type = TYPE_STR;
-        fuid.v.str = str_dup(pw->pw_name);
-
-        grp = getgrgid((short)st.st_gid);
-        fgid.type = TYPE_STR;
-        fgid.v.str = str_dup(grp->gr_name);
-
-        atime.type = TYPE_INT;
-        atime.v.num = st.st_atime;
-
-        mtime.type = TYPE_INT;
-        mtime.v.num = st.st_mtime;
-
-        ctime.type = TYPE_INT;
-        ctime.v.num = st.st_ctime;
-        
-        ret.type = TYPE_LIST;
-        ret = new_list(0);
-        ret = listappend(ret, fsize); /* total size of file, bytes */
-        ret = listappend(ret, ftype); /* file type */
-        ret = listappend(ret, fmode); /* file mode */
-        ret = listappend(ret, fuid);  /* user ID of owner */
-        ret = listappend(ret, fgid);  /* group ID of owner */
-        ret = listappend(ret, atime); /* file last access time */
-        ret = listappend(ret, mtime); /* file last modify time */
-        ret = listappend(ret, ctime); /* file last change time */
-
-        free_var(arglist);
-        return make_var_pack(ret);
+{				/* (directory, filename) */
+    char filename[BUF_LEN];
+    Var ret, atime, mtime, ctime, fsize, ftype, fmode, fuid, fgid;
+    struct stat st;
+    struct passwd *pw;
+    struct group *grp;
+    mode_t mode;
+    int r0, r1, r2;
+    char filemode[BUF_LEN];
+    int result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, filename, 'r');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    if (stat(filename, &st) != 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    fsize.type = TYPE_INT;
+    fsize.v.num = (long) st.st_size;
+
+    ftype.type = TYPE_STR;
+    ftype.v.str = str_dup("???");
+    mode = st.st_mode;
+    if (S_ISREG(st.st_mode)) {
+	ftype.v.str = str_dup("reg");
+	mode = st.st_mode - 32768;
+    }
+    if (S_ISDIR(st.st_mode)) {
+	ftype.v.str = str_dup("dir");
+	mode = st.st_mode - 16384;
+    }
+
+    if (S_ISFIFO(st.st_mode)) {
+	oklog("FIFO %ld\n", (long) st.st_mode);
+    }
+
+    if (S_ISCHR(st.st_mode)) {
+	ftype.v.str = str_dup("chr");
+	mode = st.st_mode - 8192;
+    }
+
+    if (S_ISBLK(st.st_mode)) {
+	ftype.v.str = str_dup("blk");
+	mode = st.st_mode - 24576;
+    }
+
+    if (S_ISLNK(st.st_mode)) {
+	oklog("LNK  %ld\n", (long) st.st_mode);
+    }
+
+    if (S_ISSOCK(st.st_mode)) {
+	ftype.v.str = str_dup("sck");
+	mode = st.st_mode - 49152;
+    }
+
+    fmode.type = TYPE_STR;
+    fmode.v.str = str_dup("????");
+    if (mode != st.st_mode) {
+	r0 = mode / 512;
+	r1 = mode / 8;
+	r1 = r1 - ((r1 / 8) * 8);
+	r2 = mode - ((mode / 8) * 8);
+	sprintf(filemode, "%ld%d%d", (long) mode / 64, r1, r2);
+	fmode.v.str = str_dup(filemode);
+    }
+
+    pw = getpwuid((short) st.st_uid);
+    fuid.type = TYPE_STR;
+    fuid.v.str = str_dup(pw->pw_name);
+
+    grp = getgrgid((short) st.st_gid);
+    fgid.type = TYPE_STR;
+    fgid.v.str = str_dup(grp->gr_name);
+
+    atime.type = TYPE_INT;
+    atime.v.num = st.st_atime;
+
+    mtime.type = TYPE_INT;
+    mtime.v.num = st.st_mtime;
+
+    ctime.type = TYPE_INT;
+    ctime.v.num = st.st_ctime;
+
+    ret.type = TYPE_LIST;
+    ret = new_list(0);
+    ret = listappend(ret, fsize);	/* total size of file, bytes */
+    ret = listappend(ret, ftype);	/* file type */
+    ret = listappend(ret, fmode);	/* file mode */
+    ret = listappend(ret, fuid);	/* user ID of owner */
+    ret = listappend(ret, fgid);	/* group ID of owner */
+    ret = listappend(ret, atime);	/* file last access time */
+    ret = listappend(ret, mtime);	/* file last modify time */
+    ret = listappend(ret, ctime);	/* file last change time */
+
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 #ifdef INCLUDE_FILERUN
 
 static package
 bf_filerun(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (filename, arguments) */
-        char theRequestedAction[BUF_LEN];
-        Var ret, theArgs, theline;
-        int i, numOfArgs, result;
-        char fileName[BUF_LEN];
-        char external_bin [BUF_LEN];
-
-        theline.type = TYPE_STR;
-        theArgs.type = TYPE_LIST;
-        theArgs = new_list(0);
-        numOfArgs = arglist.v.list[0].v.num;
-        for (i = 1; i <= numOfArgs; i++) {
-	        switch (arglist.v.list[i].type) {
-	          case TYPE_STR:
-                theline.v.str = str_dup(arglist.v.list[i].v.str);
-                remove_special_characters( theline.v.str); 
-
-                if (( strstr(theline.v.str,"/.")) ||
-                   (!strncmp(theline.v.str,".",1)) ||
-                   (!strncmp(theline.v.str,"/",1))) {
-                    free_var(arglist);
-                    free_var(theline);
-                    return make_error_pack(E_PERM);
-                    }
-
-                theArgs = listappend(theArgs,theline);
-	        break;
-	          case TYPE_LIST:
-                    if (arglist.v.list[i].v.list[0].v.num < 2) {
-                        theline.v.str = str_dup("");
-                        theArgs = listappend(theArgs,theline);
-                    } else {
-                    if ((arglist.v.list[i].v.list[1].type != TYPE_STR) ||
-                       (arglist.v.list[i].v.list[2].type != TYPE_STR)) {
-			            free_var(arglist);
-                                    free_var(theline);
-			            return make_error_pack(E_TYPE); 
-                       }
-                    result = build_file_name(arglist.v.list[i].v.list[1].v.str,
-                                             arglist.v.list[i].v.list[2].v.str,
-                                             fileName,
-                                             'r');
-                        theline.v.str = str_dup(fileName);
-                        theArgs = listappend(theArgs,theline);
-					}
-	            break;
-	          default:
-                free_var(arglist);
-                free_var(theline);
-                return make_error_pack(E_INVARG);
-	        }        
-        }
-       
-       numOfArgs = theArgs.v.list[0].v.num;
-       strcpy(external_bin,EXTERN_BIN_DIR);
-       sprintf(theRequestedAction,"%s%s ",external_bin,theArgs.v.list[1].v.str);
-
-        if ((numOfArgs > 1) && (strlen(theArgs.v.list[2].v.str)!=0)) {
-                 sprintf(theRequestedAction,"cat %s | %s%s",
-                                   theArgs.v.list[2].v.str,
-                                   external_bin,
-                                   theArgs.v.list[1].v.str);
-        } else {
-                 sprintf(theRequestedAction,"%s%s ",
-                                   external_bin,
-                                   theArgs.v.list[1].v.str);
-        }
-
-        for (i = 4; i <= numOfArgs; i++) {
-        sprintf(theRequestedAction,"%s %s",
-                                   theRequestedAction,
-                                   theArgs.v.list[i].v.str);
-        }
-
-        if ((numOfArgs > 2) && (strlen(theArgs.v.list[3].v.str))){
-            sprintf(theRequestedAction,"%s > %s",
-                                   theRequestedAction,
-                                   theArgs.v.list[3].v.str);
-        }
-
-        sprintf(theRequestedAction,"%s 2>&1", theRequestedAction);
-        system(theRequestedAction);
-
-        ret.type = TYPE_INT;
-        ret.v.num = 1; /* always !! */
-        free_var(arglist);
-        free_var(theline);
-        return make_var_pack(ret);
+{				/* (filename, arguments) */
+    char theRequestedAction[BUF_LEN];
+    Var ret, theArgs, theline;
+    int i, numOfArgs, result;
+    char fileName[BUF_LEN];
+    char external_bin[BUF_LEN];
+
+    theline.type = TYPE_STR;
+    theArgs.type = TYPE_LIST;
+    theArgs = new_list(0);
+    numOfArgs = arglist.v.list[0].v.num;
+    for (i = 1; i <= numOfArgs; i++) {
+	switch (arglist.v.list[i].type) {
+	case TYPE_STR:
+	    theline.v.str = str_dup(arglist.v.list[i].v.str);
+	    remove_special_characters(theline.v.str);
+
+	    if ((strstr(theline.v.str, "/.")) ||
+		(!strncmp(theline.v.str, ".", 1)) ||
+		(!strncmp(theline.v.str, "/", 1))) {
+		free_var(arglist);
+		free_var(theline);
+		return make_error_pack(E_PERM);
+	    }
+
+	    theArgs = listappend(theArgs, theline);
+	    break;
+	case TYPE_LIST:
+	    if (arglist.v.list[i].v.list[0].v.num < 2) {
+		theline.v.str = str_dup("");
+		theArgs = listappend(theArgs, theline);
+	    } else {
+		if ((arglist.v.list[i].v.list[1].type != TYPE_STR) ||
+		    (arglist.v.list[i].v.list[2].type != TYPE_STR)) {
+		    free_var(arglist);
+		    free_var(theline);
+		    return make_error_pack(E_TYPE);
+		}
+		result = build_file_name(arglist.v.list[i].v.list[1].v.str,
+					 arglist.v.list[i].v.list[2].v.str,
+					 fileName, 'r');
+		theline.v.str = str_dup(fileName);
+		theArgs = listappend(theArgs, theline);
+	    }
+	    break;
+	default:
+	    free_var(arglist);
+	    free_var(theline);
+	    return make_error_pack(E_INVARG);
+	}
+    }
+
+    numOfArgs = theArgs.v.list[0].v.num;
+    strcpy(external_bin, EXTERN_BIN_DIR);
+    sprintf(theRequestedAction, "%s%s ", external_bin,
+	    theArgs.v.list[1].v.str);
+
+    if ((numOfArgs > 1) && (strlen(theArgs.v.list[2].v.str) != 0)) {
+	sprintf(theRequestedAction, "cat %s | %s%s",
+		theArgs.v.list[2].v.str,
+		external_bin, theArgs.v.list[1].v.str);
+    } else {
+	sprintf(theRequestedAction, "%s%s ",
+		external_bin, theArgs.v.list[1].v.str);
+    }
+
+    for (i = 4; i <= numOfArgs; i++) {
+	sprintf(theRequestedAction, "%s %s",
+		theRequestedAction, theArgs.v.list[i].v.str);
+    }
+
+    if ((numOfArgs > 2) && (strlen(theArgs.v.list[3].v.str))) {
+	sprintf(theRequestedAction, "%s > %s",
+		theRequestedAction, theArgs.v.list[3].v.str);
+    }
+
+    sprintf(theRequestedAction, "%s 2>&1", theRequestedAction);
+    system(theRequestedAction);
+
+    ret.type = TYPE_INT;
+    ret.v.num = 1;		/* always !! */
+    free_var(arglist);
+    free_var(theline);
+    return make_var_pack(ret);
 }
 #endif
 
 static package
 bf_filemkdir(Var arglist, Byte next, void *vdata, Objid progr)
-{  /* filemkdir(base-directory-name, new-directory-name) */
-      char newdirName[BUF_LEN];
-      mode_t create_mode = CREATE_NEW_DIR_MODE;
-      Var ret;
-        int result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            newdirName,
-                            'd');
-        if ((result != E_NONE) && (result != E_INVARG)){
-                free_var(arglist);
-                return make_error_pack(result);
-        }
+{				/* filemkdir(base-directory-name, new-directory-name) */
+    char newdirName[BUF_LEN];
+    mode_t create_mode = CREATE_NEW_DIR_MODE;
+    Var ret;
+    int result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, newdirName, 'd');
+    if ((result != E_NONE) && (result != E_INVARG)) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
 
     if ((mkdir(newdirName, create_mode)) != 0) {
-            free_var(arglist);
-            return make_error_pack(E_PERM); }
+	free_var(arglist);
+	return make_error_pack(E_PERM);
+    }
 
     ret.type = TYPE_INT;
     ret.v.num = 1;
@@ -1088,22 +1091,20 @@ bf_filemkdir(Var arglist, Byte next, void *vdata, Objid progr)
 
 static package
 bf_filermdir(Var arglist, Byte next, void *vdata, Objid prog)
-{  /* filermdir(base-directory-name, directory-name) */
-        char rmDirName[BUF_LEN];
-        Var  ret;
-        int result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            rmDirName,
-                            'd');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
+{				/* filermdir(base-directory-name, directory-name) */
+    char rmDirName[BUF_LEN];
+    Var ret;
+    int result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, rmDirName, 'd');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
 
     if ((rmdir(rmDirName)) != 0) {
-        free_var(arglist);
-        return make_error_pack(E_PERM); 
+	free_var(arglist);
+	return make_error_pack(E_PERM);
     }
     free_var(arglist);
     ret.type = TYPE_INT;
@@ -1123,34 +1124,51 @@ bf_fileerror(Var arglist, Byte next, void *vdata, Objid progr)
 
 void
 register_files(void)
-{ 
-    oklog("          (Using File Utilities Package version %s)\n", FUP_version);
+{
+    oklog("          (Using File Utilities Package version %s)\n",
+	  FUP_version);
 
-    (void) register_function("fileappend",  3,  3, bf_fileappend,  TYPE_STR, TYPE_STR, TYPE_LIST);
+    (void) register_function("fileappend", 3, 3, bf_fileappend, TYPE_STR,
+			     TYPE_STR, TYPE_LIST);
 
 #ifdef INCLUDE_FILECHMOD
-    (void) register_function("filechmod",   3,  3, bf_filechmod,   TYPE_STR, TYPE_STR, TYPE_STR);
+    (void) register_function("filechmod", 3, 3, bf_filechmod, TYPE_STR,
+			     TYPE_STR, TYPE_STR);
 #endif
 
-    (void) register_function("filedelete",  2,  2, bf_filedelete,  TYPE_STR, TYPE_STR);
-    (void) register_function("fileerror",   0,  0, bf_fileerror);
-    (void) register_function("fileexists",  2,  2, bf_fileexists,  TYPE_STR, TYPE_STR);
-    (void) register_function("fileextract", 4,  5, bf_fileextract, TYPE_STR, TYPE_STR, TYPE_STR, TYPE_STR, TYPE_STR);
-    (void) register_function("filegrep",    3,  4, bf_filegrep,    TYPE_STR, TYPE_STR, TYPE_STR, TYPE_STR);
-    (void) register_function("fileinfo",    2,  2, bf_fileinfo,    TYPE_STR, TYPE_STR);
-    (void) register_function("filelength",  2,  2, bf_filelength,  TYPE_STR, TYPE_STR);
-    (void) register_function("filelist",    1,  2, bf_filelist,    TYPE_STR, TYPE_STR);
-    (void) register_function("filemkdir",   2,  2, bf_filemkdir,   TYPE_STR, TYPE_STR);
-    (void) register_function("fileread",    2,  4, bf_fileread,    TYPE_STR, TYPE_STR, TYPE_INT, TYPE_INT);
-    (void) register_function("filerename",  3,  3, bf_filerename,  TYPE_STR, TYPE_STR, TYPE_STR);
-    (void) register_function("filermdir",   2,  2, bf_filermdir,   TYPE_STR, TYPE_STR);
+    (void) register_function("filedelete", 2, 2, bf_filedelete, TYPE_STR,
+			     TYPE_STR);
+    (void) register_function("fileerror", 0, 0, bf_fileerror);
+    (void) register_function("fileexists", 2, 2, bf_fileexists, TYPE_STR,
+			     TYPE_STR);
+    (void) register_function("fileextract", 4, 5, bf_fileextract, TYPE_STR,
+			     TYPE_STR, TYPE_STR, TYPE_STR, TYPE_STR);
+    (void) register_function("filegrep", 3, 4, bf_filegrep, TYPE_STR,
+			     TYPE_STR, TYPE_STR, TYPE_STR);
+    (void) register_function("fileinfo", 2, 2, bf_fileinfo, TYPE_STR,
+			     TYPE_STR);
+    (void) register_function("filelength", 2, 2, bf_filelength, TYPE_STR,
+			     TYPE_STR);
+    (void) register_function("filelist", 1, 2, bf_filelist, TYPE_STR,
+			     TYPE_STR);
+    (void) register_function("filemkdir", 2, 2, bf_filemkdir, TYPE_STR,
+			     TYPE_STR);
+    (void) register_function("fileread", 2, 4, bf_fileread, TYPE_STR,
+			     TYPE_STR, TYPE_INT, TYPE_INT);
+    (void) register_function("filerename", 3, 3, bf_filerename, TYPE_STR,
+			     TYPE_STR, TYPE_STR);
+    (void) register_function("filermdir", 2, 2, bf_filermdir, TYPE_STR,
+			     TYPE_STR);
 
 #ifdef INCLUDE_FILERUN
-    (void) register_function("filerun",     1, -1, bf_filerun,     TYPE_STR, TYPE_LIST, TYPE_LIST); 
+    (void) register_function("filerun", 1, -1, bf_filerun, TYPE_STR,
+			     TYPE_LIST, TYPE_LIST);
 #endif
 
-    (void) register_function("filesize",    2,  2, bf_filesize,    TYPE_STR, TYPE_STR);
-    (void) register_function("fileversion", 0,  0, bf_fileversion);
-    (void) register_function("filewrite",   3,  5, bf_filewrite,   TYPE_STR, TYPE_STR, TYPE_LIST, TYPE_INT, TYPE_INT);
+    (void) register_function("filesize", 2, 2, bf_filesize, TYPE_STR,
+			     TYPE_STR);
+    (void) register_function("fileversion", 0, 0, bf_fileversion);
+    (void) register_function("filewrite", 3, 5, bf_filewrite, TYPE_STR,
+			     TYPE_STR, TYPE_LIST, TYPE_INT, TYPE_INT);
 
 }
diff --git a/server/ext-FUP-1.8/ext-FUP_options.h b/server/ext-FUP-1.8/ext-FUP_options.h
index 0011ad8..45d390b 100644
--- a/server/ext-FUP-1.8/ext-FUP_options.h
+++ b/server/ext-FUP-1.8/ext-FUP_options.h
@@ -13,23 +13,23 @@ You can change the name of the base directory for the external file
 hierarchy, which is 'hard-coded' into the server upon compilation.
 To change it from its default ('files'), edit the line:
 */
-     #define EXTERN_FILES_DIR   "files/"
+#define EXTERN_FILES_DIR   "files/"
 
 
 /***************************************************************************
 The default name for the directory that holds the executables is defined in:
 */
-     #define EXTERN_BIN_DIR     "bin/"
+#define EXTERN_BIN_DIR     "bin/"
 
 
 /******************************************************************************
 You can also make this base directory either read-only or read-and-write.
 It is read-only by default. To make it writable from the MOO, comment the line:
 */
-     #define EXTERN_FILES_DIR_READ_ONLY
+#define EXTERN_FILES_DIR_READ_ONLY
 
 
 /**********************************************************
 The default mode for new directories can be configured too:
 */
-     #define CREATE_NEW_DIR_MODE		0755
+#define CREATE_NEW_DIR_MODE		0755
diff --git a/server/ext-FUP-1.8/extensions.c b/server/ext-FUP-1.8/extensions.c
index e6a802f..98f0847 100644
--- a/server/ext-FUP-1.8/extensions.c
+++ b/server/ext-FUP-1.8/extensions.c
@@ -61,20 +61,19 @@ stdin_enumerator(task_closure closure, void *data)
     stdin_waiter **ww;
 
     for (ww = &waiters; *ww; ww = &((*ww)->next)) {
-        stdin_waiter *w = *ww;
-        const char *status = (w->the_vm->task_id & 1
-                              ? "stdin-waiting"
-                              : "stdin-weighting");
-        task_enum_action tea = (*closure) (w->the_vm, status, data);
-
-        if (tea == TEA_KILL) {
-            *ww = w->next;
-            myfree(w, M_TASK);
-            if (!waiters)
-                network_unregister_fd(0);
-        }
-        if (tea != TEA_CONTINUE)
-            return tea;
+	stdin_waiter *w = *ww;
+	const char *status = (w->the_vm->task_id & 1
+			      ? "stdin-waiting" : "stdin-weighting");
+	task_enum_action tea = (*closure) (w->the_vm, status, data);
+
+	if (tea == TEA_KILL) {
+	    *ww = w->next;
+	    myfree(w, M_TASK);
+	    if (!waiters)
+		network_unregister_fd(0);
+	}
+	if (tea != TEA_CONTINUE)
+	    return tea;
     }
 
     return TEA_CONTINUE;
@@ -89,24 +88,24 @@ stdin_readable(int fd, void *data)
     stdin_waiter *w;
 
     if (data != &waiters)
-        panic("STDIN_READABLE: Bad data!");
+	panic("STDIN_READABLE: Bad data!");
 
     if (!waiters) {
-        errlog("STDIN_READABLE: Nobody cares!\n");
-        return;
+	errlog("STDIN_READABLE: Nobody cares!\n");
+	return;
     }
     n = read(0, buffer, sizeof(buffer));
     buffer[n] = '\0';
     while (n)
-        if (buffer[--n] == '\n')
-            buffer[n] = 'X';
+	if (buffer[--n] == '\n')
+	    buffer[n] = 'X';
 
     if (buffer[0] == 'a') {
-        v.type = TYPE_ERR;
-        v.v.err = E_NACC;
+	v.type = TYPE_ERR;
+	v.v.err = E_NACC;
     } else {
-        v.type = TYPE_STR;
-        v.v.str = str_dup(buffer);
+	v.type = TYPE_STR;
+	v.v.str = str_dup(buffer);
     }
 
     resume_task(waiters->the_vm, v);
@@ -114,7 +113,7 @@ stdin_readable(int fd, void *data)
     myfree(waiters, M_TASK);
     waiters = w;
     if (!waiters)
-        network_unregister_fd(0);
+	network_unregister_fd(0);
 }
 
 static enum error
@@ -123,7 +122,7 @@ stdin_suspender(vm the_vm, void *data)
     stdin_waiter *w = data;
 
     if (!waiters)
-        network_register_fd(0, stdin_readable, 0, &waiters);
+	network_register_fd(0, stdin_readable, 0, &waiters);
 
     w->the_vm = the_vm;
     w->next = waiters;
@@ -139,7 +138,7 @@ bf_read_stdin(Var arglist, Byte next, void *vdata, Objid progr)
 
     return make_suspend_pack(stdin_suspender, w);
 }
-#endif                          /* EXAMPLE */
+#endif				/* EXAMPLE */
 
 #define STUPID_VERB_CACHE 1
 #ifdef STUPID_VERB_CACHE
@@ -153,7 +152,7 @@ bf_verb_cache_stats(Var arglist, Byte next, void *vdata, Objid progr)
     free_var(arglist);
 
     if (!is_wizard(progr)) {
-        return make_error_pack(E_PERM);
+	return make_error_pack(E_PERM);
     }
     r = db_verb_cache_stats();
 
@@ -166,7 +165,7 @@ bf_log_cache_stats(Var arglist, Byte next, void *vdata, Objid progr)
     free_var(arglist);
 
     if (!is_wizard(progr)) {
-        return make_error_pack(E_PERM);
+	return make_error_pack(E_PERM);
     }
     db_log_cache_stats();
 
@@ -182,15 +181,16 @@ register_extensions()
     register_task_queue(stdin_enumerator);
     register_function("read_stdin", 0, 0, bf_read_stdin);
 #endif
-oklog("          LOADING: extension FUP ...\n");
-  register_files();
+    oklog("          LOADING: extension FUP ...\n");
+    register_files();
 #ifdef STUPID_VERB_CACHE
     register_function("log_cache_stats", 0, 0, bf_log_cache_stats);
     register_function("verb_cache_stats", 0, 0, bf_verb_cache_stats);
 #endif
 }
 
-char rcsid_extensions[] = "$Id: extensions.c,v 1.3 1997/07/07 03:24:54 nop Exp
+char rcsid_extensions[] =
+    "$Id: extensions.c,v 1.3 1997/07/07 03:24:54 nop Exp
 $";
 
 /* $Log: extensions.c,v $
@@ -222,4 +222,3 @@ $";
  * Revision 1.1  1995/11/30  04:26:21  pavel
  * Initial revision
  */
-
diff --git a/server/ext-FUP.c b/server/ext-FUP.c
index 180e63f..cd2879f 100644
--- a/server/ext-FUP.c
+++ b/server/ext-FUP.c
@@ -47,26 +47,26 @@
 
 extern int fputs();
 extern struct passwd *getpwuid();
-extern struct group  *getgrgid();
+extern struct group *getgrgid();
 extern int system();
 extern int access();
 extern int atoi();
 
 extern Var do_match(Var arglist, int reverse);
 
-const char     *FUP_version = "1.8";
+const char *FUP_version = "1.8";
 
 int
 matches(char *subject, const char *pattern)
 {
     Var ans, req;
-    int  result;
-    
+    int result;
+
     req = new_list(2);
     req.v.list[1].type = TYPE_STR;
     req.v.list[2].type = TYPE_STR;
-    req.v.list[1].v.str  = str_dup(subject);
-    req.v.list[2].v.str  = str_dup(pattern);
+    req.v.list[1].v.str = str_dup(subject);
+    req.v.list[2].v.str = str_dup(pattern);
     ans = do_match(req, 0);
     result = is_true(ans);
     free_var(ans);
@@ -77,7 +77,7 @@ matches(char *subject, const char *pattern)
 void
 remove_LAST_character(char *theStr)
 {
- theStr[strlen(theStr)-1] = '\0';
+    theStr[strlen(theStr) - 1] = '\0';
 }
 
 void
@@ -90,662 +90,672 @@ remove_special_characters(char *theStr)
 
     cp = theStr;
     cp2 = buf;
-    while (( *cp ) && (currlen < BUF_LEN)) {
-        switch (*cp) {
-        case '&':
-        case '|':
-        case ';':
-        case '<':
-        case '>':
-        case '(':
-        case ')':
-        case '\'':
-        case '\\':
-        case '"':
-        case '`':
-        case ':':
-        case '$':
-        case '!':
-        case ' ':
-            cp++;
-            break;
-        default: {
-            *cp2++ = *cp++;
-            currlen++;
-            }
-        }
+    while ((*cp) && (currlen < BUF_LEN)) {
+	switch (*cp) {
+	case '&':
+	case '|':
+	case ';':
+	case '<':
+	case '>':
+	case '(':
+	case ')':
+	case '\'':
+	case '\\':
+	case '"':
+	case '`':
+	case ':':
+	case '$':
+	case '!':
+	case ' ':
+	    cp++;
+	    break;
+	default:{
+		*cp2++ = *cp++;
+		currlen++;
+	    }
+	}
     }
     *cp2 = '\0';
-    strcpy( theStr, buf);
+    strcpy(theStr, buf);
 }
 
 enum error
 build_dir_name(const char *thePathStr, char *theDirName, char spec)
 {
-    char external_files  [BUF_LEN];
-    char localthePathStr [BUF_LEN];
+    char external_files[BUF_LEN];
+    char localthePathStr[BUF_LEN];
     struct stat st;
 
-    if (strlen(thePathStr) > BUF_LEN)  return E_INVARG;
+    if (strlen(thePathStr) > BUF_LEN)
+	return E_INVARG;
 
     strcpy(localthePathStr, thePathStr);
     remove_special_characters(localthePathStr);
-    if (( strstr(localthePathStr,"/.")) ||
-       (!strncmp(localthePathStr,".",1))) {
-     return E_PERM;
+    if ((strstr(localthePathStr, "/.")) ||
+	(!strncmp(localthePathStr, ".", 1))) {
+	return E_PERM;
     }
-    strcpy(external_files,EXTERN_FILES_DIR);
-    sprintf(theDirName,"%s%s", external_files, localthePathStr);
-    
-    if (stat(theDirName, &st) != 0) return E_INVARG;
+    strcpy(external_files, EXTERN_FILES_DIR);
+    sprintf(theDirName, "%s%s", external_files, localthePathStr);
+
+    if (stat(theDirName, &st) != 0)
+	return E_INVARG;
 
     errno = 0;
-    switch (spec)
-	    {
-	    case 'd':
-	      if (!(st.st_mode & S_IFDIR)) return E_INVIND; 	      
-	      break;
-	    case 'r':
-	      if ((access (theDirName, R_OK)) !=0) return E_PERM;
-	      break;
-	    case 'w':
-	      if ((access (theDirName, W_OK)) !=0) return E_PERM;
-	      break;
-	    case 'x':
-	      if ((access (theDirName, X_OK)) !=0) return E_PERM;
-	      break;
-	    default:
-	        return E_ARGS;
-	    }
-     return E_NONE;
+    switch (spec) {
+    case 'd':
+	if (!(st.st_mode & S_IFDIR))
+	    return E_INVIND;
+	break;
+    case 'r':
+	if ((access(theDirName, R_OK)) != 0)
+	    return E_PERM;
+	break;
+    case 'w':
+	if ((access(theDirName, W_OK)) != 0)
+	    return E_PERM;
+	break;
+    case 'x':
+	if ((access(theDirName, X_OK)) != 0)
+	    return E_PERM;
+	break;
+    default:
+	return E_ARGS;
+    }
+    return E_NONE;
 }
 
 enum error
-build_file_name(const char *thePathStr, const char *theNameStr, char *theFileName, char spec)
+build_file_name(const char *thePathStr, const char *theNameStr,
+		char *theFileName, char spec)
 {
-    char external_files  [BUF_LEN];
-    char localthePathStr [BUF_LEN];
-    char localtheNameStr [BUF_LEN];
+    char external_files[BUF_LEN];
+    char localthePathStr[BUF_LEN];
+    char localtheNameStr[BUF_LEN];
     struct stat st;
 
 #ifdef EXTERN_FILES_DIR_READ_ONLY
     if (strlen(thePathStr) == 0) {
-       switch (spec)
-       {
-        case 'w':
-        case 'd':
-           return E_PERM;
-           break;
-       }
+	switch (spec) {
+	case 'w':
+	case 'd':
+	    return E_PERM;
+	    break;
+	}
     }
 #endif
 
-    if ((strlen(thePathStr) > BUF_LEN) || 
-        (strlen(theNameStr) > BUF_LEN))  return E_INVARG;
+    if ((strlen(thePathStr) > BUF_LEN) || (strlen(theNameStr) > BUF_LEN))
+	return E_INVARG;
 
     strcpy(localthePathStr, thePathStr);
     strcpy(localtheNameStr, theNameStr);
     remove_special_characters(localthePathStr);
     remove_special_characters(localtheNameStr);
-    
-    if (( strstr(localthePathStr,"/.")) ||
-       (!strncmp(localthePathStr,".",1)) ||
-       (strstr(localtheNameStr,"/"))) {
-     return E_PERM;
-    }
-    strcpy(external_files,EXTERN_FILES_DIR);
-    sprintf(theFileName,"%s%s/%s", external_files, localthePathStr, 
-                                   localtheNameStr);
-    
-    if (stat(theFileName, &st) != 0) return E_INVARG;
+
+    if ((strstr(localthePathStr, "/.")) ||
+	(!strncmp(localthePathStr, ".", 1)) ||
+	(strstr(localtheNameStr, "/"))) {
+	return E_PERM;
+    }
+    strcpy(external_files, EXTERN_FILES_DIR);
+    sprintf(theFileName, "%s%s/%s", external_files, localthePathStr,
+	    localtheNameStr);
+
+    if (stat(theFileName, &st) != 0)
+	return E_INVARG;
 
     errno = 0;
-    switch (spec)
-	    {
-	    case 'd':
-	      if (!(st.st_mode & S_IFDIR)) return E_INVIND; 	      
-	      break;
-	    case 'r':
-	      if ((access (theFileName, R_OK)) !=0) return E_PERM;
-	      break;
-	    case 'w':
-	      if ((access (theFileName, W_OK)) !=0) return E_PERM;
-	      break;
-	    case 'x':
-	      if ((access (theFileName, X_OK)) !=0) return E_PERM;
-	      break;
-	    default:
-	        return E_ARGS;
-	    }
-     return E_NONE;
+    switch (spec) {
+    case 'd':
+	if (!(st.st_mode & S_IFDIR))
+	    return E_INVIND;
+	break;
+    case 'r':
+	if ((access(theFileName, R_OK)) != 0)
+	    return E_PERM;
+	break;
+    case 'w':
+	if ((access(theFileName, W_OK)) != 0)
+	    return E_PERM;
+	break;
+    case 'x':
+	if ((access(theFileName, X_OK)) != 0)
+	    return E_PERM;
+	break;
+    default:
+	return E_ARGS;
+    }
+    return E_NONE;
 }
 
 static package
 bf_fileexists(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename) */
-        char infileName[BUF_LEN];
-        Var ret;
-        
-        ret.type = TYPE_INT;
-        ret.v.num = 1;
-        if (build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,'r') != E_NONE) {
-			ret.v.num = 0;        
-		}
-        free_var(arglist);
-        return make_var_pack(ret);
+{				/* (directory, filename) */
+    char infileName[BUF_LEN];
+    Var ret;
+
+    ret.type = TYPE_INT;
+    ret.v.num = 1;
+    if (build_file_name(arglist.v.list[1].v.str,
+			arglist.v.list[2].v.str,
+			infileName, 'r') != E_NONE) {
+	ret.v.num = 0;
+    }
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 static package
 bf_filelength(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename) */
-        FILE *f ;
-        char infileName[BUF_LEN];
-        int num_lines = -1;
-        char buffer[BUF_LEN];
-        Var ret;
-        enum error result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,
-                            'r');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-		f = fopen(infileName, "r");
-        for (num_lines = 0; fgets(buffer, BUF_LEN, f); num_lines++);
-        fclose(f);
-        free_var(arglist);
-        ret.type = TYPE_INT;
-        ret.v.num = num_lines;
-        return make_var_pack(ret);
+{				/* (directory, filename) */
+    FILE *f;
+    char infileName[BUF_LEN];
+    int num_lines = -1;
+    char buffer[BUF_LEN];
+    Var ret;
+    enum error result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, infileName, 'r');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+    f = fopen(infileName, "r");
+    for (num_lines = 0; fgets(buffer, BUF_LEN, f); num_lines++);
+    fclose(f);
+    free_var(arglist);
+    ret.type = TYPE_INT;
+    ret.v.num = num_lines;
+    return make_var_pack(ret);
 }
 
 static package
 bf_filesize(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename) */
-        char infileName[BUF_LEN];
-        struct stat st;
-        Var ret;
-        enum error result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,
-                            'r');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-	    if (stat(infileName, &st) != 0) {
-	        free_var(arglist);
-	        return make_error_pack(E_INVARG);
-	    }
-        ret.type = TYPE_INT;
-        ret.v.num = (long)st.st_size;
-        free_var(arglist);
-        return make_var_pack(ret);
+{				/* (directory, filename) */
+    char infileName[BUF_LEN];
+    struct stat st;
+    Var ret;
+    enum error result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, infileName, 'r');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+    if (stat(infileName, &st) != 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+    ret.type = TYPE_INT;
+    ret.v.num = (long) st.st_size;
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 static package
 bf_filewrite(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename, list, [start, end]) */
-
-        FILE *inFile = NULL;
-        FILE *outFile = NULL;
-        char infileName[BUF_LEN];
-        char outfileName[BUF_LEN];
-        int i, thelength;
-        int index;
-        int start_line = 1;
-        int end_line   = MAX_INT;
-        char buffer[BUF_LEN];
-        Var ret, theline;
-        enum error result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,
-                            'w');
-        if (result == E_PERM) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-        ret.type = TYPE_INT;
-        ret.v.num = 1;
-        theline.type = TYPE_STR;
-
-        sprintf(outfileName,"%s.%li", infileName,time(0));
-
-        if (arglist.v.list[0].v.num > 3) 
-           start_line = arglist.v.list[4].v.num;
-
-       thelength = arglist.v.list[3].v.list[0].v.num;
-
-        if (arglist.v.list[0].v.num > 4) {
-              end_line = arglist.v.list[5].v.num;
-           } else {
-              end_line = arglist.v.list[4].v.num + thelength - 1;
-           }
-
-        if ((outFile = fopen(outfileName, "w")) == 0) {
-           free_var(arglist);
-           return make_error_pack(E_INVARG);
-         }
-
-        inFile = fopen(infileName, "r");
-        index = 1;
-        if (inFile) {
-            while ((index < start_line) && (!feof(inFile))) {
-               fgets(buffer, BUF_LEN, inFile);
-               fputs(buffer,outFile);
-               index++;
-                }
-            while ((index <= end_line) && (!feof(inFile))) {
-               fgets(buffer, BUF_LEN, inFile);
-               index++;
-                }
-         }
+{				/* (directory, filename, list, [start, end]) */
+
+    FILE *inFile = NULL;
+    FILE *outFile = NULL;
+    char infileName[BUF_LEN];
+    char outfileName[BUF_LEN];
+    int i, thelength;
+    int index;
+    int start_line = 1;
+    int end_line = MAX_INT;
+    char buffer[BUF_LEN];
+    Var ret, theline;
+    enum error result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, infileName, 'w');
+    if (result == E_PERM) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    ret.type = TYPE_INT;
+    ret.v.num = 1;
+    theline.type = TYPE_STR;
+
+    sprintf(outfileName, "%s.%li", infileName, time(0));
+
+    if (arglist.v.list[0].v.num > 3)
+	start_line = arglist.v.list[4].v.num;
+
+    thelength = arglist.v.list[3].v.list[0].v.num;
+
+    if (arglist.v.list[0].v.num > 4) {
+	end_line = arglist.v.list[5].v.num;
+    } else {
+	end_line = arglist.v.list[4].v.num + thelength - 1;
+    }
+
+    if ((outFile = fopen(outfileName, "w")) == 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    inFile = fopen(infileName, "r");
+    index = 1;
+    if (inFile) {
+	while ((index < start_line) && (!feof(inFile))) {
+	    fgets(buffer, BUF_LEN, inFile);
+	    fputs(buffer, outFile);
+	    index++;
+	}
+	while ((index <= end_line) && (!feof(inFile))) {
+	    fgets(buffer, BUF_LEN, inFile);
+	    index++;
+	}
+    }
 
     for (i = 1; i <= thelength; i++) {
-        switch (arglist.v.list[3].v.list[i].type) {
-          case TYPE_INT:
-            fprintf (outFile, "%d\n",  arglist.v.list[3].v.list[i].v.num);
-            break;
-          case TYPE_FLOAT:
-            fprintf (outFile, "%g\n",  *(arglist.v.list[3].v.list[i].v.fnum));
-            break;
-          case TYPE_OBJ:
-            fprintf (outFile, "#%d\n",  arglist.v.list[3].v.list[i].v.obj);
-            break;
-          case TYPE_STR:
-            fprintf (outFile, "%s\n",  arglist.v.list[3].v.list[i].v.str);
-            break;
-          case TYPE_ERR:
-              fprintf (outFile, "%s\n", unparse_error( arglist.v.list[3].v.list[i].v.err));
-            break;
-          case TYPE_LIST:
-            fprintf (outFile,  "%s\n", "{list}");
-            break;
-          default:
-            fprintf (outFile,  "%s\n", "*** unrecognized VAR TYPE (this should never happen) ***");
-        }
-      }
-
-        if (inFile) {
-            while (!feof(inFile)) {
-               fgets(buffer, BUF_LEN, inFile);
-               if (!feof(inFile)) {fputs(buffer,outFile);}
-                }
-        }
-
-        if (outFile) {fclose(outFile);}
-        if (inFile)  {fclose(inFile);} 
-        rename(outfileName,infileName);
-        free_var(arglist);
-        return make_var_pack(ret);
+	switch (arglist.v.list[3].v.list[i].type) {
+	case TYPE_INT:
+	    fprintf(outFile, "%d\n", arglist.v.list[3].v.list[i].v.num);
+	    break;
+	case TYPE_FLOAT:
+	    fprintf(outFile, "%g\n",
+		    *(arglist.v.list[3].v.list[i].v.fnum));
+	    break;
+	case TYPE_OBJ:
+	    fprintf(outFile, "#%d\n", arglist.v.list[3].v.list[i].v.obj);
+	    break;
+	case TYPE_STR:
+	    fprintf(outFile, "%s\n", arglist.v.list[3].v.list[i].v.str);
+	    break;
+	case TYPE_ERR:
+	    fprintf(outFile, "%s\n",
+		    unparse_error(arglist.v.list[3].v.list[i].v.err));
+	    break;
+	case TYPE_LIST:
+	    fprintf(outFile, "%s\n", "{list}");
+	    break;
+	default:
+	    fprintf(outFile, "%s\n",
+		    "*** unrecognized VAR TYPE (this should never happen) ***");
+	}
+    }
+
+    if (inFile) {
+	while (!feof(inFile)) {
+	    fgets(buffer, BUF_LEN, inFile);
+	    if (!feof(inFile)) {
+		fputs(buffer, outFile);
+	    }
+	}
+    }
+
+    if (outFile) {
+	fclose(outFile);
+    }
+    if (inFile) {
+	fclose(inFile);
+    }
+    rename(outfileName, infileName);
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 static package
 bf_fileread(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename [start, end]) */
-
-        FILE *f;
-        char infileName[BUF_LEN];
-        char buffer[BUF_LEN];
-        Var ret, theline;
-        int index;
-        int start_line = 1;
-        int end_line   = MAX_INT;
-        enum error result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,
-                            'r');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-        if (arglist.v.list[0].v.num > 2)
-                start_line = arglist.v.list[3].v.num;
-
-        if (arglist.v.list[0].v.num > 3)
-                end_line = arglist.v.list[4].v.num;
-     
-        if ((f = fopen(infileName, "r")) == 0) {
-           free_var(arglist);
-           return make_error_pack(E_INVARG);
-        }
-
-        ret.type = TYPE_LIST;
-        ret = new_list(0);
-        theline.type = TYPE_STR;
-
-        index = 1;
-        while ((index < start_line) && (!feof(f))) {
-                fgets(buffer, BUF_LEN, f);
-                index++;
-                }
-
-        while ((index <= end_line) && (!feof(f))) {
-                fgets(buffer, BUF_LEN, f);
-                if (!feof(f)) {
-                   buffer[strlen(buffer)-1] = '\0';
-                   theline.v.str = str_dup(buffer);
-                   ret = listappend(ret, theline);
-                   }
-                index++;
-                }
-
-        fclose(f);
-        free_var(arglist);
-        return make_var_pack(ret);
+{				/* (directory, filename [start, end]) */
+
+    FILE *f;
+    char infileName[BUF_LEN];
+    char buffer[BUF_LEN];
+    Var ret, theline;
+    int index;
+    int start_line = 1;
+    int end_line = MAX_INT;
+    enum error result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, infileName, 'r');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    if (arglist.v.list[0].v.num > 2)
+	start_line = arglist.v.list[3].v.num;
+
+    if (arglist.v.list[0].v.num > 3)
+	end_line = arglist.v.list[4].v.num;
+
+    if ((f = fopen(infileName, "r")) == 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    ret.type = TYPE_LIST;
+    ret = new_list(0);
+    theline.type = TYPE_STR;
+
+    index = 1;
+    while ((index < start_line) && (!feof(f))) {
+	fgets(buffer, BUF_LEN, f);
+	index++;
+    }
+
+    while ((index <= end_line) && (!feof(f))) {
+	fgets(buffer, BUF_LEN, f);
+	if (!feof(f)) {
+	    buffer[strlen(buffer) - 1] = '\0';
+	    theline.v.str = str_dup(buffer);
+	    ret = listappend(ret, theline);
+	}
+	index++;
+    }
+
+    fclose(f);
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 static package
 bf_fileappend(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename, list) */
-
-        FILE *outFile = NULL;
-        char outfileName[BUF_LEN];
-        int i, thelength;
-        Var ret, theline;
-        enum error result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            outfileName,
-                            'w');
-        if (result == E_PERM) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-        ret.type = TYPE_INT;
-        ret.v.num = 1;
-        theline.type = TYPE_STR;
-
-        if ((outFile = fopen(outfileName, "a")) == 0) {
-            free_var(arglist);
-            return make_error_pack(E_INVARG);
-        }
-
-      thelength = arglist.v.list[3].v.list[0].v.num;
+{				/* (directory, filename, list) */
+
+    FILE *outFile = NULL;
+    char outfileName[BUF_LEN];
+    int i, thelength;
+    Var ret, theline;
+    enum error result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, outfileName, 'w');
+    if (result == E_PERM) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    ret.type = TYPE_INT;
+    ret.v.num = 1;
+    theline.type = TYPE_STR;
+
+    if ((outFile = fopen(outfileName, "a")) == 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    thelength = arglist.v.list[3].v.list[0].v.num;
 
     for (i = 1; i <= thelength; i++) {
-        switch (arglist.v.list[3].v.list[i].type) {
-          case TYPE_INT:
-            fprintf (outFile, "%d\n",  arglist.v.list[3].v.list[i].v.num);
-            break;
-          case TYPE_FLOAT:
-            fprintf (outFile, "%g\n",  *(arglist.v.list[3].v.list[i].v.fnum));
-            break;
-          case TYPE_OBJ:
-            fprintf (outFile, "#%d\n",  arglist.v.list[3].v.list[i].v.obj);
-            break;
-          case TYPE_STR:
-            fprintf (outFile, "%s\n",  arglist.v.list[3].v.list[i].v.str);
-            break;
-          case TYPE_ERR:
-              fprintf (outFile, "%s\n", unparse_error( arglist.v.list[3].v.list[i].v.err));
-            break;
-          case TYPE_LIST:
-            fprintf (outFile,  "%s\n", "{list}");
-            break;
-          default:
-            fprintf (outFile,  "%s\n", "*** unrecognized VAR TYPE (this should never happen) ***");
-        }
-      }
-
-        if (outFile) {fclose(outFile);}
-        free_var(arglist);
-        return make_var_pack(ret);
+	switch (arglist.v.list[3].v.list[i].type) {
+	case TYPE_INT:
+	    fprintf(outFile, "%d\n", arglist.v.list[3].v.list[i].v.num);
+	    break;
+	case TYPE_FLOAT:
+	    fprintf(outFile, "%g\n",
+		    *(arglist.v.list[3].v.list[i].v.fnum));
+	    break;
+	case TYPE_OBJ:
+	    fprintf(outFile, "#%d\n", arglist.v.list[3].v.list[i].v.obj);
+	    break;
+	case TYPE_STR:
+	    fprintf(outFile, "%s\n", arglist.v.list[3].v.list[i].v.str);
+	    break;
+	case TYPE_ERR:
+	    fprintf(outFile, "%s\n",
+		    unparse_error(arglist.v.list[3].v.list[i].v.err));
+	    break;
+	case TYPE_LIST:
+	    fprintf(outFile, "%s\n", "{list}");
+	    break;
+	default:
+	    fprintf(outFile, "%s\n",
+		    "*** unrecognized VAR TYPE (this should never happen) ***");
+	}
+    }
+
+    if (outFile) {
+	fclose(outFile);
+    }
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 static package
 bf_filedelete(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename) */
-        char infileName[BUF_LEN];
-        Var ret;
-         enum error result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,
-                            'w');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
+{				/* (directory, filename) */
+    char infileName[BUF_LEN];
+    Var ret;
+    enum error result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, infileName, 'w');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
 
     if ((remove(infileName)) != 0) {
-        free_var(arglist);
-        return make_error_pack(E_INVARG);
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
     }
 
-        free_var(arglist);
-        ret.type = TYPE_INT;
-        ret.v.num = 1;
-        return make_var_pack(ret);
+    free_var(arglist);
+    ret.type = TYPE_INT;
+    ret.v.num = 1;
+    return make_var_pack(ret);
 }
 
 
 static package
 bf_filelist(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory) */
-
-        typedef struct dirent MYDIRENT ;
-        DIR *dirp;
-        DIR *subdir;
-        MYDIRENT *dp;
-        char rootDir [BUF_LEN];
-        char dirName [BUF_LEN];
-        Var ret, listOfDirs, listOfFiles, theline;
-        int srchlen = 0;
-        enum error result;
-        result = build_dir_name(arglist.v.list[1].v.str,
-                            rootDir,
-                            'd');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-        if (!(dirp = opendir (rootDir))) {
-           free_var(arglist);
-           return make_error_pack(E_INVARG);
-        }
-
-       if (arglist.v.list[0].v.num > 1) {
-           srchlen = strlen(arglist.v.list[2].v.str);
-        }
-        ret.type = TYPE_LIST;
-        ret = new_list(0);
-        listOfDirs.type = TYPE_LIST;
-        listOfDirs = new_list(0);
-        listOfFiles.type = TYPE_LIST;
-        listOfFiles = new_list(0);
-        theline.type = TYPE_STR;
-
-        while ((dp = readdir (dirp)) != 0) {
-           if (strncmp(dp->d_name,".",1)) {
-               sprintf(dirName,"%s/%s", rootDir,dp->d_name);
-               if ((subdir = opendir(dirName))) {
-                    closedir(subdir);
-                    theline.v.str = str_dup(dp->d_name);
-                    listOfDirs = listappend(listOfDirs, theline);
-                }
-                else {
-                  if ((srchlen == 0) || 
-                      (matches(dp->d_name,arglist.v.list[2].v.str))) {
-                      theline.v.str = str_dup(dp->d_name);
-                      listOfFiles = listappend(listOfFiles, theline);
-                  } 
-                }
-            }
-        }
-        closedir (dirp);
-        ret = listappend(ret, listOfFiles);
-        ret = listappend(ret, listOfDirs);
-        free_var(arglist);
-        return make_var_pack(ret);
+{				/* (directory) */
+
+    typedef struct dirent MYDIRENT;
+    DIR *dirp;
+    DIR *subdir;
+    MYDIRENT *dp;
+    char rootDir[BUF_LEN];
+    char dirName[BUF_LEN];
+    Var ret, listOfDirs, listOfFiles, theline;
+    int srchlen = 0;
+    enum error result;
+    result = build_dir_name(arglist.v.list[1].v.str, rootDir, 'd');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    if (!(dirp = opendir(rootDir))) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    if (arglist.v.list[0].v.num > 1) {
+	srchlen = strlen(arglist.v.list[2].v.str);
+    }
+    ret.type = TYPE_LIST;
+    ret = new_list(0);
+    listOfDirs.type = TYPE_LIST;
+    listOfDirs = new_list(0);
+    listOfFiles.type = TYPE_LIST;
+    listOfFiles = new_list(0);
+    theline.type = TYPE_STR;
+
+    while ((dp = readdir(dirp)) != 0) {
+	if (strncmp(dp->d_name, ".", 1)) {
+	    sprintf(dirName, "%s/%s", rootDir, dp->d_name);
+	    if ((subdir = opendir(dirName))) {
+		closedir(subdir);
+		theline.v.str = str_dup(dp->d_name);
+		listOfDirs = listappend(listOfDirs, theline);
+	    } else {
+		if ((srchlen == 0) ||
+		    (matches(dp->d_name, arglist.v.list[2].v.str))) {
+		    theline.v.str = str_dup(dp->d_name);
+		    listOfFiles = listappend(listOfFiles, theline);
+		}
+	    }
+	}
+    }
+    closedir(dirp);
+    ret = listappend(ret, listOfFiles);
+    ret = listappend(ret, listOfDirs);
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 static package
 bf_filegrep(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename, pattern, [option]) */
-
-        FILE *f;
-        char infileName[BUF_LEN];
-        char buffer[BUF_LEN];
-        int line_num = 0;
-        Var ret, theline, anum, slist, nlist;
-        int strings = TRUE;
-        int numbers = FALSE;
-        int showfound = TRUE;
-        enum error result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,
-                            'r');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-        
-        if(arglist.v.list[0].v.num == 4) {
-          if(strstr(arglist.v.list[4].v.str,"n")) {
-             numbers = TRUE;
-             if(!(strstr(arglist.v.list[4].v.str,"s"))) {strings = FALSE;}
-          }
-          if(strstr(arglist.v.list[4].v.str,"v")) {showfound = FALSE;}
-        }
-
-        if ((f = fopen(infileName, "r")) == 0) {
-           free_var(arglist);
-           return make_error_pack(E_INVARG);
-        }
-
-        slist.type = TYPE_LIST;
-        slist = new_list(0);
-        nlist.type = TYPE_LIST;
-        nlist = new_list(0);
-        ret.type = TYPE_LIST;
-        ret = new_list(0);
-
-        theline.type = TYPE_STR;
-        anum.type = TYPE_INT;
-        while (!feof(f)) {
-            fgets(buffer, BUF_LEN, f);
-            line_num++;
-            
-            if (matches(buffer,arglist.v.list[3].v.str) == showfound) {
-                    if ((strings == TRUE) && (!feof(f))) {
-                      buffer[strlen(buffer)-1] = '\0';
-                      theline.v.str = str_dup(buffer);
-                      slist = listappend(slist, theline);
-                    }
-                    if ((numbers == TRUE) && (!feof(f))) {
-                      anum.v.num = line_num;
-                      nlist = listappend(nlist, anum);
-                    }
-                 }
-              }
-
-        fclose(f);
-        free_var(arglist);
-        ret = listappend(ret, slist);
-        ret = listappend(ret, nlist);
-        return make_var_pack(ret);
+{				/* (directory, filename, pattern, [option]) */
+
+    FILE *f;
+    char infileName[BUF_LEN];
+    char buffer[BUF_LEN];
+    int line_num = 0;
+    Var ret, theline, anum, slist, nlist;
+    int strings = TRUE;
+    int numbers = FALSE;
+    int showfound = TRUE;
+    enum error result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, infileName, 'r');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    if (arglist.v.list[0].v.num == 4) {
+	if (strstr(arglist.v.list[4].v.str, "n")) {
+	    numbers = TRUE;
+	    if (!(strstr(arglist.v.list[4].v.str, "s"))) {
+		strings = FALSE;
+	    }
+	}
+	if (strstr(arglist.v.list[4].v.str, "v")) {
+	    showfound = FALSE;
+	}
+    }
+
+    if ((f = fopen(infileName, "r")) == 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    slist.type = TYPE_LIST;
+    slist = new_list(0);
+    nlist.type = TYPE_LIST;
+    nlist = new_list(0);
+    ret.type = TYPE_LIST;
+    ret = new_list(0);
+
+    theline.type = TYPE_STR;
+    anum.type = TYPE_INT;
+    while (!feof(f)) {
+	fgets(buffer, BUF_LEN, f);
+	line_num++;
+
+	if (matches(buffer, arglist.v.list[3].v.str) == showfound) {
+	    if ((strings == TRUE) && (!feof(f))) {
+		buffer[strlen(buffer) - 1] = '\0';
+		theline.v.str = str_dup(buffer);
+		slist = listappend(slist, theline);
+	    }
+	    if ((numbers == TRUE) && (!feof(f))) {
+		anum.v.num = line_num;
+		nlist = listappend(nlist, anum);
+	    }
+	}
+    }
+
+    fclose(f);
+    free_var(arglist);
+    ret = listappend(ret, slist);
+    ret = listappend(ret, nlist);
+    return make_var_pack(ret);
 }
 
 static package
 bf_fileextract(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename, start_pattern, end_pattern [,extra_pattern]) */
-
-        FILE *f;
-        char infileName[BUF_LEN];
-        char buffer[BUF_LEN];
-        Var ret, theline;
-        Var startList, endList;
-        Var startLine, endLine;
-        int numOfLine = 0;
-        int status = 1;
-        int requiredPattern = (arglist.v.list[0].v.num > 4);
-        enum error result;
-        
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            infileName,
-                            'r');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-        if ((strlen(arglist.v.list[2].v.str) == 0) ||
-            (strlen(arglist.v.list[3].v.str) == 0) ||
-            (strlen(arglist.v.list[4].v.str) == 0) ||
-            (strlen(arglist.v.list[arglist.v.list[0].v.num].v.str) == 0)) {
-          free_var(arglist);
-          return make_error_pack(E_INVARG); 
-        }
-
-         if ((f = fopen(infileName, "r")) == 0) {
-           free_var(arglist);
-           return make_error_pack(E_INVARG);
-        }
-
-       ret.type = TYPE_LIST;
-        ret = new_list(0);
-        theline.type = TYPE_STR;
-
-        startList = new_list(0);
-        startList.type = TYPE_LIST;
-
-        endList = new_list(0);
-        endList.type = TYPE_LIST;
-        
-        startLine.type = TYPE_INT;
-        endLine.type = TYPE_INT;
- 
-        while (!feof(f)) {
-            fgets(buffer, BUF_LEN, f);
-            numOfLine++;
-            
-            if (status == 1) {
-               if (matches(buffer,arglist.v.list[3].v.str)) {
-	                startLine.v.num = numOfLine;
-                        if (requiredPattern == TRUE) {
-	            	    status = 2;}
-                        else {
-                            status = 3;}
-	            }
-            }
-            
-            if (status == 2) {
-               if (matches(buffer,arglist.v.list[arglist.v.list[0].v.num].v.str)) {
-	            	status = 3;
-	            }
-            }
-            
-            if ((status == 2) || (status == 3)) {
-              if (matches(buffer,arglist.v.list[4].v.str)) {
-                        if (status == 3) {
-                          startList = listappend(startList, startLine);
-                          endLine.v.num = numOfLine;
-                          endList = listappend(endList, endLine);
-                        }
-                        status = 1;
-                     }
-            }
-        }
-
-        ret = listappend(ret,startList);
-        ret = listappend(ret,endList);        
-        fclose(f);
-        free_var(arglist);
-        return make_var_pack(ret);
+{				/* (directory, filename, start_pattern, end_pattern [,extra_pattern]) */
+
+    FILE *f;
+    char infileName[BUF_LEN];
+    char buffer[BUF_LEN];
+    Var ret, theline;
+    Var startList, endList;
+    Var startLine, endLine;
+    int numOfLine = 0;
+    int status = 1;
+    int requiredPattern = (arglist.v.list[0].v.num > 4);
+    enum error result;
+
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, infileName, 'r');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    if ((strlen(arglist.v.list[2].v.str) == 0) ||
+	(strlen(arglist.v.list[3].v.str) == 0) ||
+	(strlen(arglist.v.list[4].v.str) == 0) ||
+	(strlen(arglist.v.list[arglist.v.list[0].v.num].v.str) == 0)) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    if ((f = fopen(infileName, "r")) == 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    ret.type = TYPE_LIST;
+    ret = new_list(0);
+    theline.type = TYPE_STR;
+
+    startList = new_list(0);
+    startList.type = TYPE_LIST;
+
+    endList = new_list(0);
+    endList.type = TYPE_LIST;
+
+    startLine.type = TYPE_INT;
+    endLine.type = TYPE_INT;
+
+    while (!feof(f)) {
+	fgets(buffer, BUF_LEN, f);
+	numOfLine++;
+
+	if (status == 1) {
+	    if (matches(buffer, arglist.v.list[3].v.str)) {
+		startLine.v.num = numOfLine;
+		if (requiredPattern == TRUE) {
+		    status = 2;
+		} else {
+		    status = 3;
+		}
+	    }
+	}
+
+	if (status == 2) {
+	    if (matches
+		(buffer, arglist.v.list[arglist.v.list[0].v.num].v.str)) {
+		status = 3;
+	    }
+	}
+
+	if ((status == 2) || (status == 3)) {
+	    if (matches(buffer, arglist.v.list[4].v.str)) {
+		if (status == 3) {
+		    startList = listappend(startList, startLine);
+		    endLine.v.num = numOfLine;
+		    endList = listappend(endList, endLine);
+		}
+		status = 1;
+	    }
+	}
+    }
+
+    ret = listappend(ret, startList);
+    ret = listappend(ret, endList);
+    fclose(f);
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 static package
@@ -760,322 +770,316 @@ bf_fileversion(Var arglist, Byte next, void *vdata, Objid progr)
 
 static package
 bf_filerename(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, oldFilename, newFilename) */
-        char oldFilename[BUF_LEN];
-        char newFilename[BUF_LEN];
-        Var ret;
-        enum error result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            oldFilename,
-                            'w');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[3].v.str,
-                            newFilename,
-                            'w');
-        if ((result != E_NONE) && (result != E_INVARG)){
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-    if ((rename(oldFilename,newFilename)) != 0) {
-        return make_error_pack(E_INVARG);
-        }
-        ret.type = TYPE_INT;
-        ret.v.num = 1;
-        free_var(arglist);
-        return make_var_pack(ret);
+{				/* (directory, oldFilename, newFilename) */
+    char oldFilename[BUF_LEN];
+    char newFilename[BUF_LEN];
+    Var ret;
+    enum error result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, oldFilename, 'w');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[3].v.str, newFilename, 'w');
+    if ((result != E_NONE) && (result != E_INVARG)) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    if ((rename(oldFilename, newFilename)) != 0) {
+	return make_error_pack(E_INVARG);
+    }
+    ret.type = TYPE_INT;
+    ret.v.num = 1;
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 #ifdef INCLUDE_FILECHMOD
 
 static package
 bf_filechmod(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename, filemode) */
-        char theRequestedAction[BUF_LEN];
-        char filename[BUF_LEN];
-        char external_files  [BUF_LEN];
-        Var ret;
-        struct stat st;
-        mode_t  mode;
-        char filemode[BUF_LEN];
-        int r1, r2; 
-        enum error result;
-        char localthePathStr [BUF_LEN];
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            filename,
-                            'w');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-
-        strcpy(localthePathStr, arglist.v.list[3].v.str);
-        remove_special_characters(localthePathStr);
-        if (strlen(localthePathStr) == 0) {
-                   free_var(arglist);
-                   return make_error_pack(E_INVARG); }
-
-        strcpy(external_files,EXTERN_FILES_DIR);
-        sprintf(theRequestedAction,"chmod %s %s%s/%s\n",
-                                   localthePathStr,
-                                   external_files,
-                                   arglist.v.list[1].v.str,
-                                   arglist.v.list[2].v.str);
+{				/* (directory, filename, filemode) */
+    char theRequestedAction[BUF_LEN];
+    char filename[BUF_LEN];
+    char external_files[BUF_LEN];
+    Var ret;
+    struct stat st;
+    mode_t mode;
+    char filemode[BUF_LEN];
+    int r1, r2;
+    enum error result;
+    char localthePathStr[BUF_LEN];
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, filename, 'w');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+
+    strcpy(localthePathStr, arglist.v.list[3].v.str);
+    remove_special_characters(localthePathStr);
+    if (strlen(localthePathStr) == 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    strcpy(external_files, EXTERN_FILES_DIR);
+    sprintf(theRequestedAction, "chmod %s %s%s/%s\n",
+	    localthePathStr,
+	    external_files,
+	    arglist.v.list[1].v.str, arglist.v.list[2].v.str);
 
     if ((system(theRequestedAction)) == 0) {
-          return make_error_pack(E_INVARG);
-        }
-
-	stat(filename, &st);
-        ret.type = TYPE_STR;
-        mode = st.st_mode;
-        if (S_ISREG(st.st_mode))  mode = st.st_mode - 32768;
-        if (S_ISDIR(st.st_mode))  mode = st.st_mode - 16384;
-        if (S_ISCHR(st.st_mode))  mode = st.st_mode -  8192;
-        if (S_ISBLK(st.st_mode))  mode = st.st_mode - 24576;
-        if (S_ISSOCK(st.st_mode)) mode = st.st_mode - 49152;
-        if (mode != st.st_mode) {
-           r1 = mode / 8;
-           r1 = r1 - ((r1 / 8) * 8);
-           r2 = mode - ((mode/8) * 8);
-           sprintf(filemode,"%ld%d%d",(long)mode/64,r1,r2);
-           ret.v.str = str_dup(filemode);
-           }
-        else ret.v.str = str_dup("????");
-        free_var(arglist);
-        return make_var_pack(ret);
+	return make_error_pack(E_INVARG);
+    }
+
+    stat(filename, &st);
+    ret.type = TYPE_STR;
+    mode = st.st_mode;
+    if (S_ISREG(st.st_mode))
+	mode = st.st_mode - 32768;
+    if (S_ISDIR(st.st_mode))
+	mode = st.st_mode - 16384;
+    if (S_ISCHR(st.st_mode))
+	mode = st.st_mode - 8192;
+    if (S_ISBLK(st.st_mode))
+	mode = st.st_mode - 24576;
+    if (S_ISSOCK(st.st_mode))
+	mode = st.st_mode - 49152;
+    if (mode != st.st_mode) {
+	r1 = mode / 8;
+	r1 = r1 - ((r1 / 8) * 8);
+	r2 = mode - ((mode / 8) * 8);
+	sprintf(filemode, "%ld%d%d", (long) mode / 64, r1, r2);
+	ret.v.str = str_dup(filemode);
+    } else
+	ret.v.str = str_dup("????");
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 #endif
 
 static package
 bf_fileinfo(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (directory, filename) */
-        char filename[BUF_LEN];
-        Var ret, atime, mtime, ctime, fsize, ftype, fmode, fuid, fgid;
-        struct stat st;
-        struct passwd *pw;
-        struct group *grp;
-        mode_t  mode;
-        int r0, r1, r2; 
-        char filemode[BUF_LEN];
-        enum error result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            filename,
-                            'r');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
-
-        if (stat(filename, &st) != 0) {
-           free_var(arglist);
-           return make_error_pack(E_INVARG);
-        }
-
-        fsize.type = TYPE_INT;
-        fsize.v.num = (long)st.st_size;
-
-        ftype.type = TYPE_STR;
-        ftype.v.str = str_dup("???");
-        mode = st.st_mode;
-        if (S_ISREG(st.st_mode)) {
-           ftype.v.str = str_dup("reg");
-           mode = st.st_mode - 32768;
-           }
-        if (S_ISDIR(st.st_mode)) {
-           ftype.v.str = str_dup("dir");
-           mode = st.st_mode - 16384;
-           }
-
-        if (S_ISFIFO(st.st_mode)) { oklog("FIFO %ld\n",(long)st.st_mode);
-           }
-
-        if (S_ISCHR(st.st_mode)) {
-           ftype.v.str = str_dup("chr");
-           mode = st.st_mode - 8192;
-           }
-
-        if (S_ISBLK(st.st_mode)) {
-           ftype.v.str = str_dup("blk");
-           mode = st.st_mode - 24576;
-           }
-
-        if (S_ISLNK(st.st_mode)) { oklog("LNK  %ld\n",(long)st.st_mode);
-           }
-
-        if (S_ISSOCK(st.st_mode)) {
-           ftype.v.str = str_dup("sck");
-           mode = st.st_mode - 49152;
-           }
-
-        fmode.type = TYPE_STR;
-        fmode.v.str = str_dup("????");
-        if (mode != st.st_mode) {
-           r0 = mode / 512;
-           r1 = mode / 8;
-           r1 = r1 - ((r1 / 8) * 8);
-           r2 = mode - ((mode/8) * 8);
-           sprintf(filemode,"%ld%d%d",(long)mode/64,r1,r2);
-           fmode.v.str = str_dup(filemode);
-           }
-
-        pw = getpwuid((short)st.st_uid);
-        fuid.type = TYPE_STR;
-        fuid.v.str = str_dup(pw->pw_name);
-
-        grp = getgrgid((short)st.st_gid);
-        fgid.type = TYPE_STR;
-        fgid.v.str = str_dup(grp->gr_name);
-
-        atime.type = TYPE_INT;
-        atime.v.num = st.st_atime;
-
-        mtime.type = TYPE_INT;
-        mtime.v.num = st.st_mtime;
-
-        ctime.type = TYPE_INT;
-        ctime.v.num = st.st_ctime;
-        
-        ret.type = TYPE_LIST;
-        ret = new_list(0);
-        ret = listappend(ret, fsize); /* total size of file, bytes */
-        ret = listappend(ret, ftype); /* file type */
-        ret = listappend(ret, fmode); /* file mode */
-        ret = listappend(ret, fuid);  /* user ID of owner */
-        ret = listappend(ret, fgid);  /* group ID of owner */
-        ret = listappend(ret, atime); /* file last access time */
-        ret = listappend(ret, mtime); /* file last modify time */
-        ret = listappend(ret, ctime); /* file last change time */
-
-        free_var(arglist);
-        return make_var_pack(ret);
+{				/* (directory, filename) */
+    char filename[BUF_LEN];
+    Var ret, atime, mtime, ctime, fsize, ftype, fmode, fuid, fgid;
+    struct stat st;
+    struct passwd *pw;
+    struct group *grp;
+    mode_t mode;
+    int r0, r1, r2;
+    char filemode[BUF_LEN];
+    enum error result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, filename, 'r');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
+
+    if (stat(filename, &st) != 0) {
+	free_var(arglist);
+	return make_error_pack(E_INVARG);
+    }
+
+    fsize.type = TYPE_INT;
+    fsize.v.num = (long) st.st_size;
+
+    ftype.type = TYPE_STR;
+    ftype.v.str = str_dup("???");
+    mode = st.st_mode;
+    if (S_ISREG(st.st_mode)) {
+	ftype.v.str = str_dup("reg");
+	mode = st.st_mode - 32768;
+    }
+    if (S_ISDIR(st.st_mode)) {
+	ftype.v.str = str_dup("dir");
+	mode = st.st_mode - 16384;
+    }
+
+    if (S_ISFIFO(st.st_mode)) {
+	oklog("FIFO %ld\n", (long) st.st_mode);
+    }
+
+    if (S_ISCHR(st.st_mode)) {
+	ftype.v.str = str_dup("chr");
+	mode = st.st_mode - 8192;
+    }
+
+    if (S_ISBLK(st.st_mode)) {
+	ftype.v.str = str_dup("blk");
+	mode = st.st_mode - 24576;
+    }
+
+    if (S_ISLNK(st.st_mode)) {
+	oklog("LNK  %ld\n", (long) st.st_mode);
+    }
+
+    if (S_ISSOCK(st.st_mode)) {
+	ftype.v.str = str_dup("sck");
+	mode = st.st_mode - 49152;
+    }
+
+    fmode.type = TYPE_STR;
+    fmode.v.str = str_dup("????");
+    if (mode != st.st_mode) {
+	r0 = mode / 512;
+	r1 = mode / 8;
+	r1 = r1 - ((r1 / 8) * 8);
+	r2 = mode - ((mode / 8) * 8);
+	sprintf(filemode, "%ld%d%d", (long) mode / 64, r1, r2);
+	fmode.v.str = str_dup(filemode);
+    }
+
+    pw = getpwuid((short) st.st_uid);
+    fuid.type = TYPE_STR;
+    fuid.v.str = str_dup(pw->pw_name);
+
+    grp = getgrgid((short) st.st_gid);
+    fgid.type = TYPE_STR;
+    fgid.v.str = str_dup(grp->gr_name);
+
+    atime.type = TYPE_INT;
+    atime.v.num = st.st_atime;
+
+    mtime.type = TYPE_INT;
+    mtime.v.num = st.st_mtime;
+
+    ctime.type = TYPE_INT;
+    ctime.v.num = st.st_ctime;
+
+    ret.type = TYPE_LIST;
+    ret = new_list(0);
+    ret = listappend(ret, fsize);	/* total size of file, bytes */
+    ret = listappend(ret, ftype);	/* file type */
+    ret = listappend(ret, fmode);	/* file mode */
+    ret = listappend(ret, fuid);	/* user ID of owner */
+    ret = listappend(ret, fgid);	/* group ID of owner */
+    ret = listappend(ret, atime);	/* file last access time */
+    ret = listappend(ret, mtime);	/* file last modify time */
+    ret = listappend(ret, ctime);	/* file last change time */
+
+    free_var(arglist);
+    return make_var_pack(ret);
 }
 
 #ifdef INCLUDE_FILERUN
 
 static package
 bf_filerun(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (filename, arguments) */
-        char theRequestedAction[BUF_LEN];
-        Var ret, theArgs, theline;
-        int i, numOfArgs, result;
-        char fileName[BUF_LEN];
-        char external_bin [BUF_LEN];
-
-        theline.type = TYPE_STR;
-        theArgs.type = TYPE_LIST;
-        theArgs = new_list(0);
-        numOfArgs = arglist.v.list[0].v.num;
-        for (i = 1; i <= numOfArgs; i++) {
-	        switch (arglist.v.list[i].type) {
-	          case TYPE_STR:
-                char localthePathStr [BUF_LEN];
-                strcpy(localthePathStr, arglist.v.list[i].v.str);
-                remove_special_characters( localthePathStr); 
-                theline.v.str = str_dup(localthePathStr);
-
-                if (( strstr(theline.v.str,"/.")) ||
-                   (!strncmp(theline.v.str,".",1)) ||
-                   (!strncmp(theline.v.str,"/",1))) {
-                    free_var(arglist);
-                    free_var(theline);
-                    return make_error_pack(E_PERM);
-                    }
-
-                theArgs = listappend(theArgs,theline);
-	        break;
-	          case TYPE_LIST:
-                    if (arglist.v.list[i].v.list[0].v.num < 2) {
-                        theline.v.str = str_dup("");
-                        theArgs = listappend(theArgs,theline);
-                    } else {
-                    if ((arglist.v.list[i].v.list[1].type != TYPE_STR) ||
-                       (arglist.v.list[i].v.list[2].type != TYPE_STR)) {
-			            free_var(arglist);
-                                    free_var(theline);
-			            return make_error_pack(E_TYPE); 
-                       }
-                    result = build_file_name(arglist.v.list[i].v.list[1].v.str,
-                                             arglist.v.list[i].v.list[2].v.str,
-                                             fileName,
-                                             'r');
-                        theline.v.str = str_dup(fileName);
-                        theArgs = listappend(theArgs,theline);
-					}
-	            break;
-	          default:
-                free_var(arglist);
-                free_var(theline);
-                return make_error_pack(E_INVARG);
-	        }        
-        }
-       
-       numOfArgs = theArgs.v.list[0].v.num;
-       strcpy(external_bin,EXTERN_BIN_DIR);
-       sprintf(theRequestedAction,"%s%s ",external_bin,theArgs.v.list[1].v.str);
-
-        if ((numOfArgs > 1) && (strlen(theArgs.v.list[2].v.str)!=0)) {
-                 sprintf(theRequestedAction,"cat %s | %s%s",
-                                   theArgs.v.list[2].v.str,
-                                   external_bin,
-                                   theArgs.v.list[1].v.str);
-        } else {
-                 sprintf(theRequestedAction,"%s%s ",
-                                   external_bin,
-                                   theArgs.v.list[1].v.str);
-        }
-
-        for (i = 4; i <= numOfArgs; i++) {
-        sprintf(theRequestedAction,"%s %s",
-                                   theRequestedAction,
-                                   theArgs.v.list[i].v.str);
-        }
-
-        if ((numOfArgs > 2) && (strlen(theArgs.v.list[3].v.str))){
-            sprintf(theRequestedAction,"%s > %s",
-                                   theRequestedAction,
-                                   theArgs.v.list[3].v.str);
-        }
-
-        sprintf(theRequestedAction,"%s 2>&1", theRequestedAction);
-        system(theRequestedAction);
-
-        ret.type = TYPE_INT;
-        ret.v.num = 1; /* always !! */
-        free_var(arglist);
-        free_var(theline);
-        return make_var_pack(ret);
+{				/* (filename, arguments) */
+    char theRequestedAction[BUF_LEN];
+    Var ret, theArgs, theline;
+    int i, numOfArgs, result;
+    char fileName[BUF_LEN];
+    char external_bin[BUF_LEN];
+
+    theline.type = TYPE_STR;
+    theArgs.type = TYPE_LIST;
+    theArgs = new_list(0);
+    numOfArgs = arglist.v.list[0].v.num;
+    for (i = 1; i <= numOfArgs; i++) {
+	switch (arglist.v.list[i].type) {
+	case TYPE_STR:
+	    char localthePathStr[BUF_LEN];
+	    strcpy(localthePathStr, arglist.v.list[i].v.str);
+	    remove_special_characters(localthePathStr);
+	    theline.v.str = str_dup(localthePathStr);
+
+	    if ((strstr(theline.v.str, "/.")) ||
+		(!strncmp(theline.v.str, ".", 1)) ||
+		(!strncmp(theline.v.str, "/", 1))) {
+		free_var(arglist);
+		free_var(theline);
+		return make_error_pack(E_PERM);
+	    }
+
+	    theArgs = listappend(theArgs, theline);
+	    break;
+	case TYPE_LIST:
+	    if (arglist.v.list[i].v.list[0].v.num < 2) {
+		theline.v.str = str_dup("");
+		theArgs = listappend(theArgs, theline);
+	    } else {
+		if ((arglist.v.list[i].v.list[1].type != TYPE_STR) ||
+		    (arglist.v.list[i].v.list[2].type != TYPE_STR)) {
+		    free_var(arglist);
+		    free_var(theline);
+		    return make_error_pack(E_TYPE);
+		}
+		result = build_file_name(arglist.v.list[i].v.list[1].v.str,
+					 arglist.v.list[i].v.list[2].v.str,
+					 fileName, 'r');
+		theline.v.str = str_dup(fileName);
+		theArgs = listappend(theArgs, theline);
+	    }
+	    break;
+	default:
+	    free_var(arglist);
+	    free_var(theline);
+	    return make_error_pack(E_INVARG);
+	}
+    }
+
+    numOfArgs = theArgs.v.list[0].v.num;
+    strcpy(external_bin, EXTERN_BIN_DIR);
+    sprintf(theRequestedAction, "%s%s ", external_bin,
+	    theArgs.v.list[1].v.str);
+
+    if ((numOfArgs > 1) && (strlen(theArgs.v.list[2].v.str) != 0)) {
+	sprintf(theRequestedAction, "cat %s | %s%s",
+		theArgs.v.list[2].v.str,
+		external_bin, theArgs.v.list[1].v.str);
+    } else {
+	sprintf(theRequestedAction, "%s%s ",
+		external_bin, theArgs.v.list[1].v.str);
+    }
+
+    for (i = 4; i <= numOfArgs; i++) {
+	sprintf(theRequestedAction, "%s %s",
+		theRequestedAction, theArgs.v.list[i].v.str);
+    }
+
+    if ((numOfArgs > 2) && (strlen(theArgs.v.list[3].v.str))) {
+	sprintf(theRequestedAction, "%s > %s",
+		theRequestedAction, theArgs.v.list[3].v.str);
+    }
+
+    sprintf(theRequestedAction, "%s 2>&1", theRequestedAction);
+    system(theRequestedAction);
+
+    ret.type = TYPE_INT;
+    ret.v.num = 1;		/* always !! */
+    free_var(arglist);
+    free_var(theline);
+    return make_var_pack(ret);
 }
 #endif
 
 static package
 bf_filemkdir(Var arglist, Byte next, void *vdata, Objid progr)
-{  /* filemkdir(base-directory-name, new-directory-name) */
-      char newdirName[BUF_LEN];
-      mode_t create_mode = CREATE_NEW_DIR_MODE;
-      Var ret;
-        enum error result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            newdirName,
-                            'd');
-        if ((result != E_NONE) && (result != E_INVARG)){
-                free_var(arglist);
-                return make_error_pack(result);
-        }
+{				/* filemkdir(base-directory-name, new-directory-name) */
+    char newdirName[BUF_LEN];
+    mode_t create_mode = CREATE_NEW_DIR_MODE;
+    Var ret;
+    enum error result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, newdirName, 'd');
+    if ((result != E_NONE) && (result != E_INVARG)) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
 
     if ((mkdir(newdirName, create_mode)) != 0) {
-            free_var(arglist);
-            return make_error_pack(E_PERM); }
+	free_var(arglist);
+	return make_error_pack(E_PERM);
+    }
 
     ret.type = TYPE_INT;
     ret.v.num = 1;
@@ -1085,22 +1089,20 @@ bf_filemkdir(Var arglist, Byte next, void *vdata, Objid progr)
 
 static package
 bf_filermdir(Var arglist, Byte next, void *vdata, Objid prog)
-{  /* filermdir(base-directory-name, directory-name) */
-        char rmDirName[BUF_LEN];
-        Var  ret;
-        enum error result;
-        result = build_file_name(arglist.v.list[1].v.str,
-                            arglist.v.list[2].v.str,
-                            rmDirName,
-                            'd');
-        if (result != E_NONE) {
-                free_var(arglist);
-                return make_error_pack(result);
-        }
+{				/* filermdir(base-directory-name, directory-name) */
+    char rmDirName[BUF_LEN];
+    Var ret;
+    enum error result;
+    result = build_file_name(arglist.v.list[1].v.str,
+			     arglist.v.list[2].v.str, rmDirName, 'd');
+    if (result != E_NONE) {
+	free_var(arglist);
+	return make_error_pack(result);
+    }
 
     if ((rmdir(rmDirName)) != 0) {
-        free_var(arglist);
-        return make_error_pack(E_PERM); 
+	free_var(arglist);
+	return make_error_pack(E_PERM);
     }
     free_var(arglist);
     ret.type = TYPE_INT;
@@ -1120,34 +1122,51 @@ bf_fileerror(Var arglist, Byte next, void *vdata, Objid progr)
 
 void
 register_files(void)
-{ 
-    oklog("          (Using File Utilities Package version %s)\n", FUP_version);
+{
+    oklog("          (Using File Utilities Package version %s)\n",
+	  FUP_version);
 
-    (void) register_function("fileappend",  3,  3, bf_fileappend,  TYPE_STR, TYPE_STR, TYPE_LIST);
+    (void) register_function("fileappend", 3, 3, bf_fileappend, TYPE_STR,
+			     TYPE_STR, TYPE_LIST);
 
 #ifdef INCLUDE_FILECHMOD
-    (void) register_function("filechmod",   3,  3, bf_filechmod,   TYPE_STR, TYPE_STR, TYPE_STR);
+    (void) register_function("filechmod", 3, 3, bf_filechmod, TYPE_STR,
+			     TYPE_STR, TYPE_STR);
 #endif
 
-    (void) register_function("filedelete",  2,  2, bf_filedelete,  TYPE_STR, TYPE_STR);
-    (void) register_function("fileerror",   0,  0, bf_fileerror);
-    (void) register_function("fileexists",  2,  2, bf_fileexists,  TYPE_STR, TYPE_STR);
-    (void) register_function("fileextract", 4,  5, bf_fileextract, TYPE_STR, TYPE_STR, TYPE_STR, TYPE_STR, TYPE_STR);
-    (void) register_function("filegrep",    3,  4, bf_filegrep,    TYPE_STR, TYPE_STR, TYPE_STR, TYPE_STR);
-    (void) register_function("fileinfo",    2,  2, bf_fileinfo,    TYPE_STR, TYPE_STR);
-    (void) register_function("filelength",  2,  2, bf_filelength,  TYPE_STR, TYPE_STR);
-    (void) register_function("filelist",    1,  2, bf_filelist,    TYPE_STR, TYPE_STR);
-    (void) register_function("filemkdir",   2,  2, bf_filemkdir,   TYPE_STR, TYPE_STR);
-    (void) register_function("fileread",    2,  4, bf_fileread,    TYPE_STR, TYPE_STR, TYPE_INT, TYPE_INT);
-    (void) register_function("filerename",  3,  3, bf_filerename,  TYPE_STR, TYPE_STR, TYPE_STR);
-    (void) register_function("filermdir",   2,  2, bf_filermdir,   TYPE_STR, TYPE_STR);
+    (void) register_function("filedelete", 2, 2, bf_filedelete, TYPE_STR,
+			     TYPE_STR);
+    (void) register_function("fileerror", 0, 0, bf_fileerror);
+    (void) register_function("fileexists", 2, 2, bf_fileexists, TYPE_STR,
+			     TYPE_STR);
+    (void) register_function("fileextract", 4, 5, bf_fileextract, TYPE_STR,
+			     TYPE_STR, TYPE_STR, TYPE_STR, TYPE_STR);
+    (void) register_function("filegrep", 3, 4, bf_filegrep, TYPE_STR,
+			     TYPE_STR, TYPE_STR, TYPE_STR);
+    (void) register_function("fileinfo", 2, 2, bf_fileinfo, TYPE_STR,
+			     TYPE_STR);
+    (void) register_function("filelength", 2, 2, bf_filelength, TYPE_STR,
+			     TYPE_STR);
+    (void) register_function("filelist", 1, 2, bf_filelist, TYPE_STR,
+			     TYPE_STR);
+    (void) register_function("filemkdir", 2, 2, bf_filemkdir, TYPE_STR,
+			     TYPE_STR);
+    (void) register_function("fileread", 2, 4, bf_fileread, TYPE_STR,
+			     TYPE_STR, TYPE_INT, TYPE_INT);
+    (void) register_function("filerename", 3, 3, bf_filerename, TYPE_STR,
+			     TYPE_STR, TYPE_STR);
+    (void) register_function("filermdir", 2, 2, bf_filermdir, TYPE_STR,
+			     TYPE_STR);
 
 #ifdef INCLUDE_FILERUN
-    (void) register_function("filerun",     1, -1, bf_filerun,     TYPE_STR, TYPE_LIST, TYPE_LIST); 
+    (void) register_function("filerun", 1, -1, bf_filerun, TYPE_STR,
+			     TYPE_LIST, TYPE_LIST);
 #endif
 
-    (void) register_function("filesize",    2,  2, bf_filesize,    TYPE_STR, TYPE_STR);
-    (void) register_function("fileversion", 0,  0, bf_fileversion);
-    (void) register_function("filewrite",   3,  5, bf_filewrite,   TYPE_STR, TYPE_STR, TYPE_LIST, TYPE_INT, TYPE_INT);
+    (void) register_function("filesize", 2, 2, bf_filesize, TYPE_STR,
+			     TYPE_STR);
+    (void) register_function("fileversion", 0, 0, bf_fileversion);
+    (void) register_function("filewrite", 3, 5, bf_filewrite, TYPE_STR,
+			     TYPE_STR, TYPE_LIST, TYPE_INT, TYPE_INT);
 
 }
diff --git a/server/ext-FUP_options.h b/server/ext-FUP_options.h
index cef173c..db78bd0 100644
--- a/server/ext-FUP_options.h
+++ b/server/ext-FUP_options.h
@@ -13,13 +13,13 @@ You can change the name of the base directory for the external file
 hierarchy, which is 'hard-coded' into the server upon compilation.
 To change it from its default ('files'), edit the line:
 */
-     #define EXTERN_FILES_DIR   "files/"
+#define EXTERN_FILES_DIR   "files/"
 
 
 /***************************************************************************
 The default name for the directory that holds the executables is defined in:
 */
-     #define EXTERN_BIN_DIR     "bin/"
+#define EXTERN_BIN_DIR     "bin/"
 
 
 /******************************************************************************
@@ -32,8 +32,7 @@ It is read-only by default. To make it writable from the MOO, comment the line:
 /**********************************************************
 The default mode for new directories can be configured too:
 */
-     #define CREATE_NEW_DIR_MODE		0755
+#define CREATE_NEW_DIR_MODE		0755
 
 #define INCLUDE_FILECHMOD
 #define INCLUDE_FILERUN
-
diff --git a/server/ext-xml.c b/server/ext-xml.c
index b5e7fee..23de37b 100644
--- a/server/ext-xml.c
+++ b/server/ext-xml.c
@@ -32,175 +32,176 @@
 typedef struct XMLdata XMLdata;
 
 struct XMLdata {
-  XMLdata *parent;
-  Stream *body;
-  Var element;
+    XMLdata *parent;
+    Stream *body;
+    Var element;
 };
 
 static XMLdata *
-new_node(XMLdata *parent, const char *name) 
+new_node(XMLdata * parent, const char *name)
 {
-  /* TODO: may want a suballocator here; gonna be needing a lot of
-   * these 2-ptr + 1 var nodes
-   */
-  XMLdata *node;
-  Var element;
-
-  char *nametemp       = NULL;
-  const char *nodename = NULL;
-  char *nsname         = NULL;
-  char *delim          = NULL;
-
-  if ( (delim = strchr((char *)name, NS_DELIMITER)) != NULL ) {
-    int index       = delim - name;
-    nametemp        = str_dup(name);
-    nametemp[index] = '\0';
-    nodename        = nametemp + index + 1;
-    nsname          = nametemp;
-  } else {
-    nodename = name;
-  }
-
-  node = (XMLdata *)mymalloc(1*sizeof(XMLdata), M_XML_DATA);
-  element = new_list(nsname ? 5 : 4);
-
-  /* {name, attribs, body, children} */ 
-  element.v.list[1].type  = TYPE_STR;
-  element.v.list[1].v.str = str_dup(nodename);
-  element.v.list[2]       = new_list(0);
-  element.v.list[3].type  = TYPE_INT;
-  element.v.list[3].v.num = 0;
-  element.v.list[4]       = new_list(0);
-  if (nsname) {
-    element.v.list[5].type = TYPE_STR;
-    element.v.list[5].v.str = str_dup(nsname);
-  }
-  node->body = NULL;
-  node->element = element;
-  node->parent = parent;
-
-  if (nametemp) free_str(nametemp);
-
-  return node;
-}			
-
-static void 
-finish_node(XMLdata *data)
+    /* TODO: may want a suballocator here; gonna be needing a lot of
+     * these 2-ptr + 1 var nodes
+     */
+    XMLdata *node;
+    Var element;
+
+    char *nametemp = NULL;
+    const char *nodename = NULL;
+    char *nsname = NULL;
+    char *delim = NULL;
+
+    if ((delim = strchr((char *) name, NS_DELIMITER)) != NULL) {
+	int index = delim - name;
+	nametemp = str_dup(name);
+	nametemp[index] = '\0';
+	nodename = nametemp + index + 1;
+	nsname = nametemp;
+    } else {
+	nodename = name;
+    }
+
+    node = (XMLdata *) mymalloc(1 * sizeof(XMLdata), M_XML_DATA);
+    element = new_list(nsname ? 5 : 4);
+
+    /* {name, attribs, body, children} */
+    element.v.list[1].type = TYPE_STR;
+    element.v.list[1].v.str = str_dup(nodename);
+    element.v.list[2] = new_list(0);
+    element.v.list[3].type = TYPE_INT;
+    element.v.list[3].v.num = 0;
+    element.v.list[4] = new_list(0);
+    if (nsname) {
+	element.v.list[5].type = TYPE_STR;
+	element.v.list[5].v.str = str_dup(nsname);
+    }
+    node->body = NULL;
+    node->element = element;
+    node->parent = parent;
+
+    if (nametemp)
+	free_str(nametemp);
+
+    return node;
+}
+
+static void
+finish_node(XMLdata * data)
 {
-  XMLdata *parent = data->parent;
-  Var element = data->element;
-  Var body;
-  Stream *s = data->body;
-  body.type = TYPE_STR;
-  if(s == NULL) {
-    body.v.str = str_dup("");
-  } else {
-    body.v.str = str_dup(reset_stream(s));
-  }
-  element.v.list[3] = body;
-  if(parent != NULL) {
-    Var pelement = parent->element;
-    pelement.v.list[4] = listappend(pelement.v.list[4], var_ref(element));
-  }
+    XMLdata *parent = data->parent;
+    Var element = data->element;
+    Var body;
+    Stream *s = data->body;
+    body.type = TYPE_STR;
+    if (s == NULL) {
+	body.v.str = str_dup("");
+    } else {
+	body.v.str = str_dup(reset_stream(s));
+    }
+    element.v.list[3] = body;
+    if (parent != NULL) {
+	Var pelement = parent->element;
+	pelement.v.list[4] =
+	    listappend(pelement.v.list[4], var_ref(element));
+    }
 }
-  
+
 static void
-free_node(XMLdata *data) 
+free_node(XMLdata * data)
 {
-  free_var(data->element);
-  if(data->body != NULL)
-    free_stream(data->body);
-  myfree(data, M_XML_DATA);
+    free_var(data->element);
+    if (data->body != NULL)
+	free_stream(data->body);
+    myfree(data, M_XML_DATA);
 }
 
 static void
-flush_nodes(XMLdata *bottom) 
+flush_nodes(XMLdata * bottom)
 {
-  XMLdata *parent = bottom->parent;
-  free_node(bottom);
-  if(parent != NULL) {
-    flush_nodes(parent);
-  }
+    XMLdata *parent = bottom->parent;
+    free_node(bottom);
+    if (parent != NULL) {
+	flush_nodes(parent);
+    }
 }
 
 static void
 xml_startElement(void *userData, const char *name, const char **atts)
 {
-  XMLdata **data = (XMLdata**)userData;
-  XMLdata *parent = *data;
-
-  XMLdata *node = new_node(parent, name);
-  const char **patts = atts;
-
-  char *delim;
-
-  while(*patts != NULL) {
-    Var pair;
-    if ( (delim = (char *)strchr(patts[0], NS_DELIMITER)) )
-    {
-      int index       = delim - patts[0];
-      char *nametemp  = str_dup(patts[0]);
-      nametemp[index] = '\0';
-
-      pair = new_list(3);
-      pair.v.list[3].type = TYPE_STR;
-      pair.v.list[3].v.str = str_dup(nametemp);
-      pair.v.list[1].type = TYPE_STR;
-      pair.v.list[1].v.str = str_dup(nametemp + index + 1);
-      if (nametemp) free_str(nametemp);
+    XMLdata **data = (XMLdata **) userData;
+    XMLdata *parent = *data;
+
+    XMLdata *node = new_node(parent, name);
+    const char **patts = atts;
+
+    char *delim;
+
+    while (*patts != NULL) {
+	Var pair;
+	if ((delim = (char *) strchr(patts[0], NS_DELIMITER))) {
+	    int index = delim - patts[0];
+	    char *nametemp = str_dup(patts[0]);
+	    nametemp[index] = '\0';
+
+	    pair = new_list(3);
+	    pair.v.list[3].type = TYPE_STR;
+	    pair.v.list[3].v.str = str_dup(nametemp);
+	    pair.v.list[1].type = TYPE_STR;
+	    pair.v.list[1].v.str = str_dup(nametemp + index + 1);
+	    if (nametemp)
+		free_str(nametemp);
+	} else {
+	    pair = new_list(2);
+	    pair.v.list[1].type = TYPE_STR;
+	    pair.v.list[1].v.str = str_dup(patts[0]);
+	}
+	pair.v.list[2].type = TYPE_STR;
+	pair.v.list[2].v.str = str_dup(patts[1]);
+	patts += 2;
+	node->element.v.list[2] =
+	    listappend(node->element.v.list[2], pair);
     }
-    else
-    {
-      pair = new_list(2);
-      pair.v.list[1].type = TYPE_STR;
-      pair.v.list[1].v.str = str_dup(patts[0]);
-    }
-    pair.v.list[2].type = TYPE_STR;
-    pair.v.list[2].v.str = str_dup(patts[1]);
-    patts += 2;
-    node->element.v.list[2] = listappend(node->element.v.list[2], pair);
-  }
 
-  *data = node;
+    *data = node;
 }
 
-static void 
-xml_characterDataHandler(void *userData, const XML_Char *s, int len)
+static void
+xml_characterDataHandler(void *userData, const XML_Char * s, int len)
 {
-  XMLdata **data = (XMLdata**)userData;
-  XMLdata *node = *data;
-  Stream *sp = node->body;
+    XMLdata **data = (XMLdata **) userData;
+    XMLdata *node = *data;
+    Stream *sp = node->body;
 
-  if(sp == NULL) {
-    node->body = new_stream(len);
-    sp = node->body; 
-  }
+    if (sp == NULL) {
+	node->body = new_stream(len);
+	sp = node->body;
+    }
 
-  stream_add_string(sp, raw_bytes_to_binary(s, len));
+    stream_add_string(sp, raw_bytes_to_binary(s, len));
 }
 
-static void 
-xml_streamCharacterDataHandler(void *userData, const XML_Char *s, int len)
+static void
+xml_streamCharacterDataHandler(void *userData, const XML_Char * s, int len)
 {
-  XMLdata **data = (XMLdata**)userData;
-  XMLdata *node = *data;
-  Var element = node->element;
-  Var v;
-  v.type = TYPE_STR;
-  v.v.str = str_dup(raw_bytes_to_binary(s, len));
-  element.v.list[4] = listappend(element.v.list[4], v);
+    XMLdata **data = (XMLdata **) userData;
+    XMLdata *node = *data;
+    Var element = node->element;
+    Var v;
+    v.type = TYPE_STR;
+    v.v.str = str_dup(raw_bytes_to_binary(s, len));
+    element.v.list[4] = listappend(element.v.list[4], v);
 }
 
 
 static void
 xml_endElement(void *userData, const char *name)
 {
-  XMLdata **data = (XMLdata**)userData;
-  XMLdata *node = *data;
-  XMLdata *parent = node->parent;
-  finish_node(node);
-  free_node(node);
-  *data = parent;
+    XMLdata **data = (XMLdata **) userData;
+    XMLdata *node = *data;
+    XMLdata *parent = node->parent;
+    finish_node(node);
+    free_node(node);
+    *data = parent;
 }
 
 /**
@@ -211,76 +212,80 @@ xml_endElement(void *userData, const char *name)
  *
  * See documentation (ext-xml.README) for examples.
  */
-static package 
+static package
 parse_xml(const char *data, int bool_stream, int bool_parsens)
-  {
-  /*
-   * FIXME: Feed expat smaller chunks of the string and 
-   * check for task timeout between chunks
-   *
-   */
-  int decoded_length;
-  const char *decoded;
-  package result; 
-  XML_Parser parser;
-  XMLdata *root = new_node(NULL, "");
-  XMLdata *child = root;
-
-  if (bool_parsens) {
-    parser = XML_ParserCreateNS(NULL, NS_DELIMITER);
-  } else {
-    parser = XML_ParserCreate(NULL);
-  }
-  
-  decoded_length = strlen(data);
-  decoded = data;
-  XML_SetUserData(parser, &child);
-  XML_SetElementHandler(parser, xml_startElement, xml_endElement);
-  if(bool_stream) {
-    XML_SetCharacterDataHandler(parser, xml_streamCharacterDataHandler);
-  } else {
-    XML_SetCharacterDataHandler(parser, xml_characterDataHandler);
-  }
-  if (!XML_Parse(parser, decoded, decoded_length, 1)) {
-    Var r;
-    r.type = TYPE_INT;
-    r.v.num = XML_GetCurrentByteIndex(parser);
-    flush_nodes(child);
-    result = make_raise_pack(E_INVARG, 
-			     XML_ErrorString(XML_GetErrorCode(parser)),
-			     r);
-  } else {
-    finish_node(root);
-    result = make_var_pack(var_ref(root->element.v.list[4].v.list[1]));
-    free_node(root);
-  }
-  XML_ParserFree(parser);
-  return result; 
+{
+    /*
+     * FIXME: Feed expat smaller chunks of the string and 
+     * check for task timeout between chunks
+     *
+     */
+    int decoded_length;
+    const char *decoded;
+    package result;
+    XML_Parser parser;
+    XMLdata *root = new_node(NULL, "");
+    XMLdata *child = root;
+
+    if (bool_parsens) {
+	parser = XML_ParserCreateNS(NULL, NS_DELIMITER);
+    } else {
+	parser = XML_ParserCreate(NULL);
+    }
+
+    decoded_length = strlen(data);
+    decoded = data;
+    XML_SetUserData(parser, &child);
+    XML_SetElementHandler(parser, xml_startElement, xml_endElement);
+    if (bool_stream) {
+	XML_SetCharacterDataHandler(parser,
+				    xml_streamCharacterDataHandler);
+    } else {
+	XML_SetCharacterDataHandler(parser, xml_characterDataHandler);
+    }
+    if (!XML_Parse(parser, decoded, decoded_length, 1)) {
+	Var r;
+	r.type = TYPE_INT;
+	r.v.num = XML_GetCurrentByteIndex(parser);
+	flush_nodes(child);
+	result = make_raise_pack(E_INVARG,
+				 XML_ErrorString(XML_GetErrorCode(parser)),
+				 r);
+    } else {
+	finish_node(root);
+	result = make_var_pack(var_ref(root->element.v.list[4].v.list[1]));
+	free_node(root);
+    }
+    XML_ParserFree(parser);
+    return result;
 }
 
 
 static package
-bf_parse_xml_document(Var arglist, Byte next, void *vdata, Objid progr) 
+bf_parse_xml_document(Var arglist, Byte next, void *vdata, Objid progr)
 {
-  int bool_parsens = (arglist.v.list[0].v.num >= 2 && is_true(arglist.v.list[2]));
-  package result = parse_xml(arglist.v.list[1].v.str, 1, bool_parsens);
-  free_var(arglist);
-  return result;
+    int bool_parsens = (arglist.v.list[0].v.num >= 2
+			&& is_true(arglist.v.list[2]));
+    package result = parse_xml(arglist.v.list[1].v.str, 1, bool_parsens);
+    free_var(arglist);
+    return result;
 }
 
 static package
 bf_parse_xml_tree(Var arglist, Byte next, void *vdata, Objid progr)
 {
-  int bool_parsens = (arglist.v.list[0].v.num >= 2 && is_true(arglist.v.list[2]));
-  package result = parse_xml(arglist.v.list[1].v.str, 0, bool_parsens);
-  free_var(arglist);
-  return result;
+    int bool_parsens = (arglist.v.list[0].v.num >= 2
+			&& is_true(arglist.v.list[2]));
+    package result = parse_xml(arglist.v.list[1].v.str, 0, bool_parsens);
+    free_var(arglist);
+    return result;
 }
 
 void
 register_xml()
 {
-    register_function("xml_parse_tree", 1, 2, bf_parse_xml_tree, TYPE_STR, TYPE_ANY);
-    register_function("xml_parse_document", 1, 2, bf_parse_xml_document, TYPE_STR, TYPE_ANY);
+    register_function("xml_parse_tree", 1, 2, bf_parse_xml_tree, TYPE_STR,
+		      TYPE_ANY);
+    register_function("xml_parse_document", 1, 2, bf_parse_xml_document,
+		      TYPE_STR, TYPE_ANY);
 }
-
diff --git a/server/extensions.c b/server/extensions.c
index c2f0ac7..85afc7e 100644
--- a/server/extensions.c
+++ b/server/extensions.c
@@ -59,10 +59,10 @@
 extern void register_files(void);
 
 /* utime - andy */
-#include <sys/time.h>    /* these two for gettimeofday() */
+#include <sys/time.h>		/* these two for gettimeofday() */
 #include <unistd.h>
-#include "numbers.h"     /* for new_float() */
-#include "exceptions.h"  /* for panic() */
+#include "numbers.h"		/* for new_float() */
+#include "exceptions.h"		/* for panic() */
 /* utime - andy */
 
 #if EXAMPLE
@@ -82,8 +82,7 @@ stdin_enumerator(task_closure closure, void *data)
     for (ww = &waiters; *ww; ww = &((*ww)->next)) {
 	stdin_waiter *w = *ww;
 	const char *status = (w->the_vm->task_id & 1
-			      ? "stdin-waiting"
-			      : "stdin-weighting");
+			      ? "stdin-waiting" : "stdin-weighting");
 	task_enum_action tea = (*closure) (w->the_vm, status, data);
 
 	if (tea == TEA_KILL) {
@@ -154,7 +153,8 @@ stdin_suspender(vm the_vm, void *data)
 static package
 bf_read_stdin(Var arglist, Byte next, void *vdata, Objid progr)
 {
-    stdin_waiter *w = (stdin_waiter *) mymalloc(sizeof(stdin_waiter), M_TASK);
+    stdin_waiter *w =
+	(stdin_waiter *) mymalloc(sizeof(stdin_waiter), M_TASK);
 
     return make_suspend_pack(stdin_suspender, w);
 }
@@ -196,27 +196,25 @@ bf_log_cache_stats(Var arglist, Byte next, void *vdata, Objid progr)
 static package
 bf_isa(Var arglist, Byte next, void *vdata, Objid progr)
 {
-  Objid what = arglist.v.list[1].v.obj;
-  Objid targ = arglist.v.list[2].v.obj;
-  Var   r;
+    Objid what = arglist.v.list[1].v.obj;
+    Objid targ = arglist.v.list[2].v.obj;
+    Var r;
 
-  free_var(arglist);
+    free_var(arglist);
 
-  r.type = TYPE_INT;
+    r.type = TYPE_INT;
 
-  while (valid(what))
-  {
-    if (what == targ)
-    {
-      r.v.num = 1;
-      return make_var_pack(r);
-    }
+    while (valid(what)) {
+	if (what == targ) {
+	    r.v.num = 1;
+	    return make_var_pack(r);
+	}
 
-    what = db_object_parent(what);
-  }
+	what = db_object_parent(what);
+    }
 
-  r.v.num = 0;
-  return make_var_pack(r);
+    r.v.num = 0;
+    return make_var_pack(r);
 }
 
 // Begin VERYRANDOM code from tiresias
@@ -224,12 +222,18 @@ bf_isa(Var arglist, Byte next, void *vdata, Objid progr)
 static unsigned long regA, regB, regC;
 
 //int VERYRANDOM(unsigned long &regA, unsigned long &regB, unsigned long &regC) {
-int VERYRANDOM() {
-  regA=((((regA>>31)^(regA>>6)^(regA>>4)^(regA>>2)^(regA<<1)^regA) & 0x00000001)<<31) | (regA>>1);
-  regB=((((regB>>30)^(regB>>2)) & 0x00000001)<<30) | (regB>>1);
-  regC=((((regC>>28)^(regC>>1)) & 0x00000001)<<28) | (regC>>1);
-
-  return ((regA ^ regB ^ regC) & 0x00000001);
+int
+VERYRANDOM()
+{
+    regA =
+	((((regA >> 31) ^ (regA >> 6) ^ (regA >> 4) ^ (regA >> 2) ^
+	   (regA << 1) ^ regA) & 0x00000001) << 31) | (regA >> 1);
+    regB =
+	((((regB >> 30) ^ (regB >> 2)) & 0x00000001) << 30) | (regB >> 1);
+    regC =
+	((((regC >> 28) ^ (regC >> 1)) & 0x00000001) << 28) | (regC >> 1);
+
+    return ((regA ^ regB ^ regC) & 0x00000001);
 //  return ((regA & regB) | (!regA & regC)) & 0x00000001;
 }
 
@@ -243,18 +247,23 @@ bf_vrandomseed(Var arglist, Byte next, void *vdata, Objid progr)
 
     if (nargs != 0) {
 	if (nargs != 1 || arglist.v.list[1].v.list[0].v.num != 3) {
-            return make_error_pack(E_INVARG);
-	} else if (arglist.v.list[1].v.list[1].type != TYPE_FLOAT || arglist.v.list[1].v.list[2].type != TYPE_FLOAT || arglist.v.list[1].v.list[3].type != TYPE_FLOAT) {
-            return make_error_pack(E_INVARG);
-        } else {
-            unsigned long newRegA = (unsigned long) *arglist.v.list[1].v.list[1].v.fnum;
-            unsigned long newRegB = (unsigned long) *arglist.v.list[1].v.list[2].v.fnum;
-            unsigned long newRegC = (unsigned long) *arglist.v.list[1].v.list[3].v.fnum;
-
-            regA = newRegA;
-            regB = newRegB;
-            regC = newRegC;
-        }
+	    return make_error_pack(E_INVARG);
+	} else if (arglist.v.list[1].v.list[1].type != TYPE_FLOAT
+		   || arglist.v.list[1].v.list[2].type != TYPE_FLOAT
+		   || arglist.v.list[1].v.list[3].type != TYPE_FLOAT) {
+	    return make_error_pack(E_INVARG);
+	} else {
+	    unsigned long newRegA =
+		(unsigned long) *arglist.v.list[1].v.list[1].v.fnum;
+	    unsigned long newRegB =
+		(unsigned long) *arglist.v.list[1].v.list[2].v.fnum;
+	    unsigned long newRegC =
+		(unsigned long) *arglist.v.list[1].v.list[3].v.fnum;
+
+	    regA = newRegA;
+	    regB = newRegB;
+	    regC = newRegC;
+	}
     }
 
     r = new_list(3);
@@ -282,34 +291,35 @@ bf_vrandom(Var arglist, Byte next, void *vdata, Objid progr)
     free_var(arglist);
 
     if (num <= 0)
-        return make_error_pack(E_INVARG);
+	return make_error_pack(E_INVARG);
     else {
-        Var r;
-        int bits = 0;
-        int result = -1;
-
-        r.type = TYPE_INT;
-        if (nargs == 0)
-            bits = 31;
-        else {
-            double x = pow(num, .5);
-            bits=(int)((double)abs((int)x)==x?x:abs((int)x+1));
-        }
-
-        while (result < 1 || result > num) {
-            int x = 0;
-            result = 1;
-            for (x=0; x<bits; x++) {
-                int rbit, powwow;
-                powwow = (int) pow(2, x);
+	Var r;
+	int bits = 0;
+	int result = -1;
+
+	r.type = TYPE_INT;
+	if (nargs == 0)
+	    bits = 31;
+	else {
+	    double x = pow(num, .5);
+	    bits =
+		(int) ((double) abs((int) x) == x ? x : abs((int) x + 1));
+	}
+
+	while (result < 1 || result > num) {
+	    int x = 0;
+	    result = 1;
+	    for (x = 0; x < bits; x++) {
+		int rbit, powwow;
+		powwow = (int) pow(2, x);
 //              rbit = VERYRANDOM(regA, regB, regC);
-                rbit = VERYRANDOM();
-                result = result + (rbit*powwow);
-            }
-        }
+		rbit = VERYRANDOM();
+		result = result + (rbit * powwow);
+	    }
+	}
 
-        r.v.num = result;
-        return make_var_pack(r);
+	r.v.num = result;
+	return make_var_pack(r);
     }
 }
 
@@ -325,12 +335,13 @@ bf_utime(Var arglist, Byte next, void *vdata, Objid progr)
     free_var(arglist);
 
     if (gettimeofday(&tv, NULL))
-      panic("BF_UTIME: gettimeofday() failed");
+	panic("BF_UTIME: gettimeofday() failed");
 
-    t = tv.tv_sec + (tv.tv_usec / (double)1000000.0);
+    t = tv.tv_sec + (tv.tv_usec / (double) 1000000.0);
 
     return make_var_pack(new_float(t));
 }
+
 // end utime - andy
 
 #ifdef EXPAT_XML
@@ -340,7 +351,7 @@ extern void register_xml(void);
 void
 register_extensions()
 {
-  oklog("          LOADING: extensions ...\n");
+    oklog("          LOADING: extensions ...\n");
 #if EXAMPLE
     register_task_queue(stdin_enumerator);
     register_function("read_stdin", 0, 0, bf_read_stdin);
@@ -358,11 +369,12 @@ register_extensions()
 // begin utime - andy
     register_function("utime", 0, 0, bf_utime);
 // end utime - andy
-  register_files();
-  oklog("          LOADING: extensions ... finished\n");
+    register_files();
+    oklog("          LOADING: extensions ... finished\n");
 }
 
-char rcsid_extensions[] = "$Id: extensions.c,v 1.4 1998-12-14 13:17:52 nop Exp $";
+char rcsid_extensions[] =
+    "$Id: extensions.c,v 1.4 1998-12-14 13:17:52 nop Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/functions.c b/server/functions.c
index bd04a26..cdb2776 100644
--- a/server/functions.c
+++ b/server/functions.c
@@ -41,8 +41,7 @@
 
 typedef void (*registry) ();
 
-static registry bi_function_registries[] =
-{
+static registry bi_function_registries[] = {
     register_disassemble,
     register_extensions,
     register_execute,
@@ -56,7 +55,7 @@ static registry bi_function_registries[] =
     register_tasks,
     register_verbs
 /* bg_name_lookup */
-    ,register_name_lookup
+	, register_name_lookup
 /* !bg_name_lookup */
 };
 
@@ -64,7 +63,7 @@ void
 register_bi_functions()
 {
     int loop, num_registries =
-    sizeof(bi_function_registries) / sizeof(bi_function_registries[0]);
+	sizeof(bi_function_registries) / sizeof(bi_function_registries[0]);
 
     for (loop = 0; loop < num_registries; loop++)
 	(void) (*(bi_function_registries[loop])) ();
@@ -90,12 +89,10 @@ static unsigned top_bf_table = 0;
 
 static unsigned
 register_common(const char *name,
-                int minargs,
-                int maxargs,
-                bf_type func,
-		bf_read_type read,
-                bf_write_type write,
-                va_list args)
+		int minargs,
+		int maxargs,
+		bf_type func,
+		bf_read_type read, bf_write_type write, va_list args)
 {
     int va_index;
     int num_arg_types = maxargs == -1 ? minargs : maxargs;
@@ -108,21 +105,22 @@ register_common(const char *name,
 	errlog("too many functions.  %s cannot be registered.\n", name);
 	return 0;
     }
-    bf_table[top_bf_table].name        = str_dup(name);
+    bf_table[top_bf_table].name = str_dup(name);
     stream_printf(s, "protect_%s", name);
     bf_table[top_bf_table].protect_str = str_dup(reset_stream(s));
     stream_printf(s, "bf_%s", name);
-    bf_table[top_bf_table].verb_str    = str_dup(reset_stream(s));
-    bf_table[top_bf_table].minargs     = minargs;
-    bf_table[top_bf_table].maxargs     = maxargs;
-    bf_table[top_bf_table].func        = func;
-    bf_table[top_bf_table].read        = read;
-    bf_table[top_bf_table].write       = write;
-    bf_table[top_bf_table]._protected  = 0;
-    
+    bf_table[top_bf_table].verb_str = str_dup(reset_stream(s));
+    bf_table[top_bf_table].minargs = minargs;
+    bf_table[top_bf_table].maxargs = maxargs;
+    bf_table[top_bf_table].func = func;
+    bf_table[top_bf_table].read = read;
+    bf_table[top_bf_table].write = write;
+    bf_table[top_bf_table]._protected = 0;
+
     if (num_arg_types > 0)
 	bf_table[top_bf_table].prototype =
-          (var_type *) mymalloc(num_arg_types * sizeof(var_type), M_PROTOTYPE);
+	    (var_type *) mymalloc(num_arg_types * sizeof(var_type),
+				  M_PROTOTYPE);
     else
 	bf_table[top_bf_table].prototype = 0;
 
@@ -135,7 +133,7 @@ register_common(const char *name,
 
 unsigned
 register_function(const char *name, int minargs, int maxargs,
-		  bf_type func,...)
+		  bf_type func, ...)
 {
     va_list args;
     unsigned ans;
@@ -147,9 +145,10 @@ register_function(const char *name, int minargs, int maxargs,
 }
 
 unsigned
-register_function_with_read_write(const char *name, int minargs, int maxargs,
-				  bf_type func, bf_read_type read,
-				  bf_write_type write,...)
+register_function_with_read_write(const char *name, int minargs,
+				  int maxargs, bf_type func,
+				  bf_read_type read, bf_write_type write,
+				  ...)
 {
     va_list args;
     unsigned ans;
@@ -212,7 +211,8 @@ call_bi_func(unsigned n, Var arglist, Byte func_pc,
 	/* if (caller() != SYSTEM_OBJECT && server_flag_option(f->protect_str)) { */
 	if (caller() != SYSTEM_OBJECT && f->_protected) {
 	    /* Try calling #0:bf_FUNCNAME(@ARGS) instead */
-	    enum error e = call_verb2(SYSTEM_OBJECT, f->verb_str, arglist, 0);
+	    enum error e =
+		call_verb2(SYSTEM_OBJECT, f->verb_str, arglist, 0);
 
 	    if (e == E_NONE)
 		return tail_call_pack();
@@ -303,7 +303,8 @@ read_bi_func_data(Byte f_id, void **bi_func_state, Byte * bi_func_pc)
 	    && strcmp(bf_table[f_id].name, "eval") != 0) {
 	    oklog("LOADING: Warning: patching bogus return to `%s()'\n",
 		  bf_table[f_id].name);
-	    oklog("         (See 1.8.0p4 ChangeLog.txt entry for details.)\n");
+	    oklog
+		("         (See 1.8.0p4 ChangeLog.txt entry for details.)\n");
 	    *bi_func_pc = 0;
 	}
     }
@@ -397,7 +398,7 @@ function_description(int i)
 
     entry = bf_table[i];
     v = new_list(4);
-    v.v.list[1].type = (var_type)TYPE_STR;
+    v.v.list[1].type = (var_type) TYPE_STR;
     v.v.list[1].v.str = str_ref(entry.name);
     v.v.list[2].type = TYPE_INT;
     v.v.list[2].v.num = entry.minargs;
@@ -408,7 +409,8 @@ function_description(int i)
     for (j = 0; j < nargs; j++) {
 	int proto = entry.prototype[j];
 	vv.v.list[j + 1].type = TYPE_INT;
-	vv.v.list[j + 1].v.num = proto < 0 ? proto : (proto & TYPE_DB_MASK);
+	vv.v.list[j + 1].v.num =
+	    proto < 0 ? proto : (proto & TYPE_DB_MASK);
     }
 
     return v;
@@ -443,7 +445,8 @@ load_server_protect_flags(void)
     int i;
 
     for (i = 0; i < top_bf_table; i++) {
-	bf_table[i]._protected = server_flag_option(bf_table[i].protect_str);
+	bf_table[i]._protected =
+	    server_flag_option(bf_table[i].protect_str);
     }
     oklog("Loaded protect cache for %d builtins\n", i);
 }
@@ -474,7 +477,8 @@ register_functions(void)
     register_function("load_server_options", 0, 0, bf_load_server_options);
 }
 
-char rcsid_functions[] = "$Id: functions.c,v 1.7 2001-03-12 05:10:54 bjj Exp $";
+char rcsid_functions[] =
+    "$Id: functions.c,v 1.7 2001-03-12 05:10:54 bjj Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/functions.h b/server/functions.h
index 22ea40e..c834f43 100644
--- a/server/functions.h
+++ b/server/functions.h
@@ -77,10 +77,10 @@ typedef void *(*bf_read_type) (void);
 extern const char *name_func_by_num(unsigned);
 extern unsigned number_func_by_name(const char *);
 
-extern unsigned register_function(const char *, int, int, bf_type,...);
+extern unsigned register_function(const char *, int, int, bf_type, ...);
 extern unsigned register_function_with_read_write(const char *, int, int,
 						  bf_type, bf_read_type,
-						  bf_write_type,...);
+						  bf_write_type, ...);
 
 extern package call_bi_func(unsigned, Var, Byte, Objid, void *);
 /* will free or use Var arglist */
diff --git a/server/gnu-malloc.c b/server/gnu-malloc.c
index 2da9b85..5db9ac4 100644
--- a/server/gnu-malloc.c
+++ b/server/gnu-malloc.c
@@ -731,6 +731,7 @@ malloc_stats(size)
 
     return v;
 }
+
 int
 malloc_mem_used()
 {
@@ -882,7 +883,8 @@ sys_sbrk(incr)
 }
 #endif				/* VMS */
 
-char rcsid_gnu_malloc[] = "$Id: gnu-malloc.c,v 1.2 1997-03-03 04:18:44 nop Exp $";
+char rcsid_gnu_malloc[] =
+    "$Id: gnu-malloc.c,v 1.2 1997-03-03 04:18:44 nop Exp $";
 
 /* $Log: not supported by cvs2svn $
  * Revision 1.1.1.1  1997/03/03 03:45:02  nop
diff --git a/server/keywords.c b/server/keywords.c
index b6332c1..93419dd 100644
--- a/server/keywords.c
+++ b/server/keywords.c
@@ -42,8 +42,7 @@
 static int
 hash(register const char *str, register int len)
 {
-    static const unsigned char hash_table[] =
-    {
+    static const unsigned char hash_table[] = {
 	106, 106, 106, 106, 106, 106, 106, 106, 106, 106,
 	106, 106, 106, 106, 106, 106, 106, 106, 106, 106,
 	106, 106, 106, 106, 106, 106, 106, 106, 106, 106,
@@ -86,8 +85,7 @@ const struct keyword *
 in_word_set(register const char *str, register int len)
 {
 
-    static const struct keyword wordlist[] =
-    {
+    static const struct keyword wordlist[] = {
 	{"",},
 	{"",},
 	{"",},
@@ -216,7 +214,8 @@ find_keyword(const char *word)
     return in_word_set(word, strlen(word));
 }
 
-char rcsid_keywords[] = "$Id: keywords.c,v 1.3 1998-12-14 13:17:55 nop Exp $";
+char rcsid_keywords[] =
+    "$Id: keywords.c,v 1.3 1998-12-14 13:17:55 nop Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/list.c b/server/list.c
index fa0c8ca..711cb2c 100644
--- a/server/list.c
+++ b/server/list.c
@@ -46,7 +46,7 @@ new_list(int size)
 	static Var emptylist;
 
 	if (emptylist.v.list == 0) {
-	    emptylist.type = (var_type)TYPE_LIST;
+	    emptylist.type = (var_type) TYPE_LIST;
 	    emptylist.v.list = (Var *) mymalloc(1 * sizeof(Var), M_LIST);
 	    emptylist.v.list[0].type = TYPE_INT;
 	    emptylist.v.list[0].v.num = 0;
@@ -55,7 +55,7 @@ new_list(int size)
 	addref(emptylist.v.list);
 	return emptylist;
     }
-    _new.type = (var_type)TYPE_LIST;
+    _new.type = (var_type) TYPE_LIST;
     _new.v.list = (Var *) mymalloc((size + 1) * sizeof(Var), M_LIST);
     _new.v.list[0].type = TYPE_INT;
     _new.v.list[0].v.num = size;
@@ -113,7 +113,9 @@ doinsert(Var list, Var value, int pos)
     int size = list.v.list[0].v.num + 1;
 
     if (var_refcount(list) == 1 && pos == size) {
-	list.v.list = (Var *) myrealloc(list.v.list, (size + 1) * sizeof(Var), M_LIST);
+	list.v.list =
+	    (Var *) myrealloc(list.v.list, (size + 1) * sizeof(Var),
+			      M_LIST);
 	list.v.list[0].v.num = size;
 	list.v.list[pos] = value;
 	return list;
@@ -283,7 +285,7 @@ print_to_stream(Var v, Stream * s)
 	stream_printf(s, "#%d", v.v.obj);
 	break;
     case TYPE_ERR:
-      stream_add_string(s, error_name((error)v.v.num));
+	stream_add_string(s, error_name((error) v.v.num));
 	break;
     case TYPE_FLOAT:
 	stream_printf(s, "%g", *v.v.fnum);
@@ -355,7 +357,7 @@ strrangeset(Var base, int from, int to, Var value)
     Var ans;
     char *s;
 
-    ans.type = (var_type)TYPE_STR;
+    ans.type = (var_type) TYPE_STR;
     s = (char *) mymalloc(sizeof(char) * (newsize + 1), M_STRING);
 
     for (index = 0; index < lenleft; index++)
@@ -376,7 +378,7 @@ substr(Var str, int lower, int upper)
 {
     Var r;
 
-    r.type = (var_type)TYPE_STR;
+    r.type = (var_type) TYPE_STR;
     if (lower > upper)
 	r.v.str = str_dup("");
     else {
@@ -398,7 +400,7 @@ strget(Var str, Var i)
     Var r;
     char *s;
 
-    r.type = (var_type)TYPE_STR;
+    r.type = (var_type) TYPE_STR;
     s = str_dup(" ");
     s[0] = str.v.str[i.v.num - 1];
     r.v.str = s;
@@ -457,9 +459,11 @@ bf_listappend(Var arglist, Byte next, void *vdata, Objid progr)
 {
     Var r;
     if (arglist.v.list[0].v.num == 2)
-	r = listappend(var_ref(arglist.v.list[1]), var_ref(arglist.v.list[2]));
+	r = listappend(var_ref(arglist.v.list[1]),
+		       var_ref(arglist.v.list[2]));
     else
-	r = listinsert(var_ref(arglist.v.list[1]), var_ref(arglist.v.list[2]),
+	r = listinsert(var_ref(arglist.v.list[1]),
+		       var_ref(arglist.v.list[2]),
 		       arglist.v.list[3].v.num + 1);
     free_var(arglist);
     return make_var_pack(r);
@@ -471,10 +475,12 @@ bf_listinsert(Var arglist, Byte next, void *vdata, Objid progr)
 {
     Var r;
     if (arglist.v.list[0].v.num == 2)
-	r = listinsert(var_ref(arglist.v.list[1]), var_ref(arglist.v.list[2]), 1);
+	r = listinsert(var_ref(arglist.v.list[1]),
+		       var_ref(arglist.v.list[2]), 1);
     else
 	r = listinsert(var_ref(arglist.v.list[1]),
-		    var_ref(arglist.v.list[2]), arglist.v.list[3].v.num);
+		       var_ref(arglist.v.list[2]),
+		       arglist.v.list[3].v.num);
     free_var(arglist);
     return make_var_pack(r);
 }
@@ -488,7 +494,8 @@ bf_listdelete(Var arglist, Byte next, void *vdata, Objid progr)
 	free_var(arglist);
 	return make_error_pack(E_RANGE);
     } else {
-	r = listdelete(var_ref(arglist.v.list[1]), arglist.v.list[2].v.num);
+	r = listdelete(var_ref(arglist.v.list[1]),
+		       arglist.v.list[2].v.num);
     }
     free_var(arglist);
     return make_var_pack(r);
@@ -545,7 +552,7 @@ bf_strsub(Var arglist, Byte next, void *vdata, Objid progr)
 	free_var(arglist);
 	return make_error_pack(E_INVARG);
     } else {
-	r.type = (var_type)TYPE_STR;
+	r.type = (var_type) TYPE_STR;
 	r.v.str = str_dup(strsub(arglist.v.list[1].v.str,
 				 arglist.v.list[2].v.str,
 				 arglist.v.list[3].v.str, case_matters));
@@ -564,9 +571,10 @@ bf_crypt(Var arglist, Byte next, void *vdata, Objid progr)
     char salt[3];
     const char *saltp;
     static char saltstuff[] =
-    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./";
+	"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./";
 
-    if (arglist.v.list[0].v.num == 1 || memo_strlen(arglist.v.list[2].v.str) < 2) {
+    if (arglist.v.list[0].v.num == 1
+	|| memo_strlen(arglist.v.list[2].v.str) < 2) {
 	/* provide a random 2-letter salt, works with old and new crypts */
 	salt[0] = saltstuff[RANDOM() % (int) strlen(saltstuff)];
 	salt[1] = saltstuff[RANDOM() % (int) strlen(saltstuff)];
@@ -577,7 +585,7 @@ bf_crypt(Var arglist, Byte next, void *vdata, Objid progr)
 	 * for all crypt versions */
 	saltp = arglist.v.list[2].v.str;
     }
-    r.type = (var_type)TYPE_STR;
+    r.type = (var_type) TYPE_STR;
     r.v.str = str_dup(crypt(arglist.v.list[1].v.str, saltp));
 #else				/* !HAVE_CRYPT */
     r.type = (var_type) TYPE_STR;
@@ -600,7 +608,8 @@ bf_strcmp(Var arglist, Byte next, void *vdata, Objid progr)
     Var r;
 
     r.type = TYPE_INT;
-    r.v.num = signum(strcmp(arglist.v.list[1].v.str, arglist.v.list[2].v.str));
+    r.v.num =
+	signum(strcmp(arglist.v.list[1].v.str, arglist.v.list[2].v.str));
     free_var(arglist);
     return make_var_pack(r);
 }
@@ -642,7 +651,7 @@ static package
 bf_tostr(Var arglist, Byte next, void *vdata, Objid progr)
 {
     Var r;
-    r.type = (var_type)TYPE_STR;
+    r.type = (var_type) TYPE_STR;
     r.v.str = str_dup(list2str(arglist.v.list));
     free_var(arglist);
     return make_var_pack(r);
@@ -653,7 +662,7 @@ bf_toliteral(Var arglist, Byte next, void *vdata, Objid progr)
 {
     Var r;
 
-    r.type = (var_type)TYPE_STR;
+    r.type = (var_type) TYPE_STR;
     r.v.str = str_dup(value_to_literal(arglist.v.list[1]));
     free_var(arglist);
     return make_var_pack(r);
@@ -751,7 +760,7 @@ do_match(Var arglist, int reverse)
 	    ans = new_list(4);
 	    ans.v.list[1].type = TYPE_INT;
 	    ans.v.list[2].type = TYPE_INT;
-	    ans.v.list[4].type = (var_type)TYPE_STR;
+	    ans.v.list[4].type = (var_type) TYPE_STR;
 	    ans.v.list[1].v.num = regs[0].start;
 	    ans.v.list[2].v.num = regs[0].end;
 	    ans.v.list[3] = new_list(9);
@@ -867,7 +876,7 @@ bf_substitute(Var arglist, Byte next, void *vdata, Objid progr)
     subject_length = memo_strlen(subject);
 
     s = new_stream(template_length);
-    ans.type = (var_type)TYPE_STR;
+    ans.type = (var_type) TYPE_STR;
     while ((c = *(_template++)) != '\0') {
 	switch (c) {
 	case '%':
@@ -948,12 +957,13 @@ bf_binary_hash(Var arglist, Byte next, void *vdata, Objid progr)
 {
     Var r;
     int length;
-    const char *bytes = binary_to_raw_bytes(arglist.v.list[1].v.str, &length);
+    const char *bytes =
+	binary_to_raw_bytes(arglist.v.list[1].v.str, &length);
 
     free_var(arglist);
     if (!bytes)
 	return make_error_pack(E_INVARG);
-    r.type = (var_type)TYPE_STR;
+    r.type = (var_type) TYPE_STR;
     r.v.str = hash_bytes(bytes, length);
     return make_var_pack(r);
 }
@@ -964,7 +974,7 @@ bf_string_hash(Var arglist, Byte next, void *vdata, Objid progr)
     Var r;
     const char *str = arglist.v.list[1].v.str;
 
-    r.type = (var_type)TYPE_STR;
+    r.type = (var_type) TYPE_STR;
     r.v.str = hash_bytes(str, memo_strlen(str));
     free_var(arglist);
     return make_var_pack(r);
@@ -976,7 +986,7 @@ bf_value_hash(Var arglist, Byte next, void *vdata, Objid progr)
     Var r;
     const char *lit = value_to_literal(arglist.v.list[1]);
 
-    r.type = (var_type)TYPE_STR;
+    r.type = (var_type) TYPE_STR;
     r.v.str = hash_bytes(lit, memo_strlen(lit));
     free_var(arglist);
     return make_var_pack(r);
@@ -986,7 +996,8 @@ static package
 bf_decode_binary(Var arglist, Byte next, void *vdata, Objid progr)
 {
     int length;
-    const char *bytes = binary_to_raw_bytes(arglist.v.list[1].v.str, &length);
+    const char *bytes =
+	binary_to_raw_bytes(arglist.v.list[1].v.str, &length);
     int nargs = arglist.v.list[0].v.num;
     int fully = (nargs >= 2 && is_true(arglist.v.list[2]));
     Var r;
@@ -1031,7 +1042,7 @@ bf_decode_binary(Var arglist, Byte next, void *vdata, Objid progr)
 		in_string = 1;
 	    } else {
 		if (in_string) {
-		    r.v.list[count].type = (var_type)TYPE_STR;
+		    r.v.list[count].type = (var_type) TYPE_STR;
 		    r.v.list[count].v.str = str_dup(reset_stream(s));
 		    count++;
 		}
@@ -1043,7 +1054,7 @@ bf_decode_binary(Var arglist, Byte next, void *vdata, Objid progr)
 	}
 
 	if (in_string) {
-	    r.v.list[count].type = (var_type)TYPE_STR;
+	    r.v.list[count].type = (var_type) TYPE_STR;
 	    r.v.list[count].v.str = str_dup(reset_stream(s));
 	}
     }
@@ -1093,7 +1104,7 @@ bf_encode_binary(Var arglist, Byte next, void *vdata, Objid progr)
     length = stream_length(s);
     bytes = reset_stream(s);
     if (ok) {
-	r.type = (var_type)TYPE_STR;
+	r.type = (var_type) TYPE_STR;
 	r.v.str = str_dup(raw_bytes_to_binary(bytes, length));
 	return make_var_pack(r);
     } else
@@ -1113,27 +1124,35 @@ register_list(void)
     /* list */
     register_function("length", 1, 1, bf_length, TYPE_ANY);
     register_function("setadd", 2, 2, bf_setadd, TYPE_LIST, TYPE_ANY);
-    register_function("setremove", 2, 2, bf_setremove, TYPE_LIST, TYPE_ANY);
-    register_function("listappend", 2, 3, bf_listappend,
-		      TYPE_LIST, TYPE_ANY, TYPE_INT);
-    register_function("listinsert", 2, 3, bf_listinsert,
-		      TYPE_LIST, TYPE_ANY, TYPE_INT);
-    register_function("listdelete", 2, 2, bf_listdelete, TYPE_LIST, TYPE_INT);
-    register_function("listset", 3, 3, bf_listset,
-		      TYPE_LIST, TYPE_ANY, TYPE_INT);
+    register_function("setremove", 2, 2, bf_setremove, TYPE_LIST,
+		      TYPE_ANY);
+    register_function("listappend", 2, 3, bf_listappend, TYPE_LIST,
+		      TYPE_ANY, TYPE_INT);
+    register_function("listinsert", 2, 3, bf_listinsert, TYPE_LIST,
+		      TYPE_ANY, TYPE_INT);
+    register_function("listdelete", 2, 2, bf_listdelete, TYPE_LIST,
+		      TYPE_INT);
+    register_function("listset", 3, 3, bf_listset, TYPE_LIST, TYPE_ANY,
+		      TYPE_INT);
     register_function("equal", 2, 2, bf_equal, TYPE_ANY, TYPE_ANY);
-    register_function("is_member", 2, 2, bf_is_member, TYPE_ANY, TYPE_LIST);
+    register_function("is_member", 2, 2, bf_is_member, TYPE_ANY,
+		      TYPE_LIST);
 
     /* string */
     register_function("tostr", 0, -1, bf_tostr);
     register_function("toliteral", 1, 1, bf_toliteral, TYPE_ANY);
     setup_pattern_cache();
-    register_function("match", 2, 3, bf_match, TYPE_STR, TYPE_STR, TYPE_ANY);
-    register_function("rmatch", 2, 3, bf_rmatch, TYPE_STR, TYPE_STR, TYPE_ANY);
-    register_function("substitute", 2, 2, bf_substitute, TYPE_STR, TYPE_LIST);
+    register_function("match", 2, 3, bf_match, TYPE_STR, TYPE_STR,
+		      TYPE_ANY);
+    register_function("rmatch", 2, 3, bf_rmatch, TYPE_STR, TYPE_STR,
+		      TYPE_ANY);
+    register_function("substitute", 2, 2, bf_substitute, TYPE_STR,
+		      TYPE_LIST);
     register_function("crypt", 1, 2, bf_crypt, TYPE_STR, TYPE_STR);
-    register_function("index", 2, 3, bf_index, TYPE_STR, TYPE_STR, TYPE_ANY);
-    register_function("rindex", 2, 3, bf_rindex, TYPE_STR, TYPE_STR, TYPE_ANY);
+    register_function("index", 2, 3, bf_index, TYPE_STR, TYPE_STR,
+		      TYPE_ANY);
+    register_function("rindex", 2, 3, bf_rindex, TYPE_STR, TYPE_STR,
+		      TYPE_ANY);
     register_function("strcmp", 2, 2, bf_strcmp, TYPE_STR, TYPE_STR);
     register_function("strsub", 3, 4, bf_strsub,
 		      TYPE_STR, TYPE_STR, TYPE_STR, TYPE_ANY);
diff --git a/server/log.c b/server/log.c
index f91168c..d95d842 100644
--- a/server/log.c
+++ b/server/log.c
@@ -40,7 +40,8 @@ set_log_file(FILE * f)
 
 int log_pcount = 5000;
 static time_t log_prev = 0;
-int log_report_progress_cktime()
+int
+log_report_progress_cktime()
 {
     time_t now = time(0);
     log_pcount = 5000;
@@ -68,7 +69,7 @@ do_log(const char *fmt, va_list args, const char *prefix)
 }
 
 void
-oklog(const char *fmt,...)
+oklog(const char *fmt, ...)
 {
     va_list args;
 
@@ -78,7 +79,7 @@ oklog(const char *fmt,...)
 }
 
 void
-errlog(const char *fmt,...)
+errlog(const char *fmt, ...)
 {
     va_list args;
 
@@ -125,8 +126,7 @@ add_command_to_history(Objid player, const char *command)
     char *nowstr = ctime(&now);
 
     nowstr[19] = '\0';		/* kill the year and newline at the end */
-    stream_printf(command_history, "%s: #%d: %s\n",
-		  nowstr + 4,	/* skip day of week */
+    stream_printf(command_history, "%s: #%d: %s\n", nowstr + 4,	/* skip day of week */
 		  player, command);
 #endif				/* LOG_COMMANDS */
 }
@@ -156,7 +156,8 @@ bf_server_log(Var arglist, Byte next, void *vdata, Objid progr)
 void
 register_log(void)
 {
-    register_function("server_log", 1, 2, bf_server_log, TYPE_STR, TYPE_ANY);
+    register_function("server_log", 1, 2, bf_server_log, TYPE_STR,
+		      TYPE_ANY);
 }
 
 char rcsid_log[] = "$Id: log.c,v 1.4 2004-05-22 01:25:43 wrog Exp $";
diff --git a/server/log.h b/server/log.h
index 4db1cad..9ad54e0 100644
--- a/server/log.h
+++ b/server/log.h
@@ -22,8 +22,8 @@
 
 extern void set_log_file(FILE *);
 
-extern void oklog(const char *,...);
-extern void errlog(const char *,...);
+extern void oklog(const char *, ...);
+extern void errlog(const char *, ...);
 extern void log_perror(const char *);
 
 extern void reset_command_history(void);
diff --git a/server/match.c b/server/match.c
index 6982642..c9e206f 100644
--- a/server/match.c
+++ b/server/match.c
@@ -51,7 +51,7 @@ struct match_data {
 static int
 match_proc(void *data, Objid oid)
 {
-    struct match_data *d = (match_data *)data;
+    struct match_data *d = (match_data *) data;
     Var *names = aliases(oid);
     int i;
     const char *name;
diff --git a/server/md5.c b/server/md5.c
index c8e5932..8b9f9bf 100644
--- a/server/md5.c
+++ b/server/md5.c
@@ -68,8 +68,7 @@
 #define S43 15
 #define S44 21
 
-static uint8 PADDING[64] =
-{
+static uint8 PADDING[64] = {
     0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
diff --git a/server/my-fcntl.h b/server/my-fcntl.h
index 4cb0164..ff49ab5 100644
--- a/server/my-fcntl.h
+++ b/server/my-fcntl.h
@@ -20,8 +20,8 @@
 #include <fcntl.h>
 
 #if NDECL_FCNTL
-extern int fcntl(int, int,...);
-extern int open(const char *, int,...);
+extern int fcntl(int, int, ...);
+extern int open(const char *, int, ...);
 #endif
 
 #if POSIX_NONBLOCKING_WORKS
diff --git a/server/my-ioctl.h b/server/my-ioctl.h
index a0b9b94..77d0514 100644
--- a/server/my-ioctl.h
+++ b/server/my-ioctl.h
@@ -20,7 +20,7 @@
 #include <sys/ioctl.h>
 
 #if NDECL_IOCTL
-extern int ioctl(int, int,...);
+extern int ioctl(int, int, ...);
 #endif
 
 /* 
diff --git a/server/my-stdio.h b/server/my-stdio.h
index 5173838..5a0e275 100644
--- a/server/my-stdio.h
+++ b/server/my-stdio.h
@@ -30,10 +30,10 @@ extern int fflush(FILE *);
 extern int fileno(FILE *);
 extern size_t fwrite(const void *, size_t, size_t, FILE *);
 extern int fgetc(FILE *);
-extern int fprintf(FILE *, const char *,...);
-extern int fscanf(FILE *, const char *,...);
-extern int sscanf(const char *, const char *,...);
-extern int printf(const char *,...);
+extern int fprintf(FILE *, const char *, ...);
+extern int fscanf(FILE *, const char *, ...);
+extern int sscanf(const char *, const char *, ...);
+extern int printf(const char *, ...);
 extern int ungetc(int, FILE *);
 #endif
 
diff --git a/server/name_lookup.c b/server/name_lookup.c
index 878f1c0..f092494 100644
--- a/server/name_lookup.c
+++ b/server/name_lookup.c
@@ -30,7 +30,7 @@
 #include "my-unistd.h"
 #include "my-inet.h"		/* inet_addr() */
 #include "my-in.h"		/* struct sockaddr_in, INADDR_ANY, htons(),
-				   * htonl(), ntohl(), struct in_addr */
+				 * htonl(), ntohl(), struct in_addr */
 #include <netdb.h>		/* struct hostent, gethostbyaddr() */
 #include "my-socket.h"		/* AF_INET */
 #include "my-wait.h"
@@ -76,9 +76,9 @@ spawn_pipe(void (*child_proc) (int to_parent, int from_parent),
 
 	/* Cast to (void *) to avoid warnings on systems that misdeclare the
 	 * argument.
-         * june 2009: removing cast to satisfy g++. --sw
+	 * june 2009: removing cast to satisfy g++. --sw
 	 */
-	wait( &status );	/* wait for middleman to die */
+	wait(&status);		/* wait for middleman to die */
 	if (status != 0) {
 	    errlog("SPAWNING: Middleman died with status %d!\n", status);
 	    close(pipe_to_child[1]);
@@ -136,7 +136,7 @@ robust_read(int fd, void *buffer, int len)
  *****************************************************************************/
 
 enum Req_Kind {
-  REQ_NAME_FROM_ADDR, REQ_ADDR_FROM_NAME
+    REQ_NAME_FROM_ADDR, REQ_ADDR_FROM_NAME
 };
 
 struct request {
@@ -172,7 +172,8 @@ lookup(int to_intermediary, int from_intermediary)
        expires, we exit (in timeout_proc, above).  The intermediary will
        restart us in that event. */
     for (;;) {
-	if (robust_read(from_intermediary, &req, sizeof(req)) != sizeof(req))
+	if (robust_read(from_intermediary, &req, sizeof(req)) !=
+	    sizeof(req))
 	    _exit(1);
 	if (req.kind == REQ_ADDR_FROM_NAME) {
 	    ensure_buffer(&buffer, &buflen, req.u.length + 1);
@@ -183,8 +184,8 @@ lookup(int to_intermediary, int from_intermediary)
 	    id = set_timer(req.timeout, timeout_proc, 0);
 	    /* This cast is to work around systems like NeXT that declare
 	     * gethostbyname() to take a non-const string pointer.
-             *
-             * disabled june 2009. --sw
+	     *
+	     * disabled june 2009. --sw
 	     */
 	    e = gethostbyname(buffer);
 	    cancel_timer(id);
@@ -194,7 +195,7 @@ lookup(int to_intermediary, int from_intermediary)
 		unsigned32 addr;
 
 		/* This cast is for the same reason as the one above... */
-                // also disabled june 2009. --sw
+		// also disabled june 2009. --sw
 		addr = inet_addr(buffer);
 		write(to_intermediary, &addr, sizeof(addr));
 	    }
@@ -203,8 +204,7 @@ lookup(int to_intermediary, int from_intermediary)
 	    int length;
 	    id = set_timer(req.timeout, timeout_proc, 0);
 	    e = gethostbyaddr((void *) &req.u.address.sin_addr,
-			      sizeof(req.u.address.sin_addr),
-			      AF_INET);
+			      sizeof(req.u.address.sin_addr), AF_INET);
 	    cancel_timer(id);
 	    host_name = e ? e->h_name : "";
 	    length = strlen(host_name);
@@ -255,7 +255,8 @@ intermediary(int to_server, int from_server)
 	    _exit(1);
 	if (req.kind == REQ_ADDR_FROM_NAME) {
 	    ensure_buffer(&buffer, &buflen, req.u.length);
-	    if (robust_read(from_server, buffer, req.u.length) != req.u.length)
+	    if (robust_read(from_server, buffer, req.u.length) !=
+		req.u.length)
 		_exit(1);
 	}
 	if (!lookup_pid)	/* Restart lookup if it's died */
@@ -332,15 +333,17 @@ lookup_name_from_addr(struct sockaddr_in *addr, unsigned timeout)
 	req.timeout = timeout;
 	req.u.address = *addr;
 	if (write(to_intermediary, &req, sizeof(req)) != sizeof(req))
-	    abandon_intermediary("LOOKUP_NAME: Write to intermediary failed");
+	    abandon_intermediary
+		("LOOKUP_NAME: Write to intermediary failed");
 	else if (robust_read(from_intermediary, &len, sizeof(len))
 		 != sizeof(len))
-	    abandon_intermediary("LOOKUP_NAME: Read from intermediary failed");
+	    abandon_intermediary
+		("LOOKUP_NAME: Read from intermediary failed");
 	else if (len != 0) {
 	    ensure_buffer(&buffer, &buflen, len + 1);
 	    if (robust_read(from_intermediary, buffer, len) != len)
 		abandon_intermediary("LOOKUP_NAME: "
-				   "Data-read from intermediary failed");
+				     "Data-read from intermediary failed");
 	    else {
 		buffer[len] = '\0';
 		return buffer;
@@ -371,7 +374,7 @@ lookup_addr_from_name(const char *name, unsigned timeout)
 
     if (dead_intermediary) {
 	/* Numeric addresses should always work... */
-        // june 2009: removed void pointer cast. --sw
+	// june 2009: removed void pointer cast. --sw
 	addr = inet_addr(name);
     } else {
 	req.kind = REQ_ADDR_FROM_NAME;
@@ -379,10 +382,12 @@ lookup_addr_from_name(const char *name, unsigned timeout)
 	req.u.length = strlen(name);
 	if (write(to_intermediary, &req, sizeof(req)) != sizeof(req)
 	    || write(to_intermediary, name, req.u.length) != req.u.length)
-	    abandon_intermediary("LOOKUP_ADDR: Write to intermediary failed");
+	    abandon_intermediary
+		("LOOKUP_ADDR: Write to intermediary failed");
 	else if (robust_read(from_intermediary, &addr, sizeof(addr))
 		 != sizeof(addr))
-	    abandon_intermediary("LOOKUP_ADDR: Read from intermediary failed");
+	    abandon_intermediary
+		("LOOKUP_ADDR: Read from intermediary failed");
     }
 
     return addr == 0xffffffff ? 0 : addr;
@@ -390,7 +395,8 @@ lookup_addr_from_name(const char *name, unsigned timeout)
 
 #endif				/* NETWORK_PROTOCOL == NP_TCP */
 
-char rcsid_name_lookup[] = "$Id: name_lookup.c,v 1.3 1998-12-14 13:18:25 nop Exp $";
+char rcsid_name_lookup[] =
+    "$Id: name_lookup.c,v 1.3 1998-12-14 13:18:25 nop Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/net_bsd_lcl.c b/server/net_bsd_lcl.c
index 6275056..6a8d486 100644
--- a/server/net_bsd_lcl.c
+++ b/server/net_bsd_lcl.c
@@ -20,8 +20,8 @@
 
 #include <errno.h>		/* EMFILE */
 #include "my-socket.h"		/* socket(), AF_UNIX, SOCK_STREAM,
-				   * bind(), struct sockaddr, accept(),
-				   * shutdown(), connect() */
+				 * bind(), struct sockaddr, accept(),
+				 * shutdown(), connect() */
 #include "my-stdio.h"		/* remove() */
 #include "my-string.h"		/* strcpy() */
 #include <sys/un.h>		/* struct sockaddr_un */
@@ -169,7 +169,8 @@ proto_close_listener(int fd)
     errlog("Can't find fd in PROTO_CLOSE_LISTENER!\n");
 }
 
-char rcsid_net_bsd_lcl[] = "$Id: net_bsd_lcl.c,v 1.2 1997-03-03 04:19:02 nop Exp $";
+char rcsid_net_bsd_lcl[] =
+    "$Id: net_bsd_lcl.c,v 1.2 1997-03-03 04:19:02 nop Exp $";
 
 /* $Log: not supported by cvs2svn $
  * Revision 1.1.1.1  1997/03/03 03:45:02  nop
diff --git a/server/net_bsd_tcp.c b/server/net_bsd_tcp.c
index d53cbb8..5242684 100644
--- a/server/net_bsd_tcp.c
+++ b/server/net_bsd_tcp.c
@@ -19,13 +19,13 @@
 
 #include "my-inet.h"		/* inet_addr() */
 #include <errno.h>		/* EMFILE, EADDRNOTAVAIL, ECONNREFUSED,
-				   * ENETUNREACH, ETIMEOUT */
+				 * ENETUNREACH, ETIMEOUT */
 #include "my-in.h"		/* struct sockaddr_in, INADDR_ANY, htons(),
-				   * htonl(), ntohl(), struct in_addr */
+				 * htonl(), ntohl(), struct in_addr */
 #include "my-socket.h"		/* socket(), AF_INET, SOCK_STREAM,
-				   * setsockopt(), SOL_SOCKET, SO_REUSEADDR,
-				   * bind(), struct sockaddr, accept(),
-				   * connect() */
+				 * setsockopt(), SOL_SOCKET, SO_REUSEADDR,
+				 * bind(), struct sockaddr, accept(),
+				 * connect() */
 #include "my-stdlib.h"		/* strtoul() */
 #include "my-string.h"		/* memcpy() */
 #include "my-unistd.h"		/* close() */
@@ -81,7 +81,7 @@ proto_make_listener(Var desc, int *fd, Var * canon, const char **name)
 	st = new_stream(20);
 
     if (desc.type != TYPE_INT && desc.type != TYPE_LIST)
-        return E_TYPE;
+	return E_TYPE;
 
     port = desc.v.num;
     s = socket(AF_INET, SOCK_STREAM, 0);
@@ -98,22 +98,22 @@ proto_make_listener(Var desc, int *fd, Var * canon, const char **name)
     memset((char *) &address, 0, sizeof(address));
     address.sin_family = AF_INET;
     if (desc.type == TYPE_INT) {
-      port = desc.v.num;
-      address.sin_addr.s_addr = bind_local_ip;
+	port = desc.v.num;
+	address.sin_addr.s_addr = bind_local_ip;
     } else {
-      unsigned long inaddr;
-      inaddr = inet_addr(desc.v.list[1].v.str);
-      if (inaddr != INADDR_NONE) {
-        memcpy(&address.sin_addr, &inaddr, sizeof(inaddr));
-      } else {
-        struct hostent *hp;
-        hp=gethostbyname(desc.v.list[1].v.str);
-        if (hp == NULL)
-          return E_INVARG;
-
-        memcpy(&address.sin_addr,hp->h_addr,hp->h_length);
-      }
-      port = desc.v.list[2].v.num;
+	unsigned long inaddr;
+	inaddr = inet_addr(desc.v.list[1].v.str);
+	if (inaddr != INADDR_NONE) {
+	    memcpy(&address.sin_addr, &inaddr, sizeof(inaddr));
+	} else {
+	    struct hostent *hp;
+	    hp = gethostbyname(desc.v.list[1].v.str);
+	    if (hp == NULL)
+		return E_INVARG;
+
+	    memcpy(&address.sin_addr, hp->h_addr, hp->h_length);
+	}
+	port = desc.v.list[2].v.num;
     }
     address.sin_port = htons(port);
     if (bind(s, (struct sockaddr *) &address, sizeof(address)) < 0) {
@@ -139,9 +139,10 @@ proto_make_listener(Var desc, int *fd, Var * canon, const char **name)
 	*canon = var_ref(desc);
 
     if (desc.type == TYPE_INT) {
-      stream_printf(st, "port %d", canon->v.num);
+	stream_printf(st, "port %d", canon->v.num);
     } else {
-      stream_printf(st, "%s port %d", canon->v.list[1].v.str, canon->v.list[2].v.num);
+	stream_printf(st, "%s port %d", canon->v.list[1].v.str,
+		      canon->v.list[2].v.num);
     }
     *name = reset_stream(st);
 
@@ -168,7 +169,7 @@ proto_accept_connection(int listener_fd, int *read_fd, int *write_fd,
     if (!s)
 	s = new_stream(100);
 
-    fd = accept(listener_fd, (struct sockaddr *) &address,  &addr_length);
+    fd = accept(listener_fd, (struct sockaddr *) &address, &addr_length);
     if (fd < 0) {
 	if (errno == EMFILE)
 	    return PA_FULL;
@@ -180,7 +181,7 @@ proto_accept_connection(int listener_fd, int *read_fd, int *write_fd,
     *read_fd = *write_fd = fd;
     stream_printf(s, "%s, port %d",
 /* bg_name_lookup */
-                  inet_ntoa(address. sin_addr),
+		  inet_ntoa(address.sin_addr),
 /* !bg_name_lookup */
 		  (int) ntohs(address.sin_port));
     *name = reset_stream(s);
@@ -258,7 +259,7 @@ proto_open_connection(Var arglist, int *read_fd, int *write_fd,
 	    log_perror("Making socket in proto_open_connection");
 	return E_QUOTA;
     }
-    
+
     if (bind_local_ip != INADDR_ANY) {
 	static struct sockaddr_in local_addr;
 
@@ -267,7 +268,8 @@ proto_open_connection(Var arglist, int *read_fd, int *write_fd,
 	local_addr.sin_port = 0;
 	/* In theory, if the original listen() succeeded,
 	 * then this should too, but who knows, really? */
-	if (bind(s, (struct sockaddr *) &local_addr, sizeof(local_addr)) < 0) {
+	if (bind(s, (struct sockaddr *) &local_addr, sizeof(local_addr)) <
+	    0) {
 	    enum error e = E_QUOTA;
 
 	    log_perror("Binding local address in proto_open_connection");
@@ -276,63 +278,66 @@ proto_open_connection(Var arglist, int *read_fd, int *write_fd,
 	    close(s);
 	    return e;
 	}
-    }	 
+    }
 
     {
-        ES_CtxBlock         ES_ctx;
-        volatile ES_Value   ES_es = ES_Initialize;
-
-        ES_ctx.nx = 0;
-        ES_ctx._finally = 0;
-        ES_ctx.link = ES_exceptionStack;
-        ES_exceptionStack = &ES_ctx;
-
-        if (setjmp(ES_ctx.jmp) != 0)
-            ES_es = ES_Exception;
-
-        while (1) {
-            if (ES_es == ES_EvalBody) {
-                            /* TRY body goes here */
-                            {
-                                id = set_timer(server_int_option("outbound_connect_timeout", 5),
-                                               timeout_proc, 0);
-                                result = connect(s, (struct sockaddr *) &addr, sizeof(addr));
-                                cancel_timer(id);
-                            }
-                /* TRY body or handler goes here */
-                if (ES_es == ES_EvalBody)
-                    ES_exceptionStack = ES_ctx.link;
-                break;
-            }
-            if (ES_es == ES_Initialize) {
-                if (ES_ctx.nx >= ES_MaxExceptionsPerScope)
-                    panic("Too many EXCEPT clauses!");
-                ES_ctx.array[ES_ctx.nx++] = &timeout_exception;
-            } else if (ES_ctx.id == &timeout_exception  ||  &timeout_exception == &ANY) {
-                int exception_value = ES_ctx.value;
-
-                ES_exceptionStack = ES_ctx.link;
-                exception_value = exception_value;
-                    /* avoid warnings */
-                            /* handler goes here */
-
-                            {
-                                result = -1;
-                                errno = ETIMEDOUT;
-                                reenable_timers();
-                            }
-                break;
-            }
-            ES_es = ES_EvalBody;
-        }
+	ES_CtxBlock ES_ctx;
+	volatile ES_Value ES_es = ES_Initialize;
+
+	ES_ctx.nx = 0;
+	ES_ctx._finally = 0;
+	ES_ctx.link = ES_exceptionStack;
+	ES_exceptionStack = &ES_ctx;
+
+	if (setjmp(ES_ctx.jmp) != 0)
+	    ES_es = ES_Exception;
+
+	while (1) {
+	    if (ES_es == ES_EvalBody) {
+		/* TRY body goes here */
+		{
+		    id = set_timer(server_int_option
+				   ("outbound_connect_timeout", 5),
+				   timeout_proc, 0);
+		    result =
+			connect(s, (struct sockaddr *) &addr,
+				sizeof(addr));
+		    cancel_timer(id);
+		}
+		/* TRY body or handler goes here */
+		if (ES_es == ES_EvalBody)
+		    ES_exceptionStack = ES_ctx.link;
+		break;
+	    }
+	    if (ES_es == ES_Initialize) {
+		if (ES_ctx.nx >= ES_MaxExceptionsPerScope)
+		    panic("Too many EXCEPT clauses!");
+		ES_ctx.array[ES_ctx.nx++] = &timeout_exception;
+	    } else if (ES_ctx.id == &timeout_exception
+		       || &timeout_exception == &ANY) {
+		int exception_value = ES_ctx.value;
+
+		ES_exceptionStack = ES_ctx.link;
+		exception_value = exception_value;
+		/* avoid warnings */
+		/* handler goes here */
+
+		{
+		    result = -1;
+		    errno = ETIMEDOUT;
+		    reenable_timers();
+		}
+		break;
+	    }
+	    ES_es = ES_EvalBody;
+	}
     }
 
     if (result < 0) {
 	close(s);
 	if (errno == EADDRNOTAVAIL ||
 	    errno == ECONNREFUSED ||
-	    errno == ENETUNREACH ||
-	    errno == ETIMEDOUT)
+	    errno == ENETUNREACH || errno == ETIMEDOUT)
 	    return E_INVARG;
 	log_perror("Connecting in proto_open_connection");
 	return E_QUOTA;
@@ -355,7 +360,8 @@ proto_open_connection(Var arglist, int *read_fd, int *write_fd,
 }
 #endif				/* OUTBOUND_NETWORK */
 
-char rcsid_net_bsd_tcp[] = "$Id: net_bsd_tcp.c,v 1.5 2007-11-12 11:00:18 wrog Exp $";
+char rcsid_net_bsd_tcp[] =
+    "$Id: net_bsd_tcp.c,v 1.5 2007-11-12 11:00:18 wrog Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/net_mp_fake.c b/server/net_mp_fake.c
index 23e3417..0f43123 100644
--- a/server/net_mp_fake.c
+++ b/server/net_mp_fake.c
@@ -26,7 +26,7 @@
 #include "storage.h"
 
 #if (NETWORK_PROTOCOL != NP_LOCAL) || (NETWORK_STYLE != NS_SYSV)
- #error Configuration Error: this code can only be used with the FIFO protocol
+#error Configuration Error: this code can only be used with the FIFO protocol
 #endif
 
 typedef enum {
@@ -80,7 +80,8 @@ add_common(int fd, Direction dir)
     }
     if (num_ports == max_ports) {	/* Grow ports array */
 	int new_max = max_ports + 10;
-	Port *new_ports = (Port *) mymalloc(new_max * sizeof(Port), M_NETWORK);
+	Port *new_ports =
+	    (Port *) mymalloc(new_max * sizeof(Port), M_NETWORK);
 	int i;
 
 	for (i = 0; i < max_ports; i++)
@@ -158,7 +159,8 @@ mplex_is_writable(int fd)
     return (fd < rw_size) ? writable[fd] : 0;
 }
 
-char rcsid_net_mp_fake[] = "$Id: net_mp_fake.c,v 1.2 1997-03-03 04:19:03 nop Exp $";
+char rcsid_net_mp_fake[] =
+    "$Id: net_mp_fake.c,v 1.2 1997-03-03 04:19:03 nop Exp $";
 
 /* $Log: not supported by cvs2svn $
  * Revision 1.1.1.1  1997/03/03 03:45:02  nop
diff --git a/server/net_mp_poll.c b/server/net_mp_poll.c
index 455a3d9..933fc02 100644
--- a/server/net_mp_poll.c
+++ b/server/net_mp_poll.c
@@ -47,7 +47,8 @@ add_common(int fd, unsigned dir)
 {
     if (fd >= num_ports) {	/* Grow ports array */
 	int new_num = (fd + 9) / 10 * 10 + 1;
-	Port *new_ports = (Port *) mymalloc(new_num * sizeof(Port), M_NETWORK);
+	Port *new_ports =
+	    (Port *) mymalloc(new_num * sizeof(Port), M_NETWORK);
 	int i;
 
 	for (i = 0; i < num_ports; i++)
@@ -102,7 +103,8 @@ mplex_is_writable(int fd)
     return fd <= max_fd && (ports[fd].revents & POLLOUT) != 0;
 }
 
-char rcsid_net_mp_poll[] = "$Id: net_mp_poll.c,v 1.2 1997-03-03 04:19:04 nop Exp $";
+char rcsid_net_mp_poll[] =
+    "$Id: net_mp_poll.c,v 1.2 1997-03-03 04:19:04 nop Exp $";
 
 /* $Log: not supported by cvs2svn $
  * Revision 1.1.1.1  1997/03/03 03:45:02  nop
diff --git a/server/net_mp_selct.c b/server/net_mp_selct.c
index 30e5813..d151c03 100644
--- a/server/net_mp_selct.c
+++ b/server/net_mp_selct.c
@@ -55,14 +55,15 @@ mplex_add_writer(int fd)
 int
 mplex_wait(struct timeval *timeout)
 {
-    struct timeval tv;  /* Make a copy since select() might write to it */
+    struct timeval tv;		/* Make a copy since select() might write to it */
     int n;
 
     if (timeout) {
 	tv = *timeout;
     }
 
-    n = select(max_descriptor + 1, (fd_set *) &input, (fd_set *) &output, 0, &tv);
+    n = select(max_descriptor + 1, (fd_set *) & input, (fd_set *) & output,
+	       0, &tv);
 
     if (n < 0) {
 	if (errno != EINTR)
@@ -84,7 +85,8 @@ mplex_is_writable(int fd)
     return FD_ISSET(fd, &output);
 }
 
-char rcsid_net_mp_selct[] = "$Id: net_mp_selct.c,v 1.3 1998-12-14 13:18:28 nop Exp $";
+char rcsid_net_mp_selct[] =
+    "$Id: net_mp_selct.c,v 1.3 1998-12-14 13:18:28 nop Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/net_mplex.c b/server/net_mplex.c
index 1dfe22f..d283a39 100644
--- a/server/net_mplex.c
+++ b/server/net_mplex.c
@@ -29,7 +29,8 @@
 #    include "net_mp_fake.c"
 #  endif
 
-char rcsid_net_mplex[] = "$Id: net_mplex.c,v 1.2 1998-12-14 13:18:29 nop Exp $";
+char rcsid_net_mplex[] =
+    "$Id: net_mplex.c,v 1.2 1998-12-14 13:18:29 nop Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/net_multi.c b/server/net_multi.c
index f1ed9f2..3460985 100644
--- a/server/net_multi.c
+++ b/server/net_multi.c
@@ -121,7 +121,8 @@ network_register_fd(int fd, network_fd_callback readable,
 
     if (!reg_fds) {
 	max_reg_fds = 5;
-	reg_fds = (fd_reg *) mymalloc(max_reg_fds * sizeof(fd_reg), M_NETWORK);
+	reg_fds =
+	    (fd_reg *) mymalloc(max_reg_fds * sizeof(fd_reg), M_NETWORK);
 	for (i = 0; i < max_reg_fds; i++)
 	    reg_fds[i].fd = -1;
     }
@@ -131,7 +132,8 @@ network_register_fd(int fd, network_fd_callback readable,
 	    break;
     if (i >= max_reg_fds) {	/* No free slots */
 	int new_max = 2 * max_reg_fds;
-	fd_reg *_new = (fd_reg *) mymalloc(new_max * sizeof(fd_reg), M_NETWORK);
+	fd_reg *_new =
+	    (fd_reg *) mymalloc(new_max * sizeof(fd_reg), M_NETWORK);
 
 	for (i = 0; i < new_max; i++)
 	    if (i < max_reg_fds)
@@ -301,8 +303,8 @@ pull_input(nhandle * h)
 }
 
 static nhandle *
-new_nhandle(int rfd, int wfd, const char *local_name, const char *remote_name,
-	    int outbound)
+new_nhandle(int rfd, int wfd, const char *local_name,
+	    const char *remote_name, int outbound)
 {
     nhandle *h;
     static Stream *s = 0;
@@ -341,13 +343,14 @@ new_nhandle(int rfd, int wfd, const char *local_name, const char *remote_name,
 
 #ifdef NETWORK_IDENT
     if (server_int_option("ident_lookup", 1)) {
-      h->user_name = ident_id(rfd, server_int_option("ident_lookup_timeout", 5));
+	h->user_name =
+	    ident_id(rfd, server_int_option("ident_lookup_timeout", 5));
     }
 #endif
 
     h->user_client = 0;
     if (!h->user_name || h->user_name[0] == '[') {
-      h->user_name = str_dup("unknown");
+	h->user_name = str_dup("unknown");
     }
 
     stream_printf(s, "%s %s %s",
@@ -435,7 +438,8 @@ accept_new_connection(nlistener * l)
     case PA_FULL:
 	for (i = 0; i < proto.pocket_size; i++)
 	    close(pocket_descriptors[i]);
-	if (proto_accept_connection(l->fd, &rfd, &wfd, &host_name) != PA_OKAY)
+	if (proto_accept_connection(l->fd, &rfd, &wfd, &host_name) !=
+	    PA_OKAY)
 	    errlog("Can't accept connection even by emptying pockets!\n");
 	else {
 	    nh.ptr = h = new_nhandle(rfd, wfd, l->name, host_name, 0);
@@ -455,13 +459,12 @@ static int
 enqueue_output(network_handle nh, const char *line, int line_length,
 	       int add_eol, int flush_ok)
 {
-    nhandle *h = (nhandle *)nh.ptr;
+    nhandle *h = (nhandle *) nh.ptr;
     int length = line_length + (add_eol ? eol_length : 0);
     char *buffer;
     text_block *block;
 
-    if (h->output_length != 0
-	&& h->output_length + length > MAX_QUEUED_OUTPUT) {	/* must flush... */
+    if (h->output_length != 0 && h->output_length + length > MAX_QUEUED_OUTPUT) {	/* must flush... */
 	int to_flush;
 	text_block *b;
 
@@ -528,7 +531,8 @@ network_initialize(int argc, char **argv, Var * desc)
 
 enum error
 network_make_listener(server_listener sl, Var desc,
-		   network_listener * nl, Var * canon, const char **name)
+		      network_listener * nl, Var * canon,
+		      const char **name)
 {
     int fd;
     enum error e = proto_make_listener(desc, &fd, canon, name);
@@ -551,7 +555,7 @@ network_make_listener(server_listener sl, Var desc,
 int
 network_listen(network_listener nl)
 {
-    nlistener *l = (nlistener *)nl.ptr;
+    nlistener *l = (nlistener *) nl.ptr;
 
     return proto_listen(l->fd);
 }
@@ -572,7 +576,7 @@ network_send_bytes(network_handle nh, const char *buffer, int buflen,
 int
 network_buffered_output_length(network_handle nh)
 {
-    nhandle *h = (nhandle *)nh.ptr;
+    nhandle *h = (nhandle *) nh.ptr;
 
     return h->output_length;
 }
@@ -580,7 +584,7 @@ network_buffered_output_length(network_handle nh)
 void
 network_suspend_input(network_handle nh)
 {
-    nhandle *h = (nhandle *)nh.ptr;
+    nhandle *h = (nhandle *) nh.ptr;
 
     h->input_suspended = 1;
 }
@@ -588,7 +592,7 @@ network_suspend_input(network_handle nh)
 void
 network_resume_input(network_handle nh)
 {
-    nhandle *h = (nhandle *)nh.ptr;
+    nhandle *h = (nhandle *) nh.ptr;
 
     h->input_suspended = 0;
 }
@@ -648,7 +652,7 @@ network_connection_user(network_handle nh)
 void
 network_set_connection_binary(network_handle nh, int do_binary)
 {
-    nhandle *h = (nhandle *)nh.ptr;
+    nhandle *h = (nhandle *) nh.ptr;
 
     h->binary = do_binary;
 }
@@ -666,7 +670,7 @@ network_set_connection_binary(network_handle nh, int do_binary)
 void
 network_set_client_echo(network_handle nh, int is_on)
 {
-    nhandle *h = (nhandle *)nh.ptr;
+    nhandle *h = (nhandle *) nh.ptr;
 
     /* These values taken from RFC 854 and RFC 857. */
 #define TN_IAC	255		/* Interpret As Command */
@@ -674,8 +678,7 @@ network_set_client_echo(network_handle nh, int is_on)
 #define TN_WONT	252
 #define TN_ECHO	1
 
-    static char telnet_cmd[4] =
-	{TN_IAC, 0, TN_ECHO, 0};
+    static char telnet_cmd[4] = { TN_IAC, 0, TN_ECHO, 0 };
 
     h->client_echo = is_on;
     if (is_on)
@@ -685,11 +688,11 @@ network_set_client_echo(network_handle nh, int is_on)
     enqueue_output(nh, telnet_cmd, 3, 0, 1);
 }
 
-#else /* NETWORK_PROTOCOL == NP_SINGLE */
+#else				/* NETWORK_PROTOCOL == NP_SINGLE */
 
 #  error "NP_SINGLE ???"
 
-#endif /* NETWORK_PROTOCOL */
+#endif				/* NETWORK_PROTOCOL */
 
 
 #ifdef OUTBOUND_NETWORK
@@ -701,10 +704,10 @@ network_open_connection(Var arglist, server_listener sl)
     const char *local_name, *remote_name;
     enum error e;
 
-    e = proto_open_connection(arglist, &rfd, &wfd, &local_name, &remote_name);
+    e = proto_open_connection(arglist, &rfd, &wfd, &local_name,
+			      &remote_name);
     if (e == E_NONE)
-	make_new_connection(sl, rfd, wfd,
-			    local_name, remote_name, 1);
+	make_new_connection(sl, rfd, wfd, local_name, remote_name, 1);
 
     return e;
 }
@@ -713,13 +716,13 @@ network_open_connection(Var arglist, server_listener sl)
 void
 network_close(network_handle h)
 {
-    close_nhandle((nhandle *)h.ptr);
+    close_nhandle((nhandle *) h.ptr);
 }
 
 void
 network_close_listener(network_listener nl)
 {
-    close_nlistener((nlistener *)nl.ptr);
+    close_nlistener((nlistener *) nl.ptr);
 }
 
 void
@@ -731,7 +734,8 @@ network_shutdown(void)
 	close_nlistener(all_nlisteners);
 }
 
-char rcsid_net_multi[] = "$Id: net_multi.c,v 1.6 2006-12-06 23:57:51 wrog Exp $";
+char rcsid_net_multi[] =
+    "$Id: net_multi.c,v 1.6 2006-12-06 23:57:51 wrog Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/net_proto.c b/server/net_proto.c
index 7a5003b..30f06f1 100644
--- a/server/net_proto.c
+++ b/server/net_proto.c
@@ -35,7 +35,8 @@
 #    endif
 #  endif
 
-char rcsid_net_proto[] = "$Id: net_proto.c,v 1.2 1998-12-14 13:18:33 nop Exp $";
+char rcsid_net_proto[] =
+    "$Id: net_proto.c,v 1.2 1998-12-14 13:18:33 nop Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/net_proto.h b/server/net_proto.h
index 30ce8ef..d6da387 100644
--- a/server/net_proto.h
+++ b/server/net_proto.h
@@ -103,9 +103,9 @@ enum proto_accept_error {
 };
 
 extern enum proto_accept_error
- proto_accept_connection(int listener_fd,
-			 int *read_fd, int *write_fd,
-			 const char **name);
+
+proto_accept_connection(int listener_fd,
+			int *read_fd, int *write_fd, const char **name);
 				/* Accept a new connection on LISTENER_FD,
 				 * returning PA_OKAY if successful, PA_FULL if
 				 * unsuccessful only because there aren't
diff --git a/server/net_single.c b/server/net_single.c
index 7c73542..e832f0e 100644
--- a/server/net_single.c
+++ b/server/net_single.c
@@ -194,12 +194,12 @@ network_process_io(int timeout)
 		   && (count = read(0, buffer, sizeof(buffer))) > 0) {
 		got_some = 1;
 		if (binary) {
-		    stream_add_string(s, raw_bytes_to_binary(buffer, count));
+		    stream_add_string(s,
+				      raw_bytes_to_binary(buffer, count));
 		    server_receive_line(sh, reset_stream(s));
 		} else
 		    for (ptr = buffer, end = buffer + count;
-			 ptr < end;
-			 ptr++) {
+			 ptr < end; ptr++) {
 			unsigned char c = *ptr;
 
 			if (isgraph(c) || c == ' ' || c == '\t')
@@ -225,7 +225,8 @@ network_process_io(int timeout)
     return got_some;
 }
 
-char rcsid_net_single[] = "$Id: net_single.c,v 1.4 2006-12-06 23:57:51 wrog Exp $";
+char rcsid_net_single[] =
+    "$Id: net_single.c,v 1.4 2006-12-06 23:57:51 wrog Exp $";
 
 /*
  * $Log: not supported by cvs2svn $
diff --git a/server/net_sysv_lcl.c b/server/net_sysv_lcl.c
index 9895909..beab696 100644
--- a/server/net_sysv_lcl.c
+++ b/server/net_sysv_lcl.c
@@ -264,7 +264,8 @@ proto_accept_connection(int listener_fd, int *read_fd, int *write_fd,
 		    l->ptr = 0;
 		    got_one = 1;
 		} else if (c == ' ' || l->ptr == 1000) {
-		    errlog("Overlong or malformed line on listening FIFO\n");
+		    errlog
+			("Overlong or malformed line on listening FIFO\n");
 		    l->state = RejectLine;
 		} else
 		    l->s2c[l->ptr++] = c;
@@ -306,8 +307,7 @@ proto_accept_connection(int listener_fd, int *read_fd, int *write_fd,
 	return PA_OTHER;
     }
     if (st1.st_mode & S_IFMT != S_IFIFO
-	|| st2.st_mode & S_IFMT != S_IFIFO
-	|| st1.st_uid != st2.st_uid) {
+	|| st2.st_mode & S_IFMT != S_IFIFO || st1.st_uid != st2.st_uid) {
 	close(*read_fd);
 	close(*write_fd);
 	errlog("Bogus FIFO names: \"%s\" and \"%s\"\n", l->c2s, l->s2c);
@@ -354,7 +354,8 @@ proto_close_listener(int fd)
     errlog("Can't find fd in PROTO_CLOSE_LISTENER!\n");
 }
 
-char rcsid_net_sysv_lcl[] = "$Id: net_sysv_lcl.c,v 1.2 1997-03-03 04:19:08 nop Exp $";
+char rcsid_net_sysv_lcl[] =
+    "$Id: net_sysv_lcl.c,v 1.2 1997-03-03 04:19:08 nop Exp $";
 
 /* $Log: not supported by cvs2svn $
  * Revision 1.1.1.1  1997/03/03 03:45:02  nop
diff --git a/server/net_sysv_tcp.c b/server/net_sysv_tcp.c
index 3036fa6..8813db1 100644
--- a/server/net_sysv_tcp.c
+++ b/server/net_sysv_tcp.c
@@ -35,7 +35,7 @@
 #include <errno.h>		/* EMFILE */
 #include "my-fcntl.h"		/* O_RDWR */
 #include "my-in.h"		/* struct sockaddr_in, INADDR_ANY, htonl(),
-				   * htons(), ntohl(), struct in_addr */
+				 * htons(), ntohl(), struct in_addr */
 #include "my-ioctl.h"		/* ioctl() */
 #include "my-socket.h"		/* AF_INET */
 #include "my-stdlib.h"		/* strtoul() */
@@ -301,8 +301,7 @@ proto_open_connection(Var arglist, int *read_fd, int *write_fd,
 
     if (bind_local_ip == INADDR_ANY) {
 	p_requested = 0;
-    }
-    else {
+    } else {
 	req_addr.sin_family = AF_INET;
 	req_addr.sin_addr.s_addr = bind_local_ip;
 	req_addr.sin_port = 0;
@@ -361,7 +360,8 @@ proto_open_connection(Var arglist, int *read_fd, int *write_fd,
 }
 #endif				/* OUTBOUND_NETWORK */
 
-char rcsid_net_sysv_tcp[] = "$Id: net_sysv_tcp.c,v 1.3 2004-05-22 01:25:44 wrog Exp $";
+char rcsid_net_sysv_tcp[] =
+    "$Id: net_sysv_tcp.c,v 1.3 2004-05-22 01:25:44 wrog Exp $";
 
 /*
  * $Log: not supported by cvs2svn $
diff --git a/server/net_tcp.c b/server/net_tcp.c
index 6b8e9ca..731bb92 100644
--- a/server/net_tcp.c
+++ b/server/net_tcp.c
@@ -25,54 +25,52 @@ tcp_arguments(int argc, char **argv, int *pport)
 {
     char *p = 0;
 
-    for ( ; argc > 0; argc--, argv++) {
-	if (argc > 0
-	    && (argv[0][0] == '-' || argv[0][0] == '+')
-	    && argv[0][1] == 'O'
-	    && argv[0][2] == 0
-	    ) {
+    for (; argc > 0; argc--, argv++) {
+	if (argc > 0 && (argv[0][0] == '-' || argv[0][0] == '+')
+	    && argv[0][1] == 'O' && argv[0][2] == 0) {
 #ifdef OUTBOUND_NETWORK
 	    outbound_network_enabled = (argv[0][0] == '+');
 #else
 	    if (argv[0][0] == '+') {
 		fprintf(stderr, "Outbound network not supported.\n");
-		oklog("CMDLINE: *** Ignoring %s (outbound network not supported)\n", argv[0]);
+		oklog
+		    ("CMDLINE: *** Ignoring %s (outbound network not supported)\n",
+		     argv[0]);
 	    }
 #endif
-	}
-	else if (0 == strcmp(argv[0],"-a")) {
-            if (argc <= 1)
-                return 0;
-            argc--;
-            argv++;
-            bind_local_ip = inet_addr(argv[0]);
-            if (bind_local_ip == INADDR_NONE)
-                return 0;
+	} else if (0 == strcmp(argv[0], "-a")) {
+	    if (argc <= 1)
+		return 0;
+	    argc--;
+	    argv++;
+	    bind_local_ip = inet_addr(argv[0]);
+	    if (bind_local_ip == INADDR_NONE)
+		return 0;
 	    oklog("CMDLINE: Source address restricted to %s\n", argv[0]);
-        }
-        else {
-            if (p != 0) /* strtoul always sets p */
-                return 0;
-            if (0 == strcmp(argv[0],"-p")) {
-                if (argc <= 1)
-                    return 0;
-                argc--;
-                argv++;
-            }
-            *pport = strtoul(argv[0], &p, 10);
-            if (*p != '\0')
-                return 0;
+	} else {
+	    if (p != 0)		/* strtoul always sets p */
+		return 0;
+	    if (0 == strcmp(argv[0], "-p")) {
+		if (argc <= 1)
+		    return 0;
+		argc--;
+		argv++;
+	    }
+	    *pport = strtoul(argv[0], &p, 10);
+	    if (*p != '\0')
+		return 0;
 	    oklog("CMDLINE: Initial port = %d\n", *pport);
-        }
+	}
     }
 #ifdef OUTBOUND_NETWORK
-    oklog("CMDLINE: Outbound network connections %s.\n", 
-          outbound_network_enabled ? "enabled" : "disabled");
+    oklog("CMDLINE: Outbound network connections %s.\n",
+	  outbound_network_enabled ? "enabled" : "disabled");
 #endif
     return 1;
 }
 
-char rcsid_net_tcp[] = "$Id: net_tcp.c,v 1.2 2004-05-22 01:25:44 wrog Exp $";
+char rcsid_net_tcp[] =
+    "$Id: net_tcp.c,v 1.2 2004-05-22 01:25:44 wrog Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/network.c b/server/network.c
index d0e2719..bbbd770 100644
--- a/server/network.c
+++ b/server/network.c
@@ -26,72 +26,86 @@
 Var
 network_connection_options(network_handle nh, Var list)
 {
-  do { 
-    { 
-      Var pair = new_list(2);
-      pair.v.list[1].type = (var_type)(_TYPE_STR | 0x80);
-      pair.v.list[1].v.str = str_dup("client-echo");
-      pair.v.list[2].type = (TYPE_INT);
-      pair.v.list[2].v.num = (((nhandle *)(nh).ptr)->client_echo);
-      (list) = listappend((list), pair);
+    do {
+	{
+	    Var pair = new_list(2);
+	    pair.v.list[1].type = (var_type) (_TYPE_STR | 0x80);
+	    pair.v.list[1].v.str = str_dup("client-echo");
+	    pair.v.list[2].type = (TYPE_INT);
+	    pair.v.list[2].v.num = (((nhandle *) (nh).ptr)->client_echo);
+	    (list) = listappend((list), pair);
 
-      pair = new_list(2);
-      pair.v.list[1].type = TYPE_STR;
-      pair.v.list[1].v.str = str_dup("user-client");
-      pair.v.list[2].type = TYPE_INT; 
-      pair.v.list[2].v.num = (((nhandle *)(nh).ptr)->user_client);
-      list = listappend(list, pair);
+	    pair = new_list(2);
+	    pair.v.list[1].type = TYPE_STR;
+	    pair.v.list[1].v.str = str_dup("user-client");
+	    pair.v.list[2].type = TYPE_INT;
+	    pair.v.list[2].v.num = (((nhandle *) (nh).ptr)->user_client);
+	    list = listappend(list, pair);
 
-      pair = new_list(2);
-      pair.v.list[1].type = TYPE_STR;
-      pair.v.list[1].v.str = str_dup("connect_host");
-      pair.v.list[2].type = TYPE_STR; 
-      pair.v.list[2].v.str = (((nhandle *)(nh).ptr)->connect_host) ? str_ref((((nhandle *)(nh).ptr)->connect_host)) : str_dup("");
-      list = listappend(list, pair);
-    } return (list);
-  } while (0);
+	    pair = new_list(2);
+	    pair.v.list[1].type = TYPE_STR;
+	    pair.v.list[1].v.str = str_dup("connect_host");
+	    pair.v.list[2].type = TYPE_STR;
+	    pair.v.list[2].v.str =
+		(((nhandle *) (nh).ptr)->
+		 connect_host) ? str_ref((((nhandle *) (nh).ptr)->
+					  connect_host)) : str_dup("");
+	    list = listappend(list, pair);
+	}
+	return (list);
+    } while (0);
 }
 
 int
-network_connection_option(network_handle nh, const char *option, Var * value)
+network_connection_option(network_handle nh, const char *option,
+			  Var * value)
 {
-  do { if (!mystrcasecmp((option), "client-echo")) { (value)->type = (TYPE_INT);
-      (value)->v.num = (((nhandle *)(nh).ptr)->client_echo);
-      return 1;
-    } 
-    if (!mystrcasecmp(option, "user-client")) {
-        (value)->type = TYPE_INT;
-        (value)->v.num = (((nhandle *)(nh).ptr)->user_client);
-        return 1;
-    }
-    if (!mystrcasecmp(option, "connect_host")) {
-        (value)->type = TYPE_STR;
-        (value)->v.str = (((nhandle *)(nh).ptr)->connect_host) ? str_ref((((nhandle *)(nh).ptr)->connect_host)) : str_dup("");
-        return 1;
-    }
-    return 0;
-  } while (0);
+    do {
+	if (!mystrcasecmp((option), "client-echo")) {
+	    (value)->type = (TYPE_INT);
+	    (value)->v.num = (((nhandle *) (nh).ptr)->client_echo);
+	    return 1;
+	}
+	if (!mystrcasecmp(option, "user-client")) {
+	    (value)->type = TYPE_INT;
+	    (value)->v.num = (((nhandle *) (nh).ptr)->user_client);
+	    return 1;
+	}
+	if (!mystrcasecmp(option, "connect_host")) {
+	    (value)->type = TYPE_STR;
+	    (value)->v.str =
+		(((nhandle *) (nh).ptr)->
+		 connect_host) ? str_ref((((nhandle *) (nh).ptr)->
+					  connect_host)) : str_dup("");
+	    return 1;
+	}
+	return 0;
+    } while (0);
 }
 
 int
-network_set_connection_option(network_handle nh, const char *option, Var value)
+network_set_connection_option(network_handle nh, const char *option,
+			      Var value)
 {
-  do { if (!mystrcasecmp((option), "client-echo")) { network_set_client_echo((nh), is_true((value)));;
-      return 1;
-    }
-    if (!mystrcasecmp(option, "user-client")) {
-        (((nhandle *)(nh).ptr)->user_client) = value.v.num;
-       return 1;
-     }
-    if (!mystrcasecmp(option, "connect_host")) {
-        if (value.type == TYPE_STR && value.v.str[0] != '\0')
-          (((nhandle *)(nh).ptr)->connect_host) = str_dup(value.v.str);
-        else
-          (((nhandle *)(nh).ptr)->connect_host) = 0;
-       return 1;
-     }
-    return 0;
-  } while (0);
+    do {
+	if (!mystrcasecmp((option), "client-echo")) {
+	    network_set_client_echo((nh), is_true((value)));;
+	    return 1;
+	}
+	if (!mystrcasecmp(option, "user-client")) {
+	    (((nhandle *) (nh).ptr)->user_client) = value.v.num;
+	    return 1;
+	}
+	if (!mystrcasecmp(option, "connect_host")) {
+	    if (value.type == TYPE_STR && value.v.str[0] != '\0')
+		(((nhandle *) (nh).ptr)->connect_host) =
+		    str_dup(value.v.str);
+	    else
+		(((nhandle *) (nh).ptr)->connect_host) = 0;
+	    return 1;
+	}
+	return 0;
+    } while (0);
 }
 
 /*
diff --git a/server/network.h b/server/network.h
index 8f5dc74..66961fb 100644
--- a/server/network.h
+++ b/server/network.h
@@ -51,8 +51,7 @@ extern const char *network_usage_string(void);
 				 * such as a port number, etc.
 				 */
 
-extern int network_initialize(int argc, char **argv,
-			      Var * desc);
+extern int network_initialize(int argc, char **argv, Var * desc);
 				/* ARGC and ARGV refer to just the network-
 				 * specific arguments, if any, which always
 				 * come after any network-independent args.
@@ -166,8 +165,7 @@ extern const char *network_connection_name(network_handle nh);
 				 * into the phrase 'Connection accepted: %s'.
 				 */
 
-extern Var network_connection_options(network_handle nh,
-				      Var list);
+extern Var network_connection_options(network_handle nh, Var list);
 				/* Add the current option settings for the
 				 * given connection onto the end of LIST and
 				 * return the new list.  Each entry on LIST
@@ -175,16 +173,14 @@ extern Var network_connection_options(network_handle nh,
 				 */
 
 extern int network_connection_option(network_handle nh,
-				     const char *option,
-				     Var * value);
+				     const char *option, Var * value);
 				/* Return true iff the given option name
 				 * is valid for the given connection, storing
 				 * the current setting into *VALUE if valid.
 				 */
 
 extern int network_set_connection_option(network_handle nh,
-					 const char *option,
-					 Var value);
+					 const char *option, Var value);
 				/* Return true iff the given option/value pair
 				 * is valid for the given connection, applying
 				 * the given setting if valid.
diff --git a/server/numbers.c b/server/numbers.c
index 8201847..b6e821d 100644
--- a/server/numbers.c
+++ b/server/numbers.c
@@ -99,8 +99,7 @@ become_integer(Var in, int *ret, int called_from_tonum)
 	*ret = in.v.num;
 	break;
     case TYPE_STR:
-	if (!(called_from_tonum
-	      ? parse_number(in.v.str, ret, 1)
+	if (!(called_from_tonum ? parse_number(in.v.str, ret, 1)
 	      : parse_object(in.v.str, ret)))
 	    *ret = 0;
 	break;
@@ -156,7 +155,7 @@ new_float(double d)
 {
     Var v;
 
-    v.type = (var_type)TYPE_FLOAT;
+    v.type = (var_type) TYPE_FLOAT;
     v.v.fnum = (double *) mymalloc(sizeof(double), M_FLOAT);
     *v.v.fnum = d;
 
@@ -193,9 +192,9 @@ to_float(Var v, double *dp)
 // borrowed from:
 // http://docs.sun.com/app/docs/doc/805-3175/6j31emoh8?l=Ja&a=view
 struct exception {
-	int type;
-	char *name;
-	double arg1, arg2, retval;
+    int type;
+    char *name;
+    double arg1, arg2, retval;
 };
 
 
@@ -302,8 +301,8 @@ compare_numbers(Var a, Var b)
 		}
 
 SIMPLE_BINARY(add, +)
-SIMPLE_BINARY(subtract, -)
-SIMPLE_BINARY(multiply, *)
+    SIMPLE_BINARY(subtract, -)
+    SIMPLE_BINARY(multiply, *)
 #define DIVISION_OP(name, iop, fexpr)				\
 		Var						\
 		do_ ## name(Var a, Var b)			\
@@ -333,10 +332,9 @@ SIMPLE_BINARY(multiply, *)
 								\
 		    return ans;					\
 		}
-
-DIVISION_OP(divide, /, *a.v.fnum / *b.v.fnum)
-DIVISION_OP(modulus, %, fmod(*a.v.fnum, *b.v.fnum))
-Var
+    DIVISION_OP(divide, /, *a.v.fnum / *b.v.fnum)
+    DIVISION_OP(modulus, %, fmod(*a.v.fnum, *b.v.fnum))
+    Var
 do_power(Var lhs, Var rhs)
 {				/* LHS ^ RHS */
     Var ans;
@@ -534,21 +532,21 @@ bf_abs(Var arglist, Byte next, void *vdata, Objid progr)
 		}
 
 MATH_FUNC(sqrt)
-MATH_FUNC(sin)
-MATH_FUNC(cos)
-MATH_FUNC(tan)
-MATH_FUNC(asin)
-MATH_FUNC(acos)
-MATH_FUNC(sinh)
-MATH_FUNC(cosh)
-MATH_FUNC(tanh)
-MATH_FUNC(exp)
-MATH_FUNC(log)
-MATH_FUNC(log10)
-MATH_FUNC(ceil)
-MATH_FUNC(floor)
+    MATH_FUNC(sin)
+    MATH_FUNC(cos)
+    MATH_FUNC(tan)
+    MATH_FUNC(asin)
+    MATH_FUNC(acos)
+    MATH_FUNC(sinh)
+    MATH_FUNC(cosh)
+    MATH_FUNC(tanh)
+    MATH_FUNC(exp)
+    MATH_FUNC(log)
+    MATH_FUNC(log10)
+    MATH_FUNC(ceil)
+    MATH_FUNC(floor)
     static package
-     bf_trunc(Var arglist, Byte next, void *vdata, Objid progr)
+	bf_trunc(Var arglist, Byte next, void *vdata, Objid progr)
 {
     double d;
 
@@ -633,7 +631,7 @@ bf_ctime(Var arglist, Byte next, void *vdata, Objid progr)
 
     if (buffer[8] == '0')
 	buffer[8] = ' ';
-    r.type = (var_type)TYPE_STR;
+    r.type = (var_type) TYPE_STR;
     r.v.str = str_dup(buffer);
 
     free_var(arglist);
@@ -680,7 +678,7 @@ bf_floatstr(Var arglist, Byte next, void *vdata, Objid progr)
     sprintf(fmt, "%%.%d%c", prec, use_sci ? 'e' : 'f');
     sprintf(output, fmt, d);
 
-    r.type = (var_type)TYPE_STR;
+    r.type = (var_type) TYPE_STR;
     r.v.str = str_dup(output);
 
     return make_var_pack(r);
@@ -723,7 +721,8 @@ register_numbers(void)
     register_function("trunc", 1, 1, bf_trunc, TYPE_FLOAT);
 }
 
-char rcsid_numbers[] = "$Id: numbers.c,v 1.4 1998-12-14 13:18:37 nop Exp $";
+char rcsid_numbers[] =
+    "$Id: numbers.c,v 1.4 1998-12-14 13:18:37 nop Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/objects.c b/server/objects.c
index 112db81..68d1110 100644
--- a/server/objects.c
+++ b/server/objects.c
@@ -145,11 +145,11 @@ do_move(Var arglist, Byte next, struct bf_move_data *data, Objid progr)
 static package
 bf_move(Var arglist, Byte next, void *vdata, Objid progr)
 {
-  struct bf_move_data *data = (bf_move_data *)vdata;
+    struct bf_move_data *data = (bf_move_data *) vdata;
     package p;
 
     if (next == 1) {
-        data = (bf_move_data *) alloc_data(sizeof(*data));
+	data = (bf_move_data *) alloc_data(sizeof(*data));
 	data->what = arglist.v.list[1].v.obj;
 	data->where = arglist.v.list[2].v.obj;
     }
@@ -165,7 +165,7 @@ bf_move(Var arglist, Byte next, void *vdata, Objid progr)
 static void
 bf_move_write(void *vdata)
 {
-  struct bf_move_data *data = (bf_move_data *) vdata;
+    struct bf_move_data *data = (bf_move_data *) vdata;
 
     dbio_printf("bf_move data: what = %d, where = %d\n",
 		data->what, data->where);
@@ -244,8 +244,7 @@ bf_create(Var arglist, Byte next, void *vdata, Objid progr)
 
 	parent = arglist.v.list[1].v.obj;
 	owner = (arglist.v.list[0].v.num == 2
-		 ? arglist.v.list[2].v.obj
-		 : progr);
+		 ? arglist.v.list[2].v.obj : progr);
 	free_var(arglist);
 
 	if ((valid(parent) ? !db_object_allows(parent, progr, FLAG_FERTILE)
@@ -361,7 +360,7 @@ struct children_data {
 static int
 add_to_list(void *data, Objid child)
 {
-  struct children_data *d = (children_data *) data;
+    struct children_data *d = (children_data *) data;
 
     d->i++;
     d->r.v.list[d->i].type = TYPE_OBJ;
@@ -420,7 +419,8 @@ first_proc(void *data, Objid oid)
 }
 
 static Objid
-get_first(Objid oid, int (*for_all) (Objid, int (*)(void *, Objid), void *))
+get_first(Objid oid,
+	  int (*for_all) (Objid, int (*)(void *, Objid), void *))
 {
     Objid result = NOTHING;
 
@@ -472,8 +472,7 @@ bf_recycle(Var arglist, Byte func_pc, void *vdata, Objid progr)
 	    if (move_to_nothing(c))
 		return make_call_pack(2, data);
 
-	if (db_object_location(oid) != NOTHING
-	    && move_to_nothing(oid))
+	if (db_object_location(oid) != NOTHING && move_to_nothing(oid))
 	    /* Return to same case because this :exitfunc might add new */
 	    /* contents to OID or even move OID right back in. */
 	    return make_call_pack(2, data);
@@ -618,7 +617,8 @@ register_objects(void)
 				      TYPE_OBJ, TYPE_OBJ);
 }
 
-char rcsid_objects[] = "$Id: objects.c,v 1.4 1998-12-14 13:18:39 nop Exp $";
+char rcsid_objects[] =
+    "$Id: objects.c,v 1.4 1998-12-14 13:18:39 nop Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/options.h b/server/options.h
index fdf61b5..79806cd 100644
--- a/server/options.h
+++ b/server/options.h
@@ -280,7 +280,7 @@
  ******************************************************************************
  */
 
-#define STRING_INTERNING /* */
+#define STRING_INTERNING	/* */
 
 /******************************************************************************
  * Store the length of the string WITH the string rather than recomputing
@@ -344,7 +344,7 @@
 #    if HAVE_SELECT
 #      define MPLEX_STYLE MP_SELECT
 #    else
-       #error You cannot use BSD sockets without having select()!
+#error You cannot use BSD sockets without having select()!
 #    endif
 #  else				/* NETWORK_STYLE == NS_SYSV */
 #    if NETWORK_PROTOCOL == NP_LOCAL
@@ -357,7 +357,7 @@
 #	   if FSTAT_WORKS_ON_FIFOS
 #	     define MPLEX_STYLE MP_FAKE
 #	   else
-	     #error I need to be able to do a multiplexing wait on FIFOs!
+#error I need to be able to do a multiplexing wait on FIFOs!
 #	   endif
 #	 endif
 #      endif
@@ -365,7 +365,7 @@
 #      if HAVE_POLL
 #        define MPLEX_STYLE MP_POLL
 #      else
-         #error You cannot use TLI without having poll()!
+#error You cannot use TLI without having poll()!
 #      endif
 #    endif
 #  endif
diff --git a/server/parse_cmd.c b/server/parse_cmd.c
index 606d25c..2ed465c 100644
--- a/server/parse_cmd.c
+++ b/server/parse_cmd.c
@@ -40,7 +40,8 @@ parse_into_words(char *input, int *nwords)
 
     if (!words) {
 	max_words = 50;
-	words = (char **) mymalloc(max_words * sizeof(char *), M_STRING_PTRS);
+	words =
+	    (char **) mymalloc(max_words * sizeof(char *), M_STRING_PTRS);
     }
     while (*input == ' ')
 	input++;
@@ -48,7 +49,9 @@ parse_into_words(char *input, int *nwords)
     for (*nwords = 0; *input != '\0'; (*nwords)++) {
 	if (*nwords == max_words) {
 	    int new_max = max_words * 2;
-	    char **_new = (char **) mymalloc(new_max * sizeof(char *), M_STRING_PTRS);
+	    char **_new =
+		(char **) mymalloc(new_max * sizeof(char *),
+				   M_STRING_PTRS);
 	    int i;
 
 	    for (i = 0; i < max_words; i++)
@@ -116,7 +119,7 @@ parse_into_wordlist(const char *command)
     argv = parse_into_words(s, &argc);
     args = new_list(argc);
     for (i = 1; i <= argc; i++) {
-      args.v.list[i].type = (var_type) TYPE_STR;
+	args.v.list[i].type = (var_type) TYPE_STR;
 	args.v.list[i].v.str = str_dup(argv[i - 1]);
     }
     free_str(s);
@@ -187,7 +190,7 @@ parse_command(const char *command, Objid user)
 
     pc.args = new_list(argc - 1);
     for (i = 1; i < argc; i++) {
-        pc.args.v.list[i].type = (var_type) TYPE_STR;
+	pc.args.v.list[i].type = (var_type) TYPE_STR;
 	pc.args.v.list[i].v.str = str_dup(argv[i]);
     }
 
@@ -249,7 +252,8 @@ free_parsed_command(Parsed_Command * pc)
 }
 
 
-char rcsid_parse_cmd[] = "$Id: parse_cmd.c,v 1.4 1998-12-14 13:18:42 nop Exp $";
+char rcsid_parse_cmd[] =
+    "$Id: parse_cmd.c,v 1.4 1998-12-14 13:18:42 nop Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/pattern.c b/server/pattern.c
index 7b5b737..b850f07 100644
--- a/server/pattern.c
+++ b/server/pattern.c
@@ -120,8 +120,7 @@ new_pattern(const char *pattern, int case_matters)
     buf->translate = case_matters ? 0 : casefold;
     re_set_syntax(MOO_SYNTAX);
 
-    if (tpattern
-	&& !re_compile_pattern((char *) tpattern, tpatlen, buf)) {
+    if (tpattern && !re_compile_pattern((char *) tpattern, tpatlen, buf)) {
 	buf->fastmap = (char *) mymalloc(256 * sizeof(char), M_PATTERN);
 	re_compile_fastmap(buf);
 	p.ptr = buf;
@@ -146,8 +145,7 @@ match_pattern(Pattern p, const char *string, Match_Indices * indices,
 
     switch (re_search(buf, (char *) string, len,
 		      is_reverse ? len : 0,
-		      is_reverse ? -len : len,
-		      (re_registers *) &regs)) {
+		      is_reverse ? -len : len, (re_registers *) & regs)) {
     default:
 	for (i = 0; i < 10; i++) {
 	    /* Convert from 0-based open interval to 1-based closed one. */
diff --git a/server/pattern.h b/server/pattern.h
index f4f254e..0f8b204 100644
--- a/server/pattern.h
+++ b/server/pattern.h
@@ -31,7 +31,7 @@ typedef enum {
 
 extern Pattern new_pattern(const char *pattern, int case_matters);
 extern Match_Result match_pattern(Pattern p, const char *string,
-				Match_Indices * indices, int is_reverse);
+				  Match_Indices * indices, int is_reverse);
 extern void free_pattern(Pattern p);
 
 /* 
diff --git a/server/pgperf/boolarray.c b/server/pgperf/boolarray.c
index 8906134..141b60a 100644
--- a/server/pgperf/boolarray.c
+++ b/server/pgperf/boolarray.c
@@ -29,62 +29,63 @@ static BOOL_ARRAY bool_array;
 /* Prints out debugging diagnostics. */
 
 void
-bool_array_destroy ()
+bool_array_destroy()
 {
-  if (OPTION_ENABLED (option, DEBUG))
-    fprintf (stderr, "\ndumping boolean array information\niteration number = %d\nend of array dump\n",
-             bool_array.iteration_number);
-  free ((char *) bool_array.storage_array);
+    if (OPTION_ENABLED(option, DEBUG))
+	fprintf(stderr,
+		"\ndumping boolean array information\niteration number = %d\nend of array dump\n",
+		bool_array.iteration_number);
+    free((char *) bool_array.storage_array);
 }
 
 void
-bool_array_init (size)
-     int size;
+bool_array_init(size)
+    int size;
 {
-	STORAGE_TYPE *xmalloc ();
-  bool_array.iteration_number = 1;
-  bool_array.size = size;
-  bool_array.storage_array = xmalloc (size * sizeof *bool_array.storage_array);
-  bzero (bool_array.storage_array, size * sizeof *bool_array.storage_array);
-  if (OPTION_ENABLED (option, DEBUG))
-    fprintf (stderr, "\nbool array size = %d, total bytes = %d\n",
-             bool_array.size, bool_array.size * sizeof *bool_array.storage_array);
+    STORAGE_TYPE *xmalloc();
+    bool_array.iteration_number = 1;
+    bool_array.size = size;
+    bool_array.storage_array =
+	xmalloc(size * sizeof *bool_array.storage_array);
+    bzero(bool_array.storage_array,
+	  size * sizeof *bool_array.storage_array);
+    if (OPTION_ENABLED(option, DEBUG))
+	fprintf(stderr, "\nbool array size = %d, total bytes = %d\n",
+		bool_array.size,
+		bool_array.size * sizeof *bool_array.storage_array);
 }
 
-bool 
-lookup (index)
-     int index;
+bool
+lookup(index)
+    int index;
 {
-  if (bool_array.storage_array[index] == bool_array.iteration_number)
-    return 1;
-  else
-    {
-      bool_array.storage_array[index] = bool_array.iteration_number;
-      return 0;
+    if (bool_array.storage_array[index] == bool_array.iteration_number)
+	return 1;
+    else {
+	bool_array.storage_array[index] = bool_array.iteration_number;
+	return 0;
     }
 }
 
 /* Simple enough to reset, eh?! */
 
-void 
-bool_array_reset ()  
+void
+bool_array_reset()
 {
-  /* If we wrap around it's time to zero things out again! */
-            
-  
-  if (++bool_array.iteration_number == 0)
-    {
-      if (OPTION_ENABLED (option, DEBUG))
-        {
-          fprintf (stderr, "(re-initializing bool_array)...");
-          fflush (stderr);
-        }
-      bool_array.iteration_number = 1;
-      bzero (bool_array.storage_array, bool_array.size * sizeof *bool_array.storage_array);
-      if (OPTION_ENABLED (option, DEBUG))
-        {
-          fprintf (stderr, "done\n");
-          fflush (stderr);
-        }
+    /* If we wrap around it's time to zero things out again! */
+
+
+    if (++bool_array.iteration_number == 0) {
+	if (OPTION_ENABLED(option, DEBUG)) {
+	    fprintf(stderr, "(re-initializing bool_array)...");
+	    fflush(stderr);
+	}
+	bool_array.iteration_number = 1;
+	bzero(bool_array.storage_array,
+	      bool_array.size * sizeof *bool_array.storage_array);
+	if (OPTION_ENABLED(option, DEBUG)) {
+	    fprintf(stderr, "done\n");
+	    fflush(stderr);
+	}
     }
 }
diff --git a/server/pgperf/boolarray.h b/server/pgperf/boolarray.h
index 4833975..4f5ea9b 100644
--- a/server/pgperf/boolarray.h
+++ b/server/pgperf/boolarray.h
@@ -20,7 +20,7 @@ along with GNU GPERF; see the file COPYING.  If not, write to
 the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 
 /* Define and implement a simple boolean array abstraction,
-   uses a Guilmette array implementation to save on initialization time. */ 
+   uses a Guilmette array implementation to save on initialization time. */
 
 #ifndef _boolarray_h
 #define _boolarray_h
@@ -33,16 +33,15 @@ typedef unsigned short STORAGE_TYPE;
 #else
 typedef int STORAGE_TYPE;
 #endif
-typedef struct bool_array 
-{
-  STORAGE_TYPE *storage_array;    /* Initialization of the index space. */
-  STORAGE_TYPE  iteration_number; /* Keep track of the current iteration. */
-  int  size;                      /* Size of the entire array (dynamically initialized). */
+typedef struct bool_array {
+    STORAGE_TYPE *storage_array;	/* Initialization of the index space. */
+    STORAGE_TYPE iteration_number;	/* Keep track of the current iteration. */
+    int size;			/* Size of the entire array (dynamically initialized). */
 } BOOL_ARRAY;
 
-extern void bool_array_init P ((int size));
-extern void bool_array_destroy P ((void));
-extern bool lookup P ((int hash_value));
-extern void bool_array_reset P ((void));
+extern void bool_array_init P((int size));
+extern void bool_array_destroy P((void));
+extern bool lookup P((int hash_value));
+extern void bool_array_reset P((void));
 
-#endif /* _boolarray_h */
+#endif				/* _boolarray_h */
diff --git a/server/pgperf/getopt.c b/server/pgperf/getopt.c
index 4eb3c20..f8d9272 100644
--- a/server/pgperf/getopt.c
+++ b/server/pgperf/getopt.c
@@ -14,9 +14,9 @@
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+
 
 
-
 /* This version of `getopt' appears to the caller like standard Unix `getopt'
    but it behaves differently for the user, since it allows the user
    to intersperse the options with the other arguments.
@@ -123,25 +123,23 @@ static int last_nonopt;
     the new indices of the non-options in ARGV after they are moved.  */
 
 static void
-exchange (argv)
-     char **argv;
+exchange(argv)
+    char **argv;
 {
-  int nonopts_size
-    = (last_nonopt - first_nonopt) * sizeof (char *);
-  char **temp = (char **) alloca (nonopts_size);
+    int nonopts_size = (last_nonopt - first_nonopt) * sizeof(char *);
+    char **temp = (char **) alloca(nonopts_size);
 
-  /* Interchange the two blocks of data in argv.  */
+    /* Interchange the two blocks of data in argv.  */
 
-  bcopy (&argv[first_nonopt], temp, nonopts_size);
-  bcopy (&argv[last_nonopt], &argv[first_nonopt],
-	 (optind - last_nonopt) * sizeof (char *));
-  bcopy (temp, &argv[first_nonopt + optind - last_nonopt],
-	 nonopts_size);
+    bcopy(&argv[first_nonopt], temp, nonopts_size);
+    bcopy(&argv[last_nonopt], &argv[first_nonopt],
+	  (optind - last_nonopt) * sizeof(char *));
+    bcopy(temp, &argv[first_nonopt + optind - last_nonopt], nonopts_size);
 
-  /* Update records for the slots the non-options now occupy.  */
+    /* Update records for the slots the non-options now occupy.  */
 
-  first_nonopt += (optind - last_nonopt);
-  last_nonopt = optind;
+    first_nonopt += (optind - last_nonopt);
+    last_nonopt = optind;
 }
 
 /* Scan elements of ARGV (whose length is ARGC) for option characters
@@ -182,164 +180,147 @@ exchange (argv)
    non-option ARGV-elements.  See the comments about RETURN_IN_ORDER, above.  */
 
 int
-getopt (argc, argv, optstring)
-     int argc;
-     char **argv;
-     char *optstring;
+getopt(argc, argv, optstring)
+    int argc;
+    char **argv;
+    char *optstring;
 {
-  /* Initialize the internal data when the first call is made.
-     Start processing options with ARGV-element 1 (since ARGV-element 0
-     is the program name); the sequence of previously skipped
-     non-option ARGV-elements is empty.  */
+    /* Initialize the internal data when the first call is made.
+       Start processing options with ARGV-element 1 (since ARGV-element 0
+       is the program name); the sequence of previously skipped
+       non-option ARGV-elements is empty.  */
 
-  if (optind == 0)
-    {
-      first_nonopt = last_nonopt = optind = 1;
+    if (optind == 0) {
+	first_nonopt = last_nonopt = optind = 1;
 
-      nextchar = 0;
+	nextchar = 0;
 
-      /* Determine how to handle the ordering of options and nonoptions.  */
+	/* Determine how to handle the ordering of options and nonoptions.  */
 
-      if (optstring[0] == '-')
-	ordering = RETURN_IN_ORDER;
-      else if (getenv ("_POSIX_OPTION_ORDER") != 0)
-	ordering = REQUIRE_ORDER;
-      else
-	ordering = PERMUTE;
+	if (optstring[0] == '-')
+	    ordering = RETURN_IN_ORDER;
+	else if (getenv("_POSIX_OPTION_ORDER") != 0)
+	    ordering = REQUIRE_ORDER;
+	else
+	    ordering = PERMUTE;
     }
 
-  if (nextchar == 0 || *nextchar == 0)
-    {
-      if (ordering == PERMUTE)
-	{
-	  /* If we have just processed some options following some non-options,
-	     exchange them so that the options come first.  */
-
-	  if (first_nonopt != last_nonopt && last_nonopt != optind)
-	    exchange (argv);
-	  else if (last_nonopt != optind)
-	    first_nonopt = optind;
-
-	  /* Now skip any additional non-options
-	     and extend the range of non-options previously skipped.  */
-
-	  while (optind < argc
-		 && (argv[optind][0] != '-'
-		     || argv[optind][1] == 0))
-	    optind++;
-	  last_nonopt = optind;
+    if (nextchar == 0 || *nextchar == 0) {
+	if (ordering == PERMUTE) {
+	    /* If we have just processed some options following some non-options,
+	       exchange them so that the options come first.  */
+
+	    if (first_nonopt != last_nonopt && last_nonopt != optind)
+		exchange(argv);
+	    else if (last_nonopt != optind)
+		first_nonopt = optind;
+
+	    /* Now skip any additional non-options
+	       and extend the range of non-options previously skipped.  */
+
+	    while (optind < argc
+		   && (argv[optind][0] != '-' || argv[optind][1] == 0))
+		optind++;
+	    last_nonopt = optind;
 	}
 
-      /* Special ARGV-element `--' means premature end of options.
-	 Skip it like a null option,
-	 then exchange with previous non-options as if it were an option,
-	 then skip everything else like a non-option.  */
+	/* Special ARGV-element `--' means premature end of options.
+	   Skip it like a null option,
+	   then exchange with previous non-options as if it were an option,
+	   then skip everything else like a non-option.  */
 
-      if (optind != argc && !strcmp (argv[optind], "--"))
-	{
-	  optind++;
+	if (optind != argc && !strcmp(argv[optind], "--")) {
+	    optind++;
 
-	  if (first_nonopt != last_nonopt && last_nonopt != optind)
-	    exchange (argv);
-	  else if (first_nonopt == last_nonopt)
-	    first_nonopt = optind;
-	  last_nonopt = argc;
+	    if (first_nonopt != last_nonopt && last_nonopt != optind)
+		exchange(argv);
+	    else if (first_nonopt == last_nonopt)
+		first_nonopt = optind;
+	    last_nonopt = argc;
 
-	  optind = argc;
+	    optind = argc;
 	}
 
-      /* If we have done all the ARGV-elements, stop the scan
-	 and back over any non-options that we skipped and permuted.  */
+	/* If we have done all the ARGV-elements, stop the scan
+	   and back over any non-options that we skipped and permuted.  */
 
-      if (optind == argc)
-	{
-	  /* Set the next-arg-index to point at the non-options
-	     that we previously skipped, so the caller will digest them.  */
-	  if (first_nonopt != last_nonopt)
-	    optind = first_nonopt;
-	  return EOF;
+	if (optind == argc) {
+	    /* Set the next-arg-index to point at the non-options
+	       that we previously skipped, so the caller will digest them.  */
+	    if (first_nonopt != last_nonopt)
+		optind = first_nonopt;
+	    return EOF;
 	}
-	 
-      /* If we have come to a non-option and did not permute it,
-	 either stop the scan or describe it to the caller and pass it by.  */
 
-      if (argv[optind][0] != '-' || argv[optind][1] == 0)
-	{
-	  if (ordering == REQUIRE_ORDER)
-	    return EOF;
-	  optarg = argv[optind++];
-	  return 0;
+	/* If we have come to a non-option and did not permute it,
+	   either stop the scan or describe it to the caller and pass it by.  */
+
+	if (argv[optind][0] != '-' || argv[optind][1] == 0) {
+	    if (ordering == REQUIRE_ORDER)
+		return EOF;
+	    optarg = argv[optind++];
+	    return 0;
 	}
 
-      /* We have found another option-ARGV-element.
-	 Start decoding its characters.  */
+	/* We have found another option-ARGV-element.
+	   Start decoding its characters.  */
 
-      nextchar = argv[optind] + 1;
+	nextchar = argv[optind] + 1;
     }
 
-  /* Look at and handle the next option-character.  */
-
-  {
-    char c = *nextchar++;
-    char *temp = (char *) index (optstring, c);
-
-    /* Increment `optind' when we start to process its last character.  */
-    if (*nextchar == 0)
-      optind++;
-
-    if (temp == 0 || c == ':')
-      {
-	if (opterr != 0)
-	  {
-	    if (c < 040 || c >= 0177)
-	      fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
-		       argv[0], c);
-	    else
-	      fprintf (stderr, "%s: unrecognized option `-%c'\n",
-		       argv[0], c);
-	  }
-	return '?';
-      }
-    if (temp[1] == ':')
-      {
-	if (temp[2] == ':')
-	  {
-	    /* This is an option that accepts an argument optionally.  */
-	    if (*nextchar != 0)
-	      {
-	        optarg = nextchar;
-		optind++;
-	      }
-	    else
-	      optarg = 0;
-	    nextchar = 0;
-	  }
-	else
-	  {
-	    /* This is an option that requires an argument.  */
-	    if (*nextchar != 0)
-	      {
-		optarg = nextchar;
-		/* If we end this ARGV-element by taking the rest as an arg,
-		   we must advance to the next element now.  */
-		optind++;
-	      }
-	    else if (optind == argc)
-	      {
-		if (opterr != 0)
-		  fprintf (stderr, "%s: no argument for `-%c' option\n",
-			   argv[0], c);
-		c = '?';
-	      }
-	    else
-	      /* We already incremented `optind' once;
-		 increment it again when taking next ARGV-elt as argument.  */
-	      optarg = argv[optind++];
-	    nextchar = 0;
-	  }
-      }
-    return c;
-  }
+    /* Look at and handle the next option-character.  */
+
+    {
+	char c = *nextchar++;
+	char *temp = (char *) index(optstring, c);
+
+	/* Increment `optind' when we start to process its last character.  */
+	if (*nextchar == 0)
+	    optind++;
+
+	if (temp == 0 || c == ':') {
+	    if (opterr != 0) {
+		if (c < 040 || c >= 0177)
+		    fprintf(stderr,
+			    "%s: unrecognized option, character code 0%o\n",
+			    argv[0], c);
+		else
+		    fprintf(stderr, "%s: unrecognized option `-%c'\n",
+			    argv[0], c);
+	    }
+	    return '?';
+	}
+	if (temp[1] == ':') {
+	    if (temp[2] == ':') {
+		/* This is an option that accepts an argument optionally.  */
+		if (*nextchar != 0) {
+		    optarg = nextchar;
+		    optind++;
+		} else
+		    optarg = 0;
+		nextchar = 0;
+	    } else {
+		/* This is an option that requires an argument.  */
+		if (*nextchar != 0) {
+		    optarg = nextchar;
+		    /* If we end this ARGV-element by taking the rest as an arg,
+		       we must advance to the next element now.  */
+		    optind++;
+		} else if (optind == argc) {
+		    if (opterr != 0)
+			fprintf(stderr,
+				"%s: no argument for `-%c' option\n",
+				argv[0], c);
+		    c = '?';
+		} else
+		    /* We already incremented `optind' once;
+		       increment it again when taking next ARGV-elt as argument.  */
+		    optarg = argv[optind++];
+		nextchar = 0;
+	    }
+	}
+	return c;
+    }
 }
 
 #ifdef TEST
@@ -348,21 +329,19 @@ getopt (argc, argv, optstring)
    the above definition of `getopt'.  */
 
 int
-main (argc, argv)
-     int argc;
-     char **argv;
+main(argc, argv)
+    int argc;
+    char **argv;
 {
-  char c;
-  int digit_optind = 0;
+    char c;
+    int digit_optind = 0;
 
-  while (1)
-    {
-      int this_option_optind = optind;
-      if ((c = getopt (argc, argv, "abc:d:0123456789")) == EOF)
-	break;
+    while (1) {
+	int this_option_optind = optind;
+	if ((c = getopt(argc, argv, "abc:d:0123456789")) == EOF)
+	    break;
 
-      switch (c)
-	{
+	switch (c) {
 	case '0':
 	case '1':
 	case '2':
@@ -373,41 +352,40 @@ main (argc, argv)
 	case '7':
 	case '8':
 	case '9':
-	  if (digit_optind != 0 && digit_optind != this_option_optind)
-	    printf ("digits occur in two different argv-elements.\n");
-	  digit_optind = this_option_optind;
-	  printf ("option %c\n", c);
-	  break;
+	    if (digit_optind != 0 && digit_optind != this_option_optind)
+		printf("digits occur in two different argv-elements.\n");
+	    digit_optind = this_option_optind;
+	    printf("option %c\n", c);
+	    break;
 
 	case 'a':
-	  printf ("option a\n");
-	  break;
+	    printf("option a\n");
+	    break;
 
 	case 'b':
-	  printf ("option b\n");
-	  break;
+	    printf("option b\n");
+	    break;
 
 	case 'c':
-	  printf ("option c with value `%s'\n", optarg);
-	  break;
+	    printf("option c with value `%s'\n", optarg);
+	    break;
 
 	case '?':
-	  break;
+	    break;
 
 	default:
-	  printf ("?? getopt returned character code 0%o ??\n", c);
+	    printf("?? getopt returned character code 0%o ??\n", c);
 	}
     }
 
-  if (optind < argc)
-    {
-      printf ("non-option ARGV-elements: ");
-      while (optind < argc)
-	printf ("%s ", argv[optind++]);
-      printf ("\n");
+    if (optind < argc) {
+	printf("non-option ARGV-elements: ");
+	while (optind < argc)
+	    printf("%s ", argv[optind++]);
+	printf("\n");
     }
 
-  return 0;
+    return 0;
 }
 
-#endif /* TEST */
+#endif				/* TEST */
diff --git a/server/pgperf/hashtable.c b/server/pgperf/hashtable.c
index c256add..71b7b4a 100644
--- a/server/pgperf/hashtable.c
+++ b/server/pgperf/hashtable.c
@@ -33,23 +33,21 @@ static HASH_TABLE hash_table;
 /* Basically the algorithm from the Dragon book. */
 
 static unsigned
-hash_pjw (str)
-     char *str;
+hash_pjw(str)
+    char *str;
 {
-  char    *temp;
-  unsigned g, h = 0;
-   
-  for (temp = str; *temp; temp++) 
-    {
-      h = (h << 4) + (*temp * 13);
-      if (g = h & 0xf0000000) 
-        {
-          h ^= (g >> 24);
-          h ^= g;
-        }
+    char *temp;
+    unsigned g, h = 0;
+
+    for (temp = str; *temp; temp++) {
+	h = (h << 4) + (*temp * 13);
+	if (g = h & 0xf0000000) {
+	    h ^= (g >> 24);
+	    h ^= g;
+	}
     }
 
-  return h;
+    return h;
 }
 
 /* The size of the hash table is always the smallest power of 2 >= the size
@@ -62,13 +60,14 @@ hash_pjw (str)
    memory fragmentation, since we can now use alloca! */
 
 void
-hash_table_init (table, s)
-     LIST_NODE **table;
-     int s;
+hash_table_init(table, s)
+    LIST_NODE **table;
+    int s;
 {
-  hash_table.size  = s;
-  hash_table.table = table;
-  bzero ((char *) hash_table.table, hash_table.size * sizeof *hash_table.table);
+    hash_table.size = s;
+    hash_table.table = table;
+    bzero((char *) hash_table.table,
+	  hash_table.size * sizeof *hash_table.table);
 }
 
 /* Frees the dynamically allocated table.  Note that since we don't
@@ -76,24 +75,28 @@ hash_table_init (table, s)
    big it is best to return it when we are done. */
 
 void
-hash_table_destroy ()
-{ 
-  if (OPTION_ENABLED (option, DEBUG))
-    {
-      int i;
-
-      fprintf (stderr, "\ndumping the hash table\ntotal elements = %d, bytes = %d\n",
-               hash_table.size, hash_table.size * sizeof *hash_table.table);
-    
-      for (i = hash_table.size - 1; i >= 0; i--)
-        if (hash_table.table[i])
-          fprintf (stderr, "location[%d] has charset \"%s\" and keyword \"%s\"\n",
-                   i, hash_table.table[i]->char_set, hash_table.table[i]->key);
+hash_table_destroy()
+{
+    if (OPTION_ENABLED(option, DEBUG)) {
+	int i;
+
+	fprintf(stderr,
+		"\ndumping the hash table\ntotal elements = %d, bytes = %d\n",
+		hash_table.size,
+		hash_table.size * sizeof *hash_table.table);
+
+	for (i = hash_table.size - 1; i >= 0; i--)
+	    if (hash_table.table[i])
+		fprintf(stderr,
+			"location[%d] has charset \"%s\" and keyword \"%s\"\n",
+			i, hash_table.table[i]->char_set,
+			hash_table.table[i]->key);
 
 #ifdef GATHER_STATISTICS
-      fprintf (stderr, "\ntotal collisions during hashing = %d\n", collisions);
+	fprintf(stderr, "\ntotal collisions during hashing = %d\n",
+		collisions);
 #endif
-      fprintf (stderr, "end dumping hash table\n\n");
+	fprintf(stderr, "end dumping hash table\n\n");
     }
 }
 
@@ -102,31 +105,28 @@ hash_table_destroy ()
    Uses double hashing. */
 
 LIST_NODE *
-retrieve (item, ignore_length)
-     LIST_NODE *item;
-     int        ignore_length;
+retrieve(item, ignore_length)
+    LIST_NODE *item;
+    int ignore_length;
 {
-  unsigned hash_val  = hash_pjw (item->char_set);
-  int      probe     = hash_val & hash_table.size - 1;
-  int      increment = (hash_val ^ item->length | 1) & hash_table.size - 1;
-  
-  while (hash_table.table[probe]
-         && (strcmp (hash_table.table[probe]->char_set, item->char_set)
-             || (!ignore_length && hash_table.table[probe]->length != item->length)))
-    {
+    unsigned hash_val = hash_pjw(item->char_set);
+    int probe = hash_val & hash_table.size - 1;
+    int increment = (hash_val ^ item->length | 1) & hash_table.size - 1;
+
+    while (hash_table.table[probe]
+	   && (strcmp(hash_table.table[probe]->char_set, item->char_set)
+	       || (!ignore_length
+		   && hash_table.table[probe]->length != item->length))) {
 #ifdef GATHER_STATISTICS
-      collisions++;
+	collisions++;
 #endif
-      probe = probe + increment & hash_table.size - 1;
+	probe = probe + increment & hash_table.size - 1;
     }
 
-  if (hash_table.table[probe])
-    return hash_table.table[probe];
-  else
-    {
-      hash_table.table[probe] = item;
-      return 0;
+    if (hash_table.table[probe])
+	return hash_table.table[probe];
+    else {
+	hash_table.table[probe] = item;
+	return 0;
     }
 }
-
-
diff --git a/server/pgperf/hashtable.h b/server/pgperf/hashtable.h
index 218e987..eab54e4 100644
--- a/server/pgperf/hashtable.h
+++ b/server/pgperf/hashtable.h
@@ -24,14 +24,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 #include "keylist.h"
 #include "prototype.h"
 
-typedef struct hash_table 
-{
-  LIST_NODE **table; /* Vector of pointers to linked lists of List_Node's. */
-  int         size;  /* Size of the vector. */
+typedef struct hash_table {
+    LIST_NODE **table;		/* Vector of pointers to linked lists of List_Node's. */
+    int size;			/* Size of the vector. */
 } HASH_TABLE;
 
-extern void       hash_table_init P ((LIST_NODE **table, int size));
-extern void       hash_table_destroy P ((void));
-extern LIST_NODE *retrieve P ((LIST_NODE *item, int ignore_length));
+extern void hash_table_init P((LIST_NODE ** table, int size));
+extern void hash_table_destroy P((void));
+extern LIST_NODE *retrieve P((LIST_NODE * item, int ignore_length));
 
-#endif /* _hashtable_h */
+#endif				/* _hashtable_h */
diff --git a/server/pgperf/iterator.c b/server/pgperf/iterator.c
index b5930f0..ee71138 100644
--- a/server/pgperf/iterator.c
+++ b/server/pgperf/iterator.c
@@ -29,20 +29,20 @@ ITERATOR iterator;
 /* Constructor for ITERATOR. */
 
 void
-iterator_init (s, lo, hi, word_end, bad_val, key_end)
-     char *s;
-     int lo;
-     int hi;
-     int word_end;
-     int bad_val;
-     int key_end;
+iterator_init(s, lo, hi, word_end, bad_val, key_end)
+    char *s;
+    int lo;
+    int hi;
+    int word_end;
+    int bad_val;
+    int key_end;
 {
-  iterator.end         = key_end;
-  iterator.error_value = bad_val;
-  iterator.end_word    = word_end;
-  iterator.str         = s;
-  iterator.hi_bound    = hi;
-  iterator.lo_bound    = lo;
+    iterator.end = key_end;
+    iterator.error_value = bad_val;
+    iterator.end_word = word_end;
+    iterator.str = s;
+    iterator.hi_bound = hi;
+    iterator.lo_bound = lo;
 }
 
 /* Define several useful macros to clarify subsequent code. */
@@ -52,55 +52,50 @@ iterator_init (s, lo, hi, word_end, bad_val, key_end)
 /* Provide an Iterator, returning the ``next'' value from 
    the list of valid values given in the constructor. */
 
-int 
-next ()
-{ 
+int
+next()
+{
 /* Variables to record the Iterator's status when handling ranges, e.g., 3-12. */
 
-  static int size;              
-  static int curr_value;           
-  static int upper_bound;
-
-  if (size) 
-    { 
-      if (++curr_value >= upper_bound) 
-        size = 0;    
-      return curr_value; 
-    }
-  else 
-    {
-      while (*iterator.str) 
-        {
-          if (*iterator.str == ',') 
-            iterator.str++;
-          else if (*iterator.str == '$') 
-            {
-              iterator.str++;
-              return iterator.end_word;
-            }
-          else if (ISPOSDIGIT (*iterator.str))
-            {
-
-              for (curr_value = 0; isdigit (*iterator.str); iterator.str++) 
-                curr_value = curr_value * 10 + *iterator.str - '0';
-
-              if (*iterator.str == '-') 
-                {
-
-                  for (size = 1, upper_bound = 0; 
-                       isdigit (*++iterator.str); 
-                       upper_bound = upper_bound * 10 + *iterator.str - '0');
-
-                  if (upper_bound <= curr_value || upper_bound > iterator.hi_bound) 
-                    return iterator.error_value;
-                }
-              return curr_value >= iterator.lo_bound && curr_value <= iterator.hi_bound 
-                ? curr_value : iterator.error_value;
-            }
-          else
-            return iterator.error_value;               
-        }
-
-      return iterator.end;
+    static int size;
+    static int curr_value;
+    static int upper_bound;
+
+    if (size) {
+	if (++curr_value >= upper_bound)
+	    size = 0;
+	return curr_value;
+    } else {
+	while (*iterator.str) {
+	    if (*iterator.str == ',')
+		iterator.str++;
+	    else if (*iterator.str == '$') {
+		iterator.str++;
+		return iterator.end_word;
+	    } else if (ISPOSDIGIT(*iterator.str)) {
+
+		for (curr_value = 0; isdigit(*iterator.str);
+		     iterator.str++)
+		    curr_value = curr_value * 10 + *iterator.str - '0';
+
+		if (*iterator.str == '-') {
+
+		    for (size = 1, upper_bound = 0;
+			 isdigit(*++iterator.str);
+			 upper_bound =
+			 upper_bound * 10 + *iterator.str - '0');
+
+		    if (upper_bound <= curr_value
+			|| upper_bound > iterator.hi_bound)
+			return iterator.error_value;
+		}
+		return curr_value >= iterator.lo_bound
+		    && curr_value <=
+		    iterator.hi_bound ? curr_value : iterator.error_value;
+	    } else
+		return iterator.error_value;
+	}
+
+	return iterator.end;
     }
 }
diff --git a/server/pgperf/iterator.h b/server/pgperf/iterator.h
index 06dcffd..d134d8e 100644
--- a/server/pgperf/iterator.h
+++ b/server/pgperf/iterator.h
@@ -32,16 +32,16 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 #define _iterator_h
 #include "prototype.h"
 
-typedef struct iterator 
-{
-  char *str;                    /* A pointer to the string provided by the user. */
-  int   end;                    /* Value returned after last key is processed. */
-  int   end_word;               /* A value marking the abstract ``end of word'' ( usually '$'). */
-  int   error_value;            /* Error value returned when input is syntactically erroneous. */
-  int   hi_bound;               /* Greatest possible value, inclusive. */
-  int   lo_bound;               /* Smallest possible value, inclusive. */
+typedef struct iterator {
+    char *str;			/* A pointer to the string provided by the user. */
+    int end;			/* Value returned after last key is processed. */
+    int end_word;		/* A value marking the abstract ``end of word'' ( usually '$'). */
+    int error_value;		/* Error value returned when input is syntactically erroneous. */
+    int hi_bound;		/* Greatest possible value, inclusive. */
+    int lo_bound;		/* Smallest possible value, inclusive. */
 } ITERATOR;
 
-extern void iterator_init P ((char *s, int lo, int hi, int word_end, int bad_val, int key_end));
-extern int  next P ((void));
-#endif /* _iterator_h */
+extern void iterator_init
+P((char *s, int lo, int hi, int word_end, int bad_val, int key_end));
+extern int next P((void));
+#endif				/* _iterator_h */
diff --git a/server/pgperf/keylist.c b/server/pgperf/keylist.c
index 39b8d16..5fe02a5 100644
--- a/server/pgperf/keylist.c
+++ b/server/pgperf/keylist.c
@@ -33,13 +33,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 extern char *version_string;
 
 /* See comments in perfect.cc. */
-extern int occurrences[ALPHABET_SIZE]; 
+extern int occurrences[ALPHABET_SIZE];
 
 /* Ditto. */
 extern int asso_values[ALPHABET_SIZE];
 
 /* Used in function reorder, below. */
-static bool determined[ALPHABET_SIZE]; 
+static bool determined[ALPHABET_SIZE];
 
 /* Default type for generated code. */
 static char *default_array_type = "char *";
@@ -87,70 +87,62 @@ KEY_LIST key_list;
    and return a pointer to all the code (if any) appearing before the delimiter. */
 
 static char *
-get_special_input (delimiter)
-     char delimiter;
-{ 
-  char *xmalloc ();
-  int size  = 80;
-  char *buf = xmalloc (size);
-  int c, i;
-
-  for (i = 0; (c = getchar ()) != EOF; i++)
-    {
-      if (c == '%')
-        {
-          if ((c = getchar ()) == delimiter)
-            {
-        
-              while ((c = getchar ()) != '\n')
-                ; /* Discard newline. */
-              
-              if (i == 0)
-                return "";
-              else
-                {
-                  buf[delimiter == '%' && buf[i - 2] == ';' ? i - 2 : i - 1] = '\0';
-                  return buf;
-                }
-            }
-          else
-            ungetc (c, stdin);
-        }
-      else if (i >= size) /* Yikes, time to grow the buffer! */
-        { 
-          char *temp = xmalloc (size *= 2);
-          int j;
-          
-          for (j = 0; j < i; j++)
-            temp[j] = buf[j];
-          
-          free (buf);
-          buf = temp;
-        }
-      buf[i] = c;
+get_special_input(delimiter)
+    char delimiter;
+{
+    char *xmalloc();
+    int size = 80;
+    char *buf = xmalloc(size);
+    int c, i;
+
+    for (i = 0; (c = getchar()) != EOF; i++) {
+	if (c == '%') {
+	    if ((c = getchar()) == delimiter) {
+
+		while ((c = getchar()) != '\n');	/* Discard newline. */
+
+		if (i == 0)
+		    return "";
+		else {
+		    buf[delimiter == '%'
+			&& buf[i - 2] == ';' ? i - 2 : i - 1] = '\0';
+		    return buf;
+		}
+	    } else
+		ungetc(c, stdin);
+	} else if (i >= size) {	/* Yikes, time to grow the buffer! */
+	    char *temp = xmalloc(size *= 2);
+	    int j;
+
+	    for (j = 0; j < i; j++)
+		temp[j] = buf[j];
+
+	    free(buf);
+	    buf = temp;
+	}
+	buf[i] = c;
     }
-  
-  return NULL;        /* Problem here. */
+
+    return NULL;		/* Problem here. */
 }
 
 /* Stores any C text that must be included verbatim into the 
    generated code output. */
 
 static char *
-save_include_src ()
+save_include_src()
 {
-  int c;
-  
-  if ((c = getchar ()) != '%')
-    {
-      ungetc (c, stdin);
-      return "";
-    }
-  else if ((c = getchar ()) != '{')
-    report_error ("internal error, %c != '{' on line %d in file %s%a", c, __LINE__, __FILE__);
-    /*NOT REACHED*/
-  else 
-    return get_special_input ('}');
+    int c;
+
+    if ((c = getchar()) != '%') {
+	ungetc(c, stdin);
+	return "";
+    } else if ((c = getchar()) != '{')
+	report_error("internal error, %c != '{' on line %d in file %s%a",
+		     c, __LINE__, __FILE__);
+    /*NOT REACHED */
+    else
+	return get_special_input('}');
 }
 
 /* strcspn - find length of initial segment of s consisting entirely
@@ -158,25 +150,24 @@ save_include_src ()
    ANSI string package). */
 
 static int
-strcspn (s, reject)
-     char *s;
-     char *reject;
+strcspn(s, reject)
+    char *s;
+    char *reject;
 {
-  char *scan;
-  char *rej_scan;
-  int   count = 0;
+    char *scan;
+    char *rej_scan;
+    int count = 0;
 
-  for (scan = s; *scan; scan++) 
-    {
+    for (scan = s; *scan; scan++) {
 
-      for (rej_scan = reject; *rej_scan;) 
-        if (*scan == *rej_scan++)
-          return count;
+	for (rej_scan = reject; *rej_scan;)
+	    if (*scan == *rej_scan++)
+		return count;
 
-      count++;
+	count++;
     }
 
-  return count;
+    return count;
 }
 
 /* Determines from the input file whether the user wants to build a table
@@ -184,134 +175,140 @@ strcspn (s, reject)
    use the default array of keys. */
 
 static char *
-get_array_type ()
+get_array_type()
 {
-  return get_special_input ('%');
-}  
-  
+    return get_special_input('%');
+}
+
 /* Sets up the Return_Type, the Struct_Tag type and the Array_Type
    based upon various user Options. */
 
-static void 
-set_output_types ()
+static void
+set_output_types()
 {
-  char *xmalloc ();
-  
-  if (OPTION_ENABLED (option, TYPE) && !(key_list.array_type = get_array_type ()))
-    return;                     /* Something's wrong, bug we'll catch it later on.... */
-  else if (OPTION_ENABLED (option, TYPE))        /* Yow, we've got a user-defined type... */
-    {    
-      int struct_tag_length = strcspn (key_list.array_type, "{\n\0");
-      
-      if (OPTION_ENABLED (option, POINTER))      /* And it must return a pointer... */
-        {    
-          key_list.return_type = xmalloc (struct_tag_length + 2);
-          strncpy (key_list.return_type, key_list.array_type, struct_tag_length);
-          key_list.return_type[struct_tag_length] = '\0';
-          strcat (key_list.return_type, "*");
-        }
-      
-      key_list.struct_tag = (char *) xmalloc (struct_tag_length + 1);
-      strncpy (key_list.struct_tag, key_list.array_type, struct_tag_length);
-      key_list.struct_tag[struct_tag_length] = '\0';
-    }  
-  else if (OPTION_ENABLED (option, POINTER))     /* Return a char *. */
-    key_list.return_type = default_array_type;
+    char *xmalloc();
+
+    if (OPTION_ENABLED(option, TYPE)
+	&& !(key_list.array_type = get_array_type()))
+	return;			/* Something's wrong, bug we'll catch it later on.... */
+    else if (OPTION_ENABLED(option, TYPE)) {	/* Yow, we've got a user-defined type... */
+	int struct_tag_length = strcspn(key_list.array_type, "{\n\0");
+
+	if (OPTION_ENABLED(option, POINTER)) {	/* And it must return a pointer... */
+	    key_list.return_type = xmalloc(struct_tag_length + 2);
+	    strncpy(key_list.return_type, key_list.array_type,
+		    struct_tag_length);
+	    key_list.return_type[struct_tag_length] = '\0';
+	    strcat(key_list.return_type, "*");
+	}
+
+	key_list.struct_tag = (char *) xmalloc(struct_tag_length + 1);
+	strncpy(key_list.struct_tag, key_list.array_type,
+		struct_tag_length);
+	key_list.struct_tag[struct_tag_length] = '\0';
+    } else if (OPTION_ENABLED(option, POINTER))	/* Return a char *. */
+	key_list.return_type = default_array_type;
 }
 
 /* Reads in all keys from standard input and creates a linked list pointed
    to by Head.  This list is then quickly checked for ``links,'' i.e.,
    unhashable elements possessing identical key sets and lengths. */
 
-void 
-read_keys ()
+void
+read_keys()
 {
-  char     *ptr;
-  
-  key_list.include_src = save_include_src ();
-  set_output_types ();
-
-  /* Oops, problem with the input file. */  
-  if (! (ptr = read_line ())) 
-    report_error ("No words in input file, did you forget\
+    char *ptr;
+
+    key_list.include_src = save_include_src();
+    set_output_types();
+
+    /* Oops, problem with the input file. */
+    if (!(ptr = read_line()))
+	report_error("No words in input file, did you forget\
  to prepend %s or use -t accidentally?\n%a", "%%");
 
-  /* Read in all the keywords from the input file. */
-  else 
-    {                      
-      LIST_NODE *temp, *trail;
-      char *delimiter = GET_DELIMITER (option); 
-
-      for (temp = key_list.head = make_list_node (ptr, strcspn (ptr, delimiter));
-           (ptr = read_line ()) && strcmp (ptr, "%%");
-           key_list.total_keys++, temp = temp->next)
-        temp->next = make_list_node (ptr, strcspn (ptr, delimiter));
-      
-      /* See if any additional C code is included at end of this file. */
-      if (ptr)
-        key_list.additional_code = TRUE;
-      {
-        /* If this becomes TRUE we've got a link. */
-        bool       link = FALSE;  
-
-        /* Make large hash table for efficiency. */
-        int table_size = (key_list.list_len = key_list.total_keys) * TABLE_MULTIPLE;
-        
-        /* By allocating the memory here we save on dynamic allocation overhead. 
-           Table must be a power of 2 for the hash function scheme to work. */
-        LIST_NODE **table = (LIST_NODE **) alloca (POW (table_size) * sizeof (LIST_NODE *));
-
-        hash_table_init (table, table_size);
-
-        /* Test whether there are any links and also set the maximum length of
-          an identifier in the keyword list. */
-      
-        for (temp = key_list.head, trail = NULL; temp; temp = temp->next)
-          {
-            LIST_NODE *ptr = retrieve (temp, OPTION_ENABLED (option, NOLENGTH));
-          
-            /* Check for links.  We deal with these by building an equivalence class
-              of all duplicate values (i.e., links) so that only 1 keyword is
-                representative of the entire collection.  This *greatly* simplifies
-                  processing during later stages of the program. */
-
-            if (ptr)              
-              {                   
-                key_list.list_len--;
-                trail->next = temp->next;
-                temp->link  = ptr->link;
-                ptr->link   = temp;
-                link        = TRUE;
-
-                /* Complain if user hasn't enabled the duplicate option. */
-                if (!OPTION_ENABLED (option, DUP))
-                  fprintf (stderr, "Key link: \"%s\" = \"%s\", with key set \"%s\".\n", 
-                  temp->key, ptr->key, temp->char_set);
-                else if (OPTION_ENABLED (option, DEBUG))
-                  fprintf (stderr, "Key link: \"%s\" = \"%s\", with key set \"%s\".\n", 
-                  temp->key, ptr->key, temp->char_set);
-              }
-            else
-              trail = temp;
-            
-            /* Update minimum and maximum keyword length, if needed. */
-            if (temp->length > key_list.max_key_len) 
-              key_list.max_key_len = temp->length;
-            if (temp->length < key_list.min_key_len) 
-              key_list.min_key_len = temp->length;
-          }
-
-        /* Free up the dynamic memory used in the hash table. */
-        hash_table_destroy ();
-
-        /* Exit program if links exists and option[DUP] not set, since we can't continue safely. */
-        if (link) 
-          report_error (OPTION_ENABLED (option, DUP)
-                        ? "Some input keys have identical hash values, examine output carefully...\n"
-                        : "Some input keys have identical hash values,\ntry different key positions or use option -D.\n%a");
-      }
-      if (OPTION_ENABLED (option, ALLCHARS))
-        SET_CHARSET_SIZE (option, key_list.max_key_len);
+    /* Read in all the keywords from the input file. */
+    else {
+	LIST_NODE *temp, *trail;
+	char *delimiter = GET_DELIMITER(option);
+
+	for (temp = key_list.head =
+	     make_list_node(ptr, strcspn(ptr, delimiter));
+	     (ptr = read_line()) && strcmp(ptr, "%%");
+	     key_list.total_keys++, temp = temp->next)
+	    temp->next = make_list_node(ptr, strcspn(ptr, delimiter));
+
+	/* See if any additional C code is included at end of this file. */
+	if (ptr)
+	    key_list.additional_code = TRUE;
+	{
+	    /* If this becomes TRUE we've got a link. */
+	    bool link = FALSE;
+
+	    /* Make large hash table for efficiency. */
+	    int table_size = (key_list.list_len =
+			      key_list.total_keys) * TABLE_MULTIPLE;
+
+	    /* By allocating the memory here we save on dynamic allocation overhead. 
+	       Table must be a power of 2 for the hash function scheme to work. */
+	    LIST_NODE **table =
+		(LIST_NODE **) alloca(POW(table_size) *
+				      sizeof(LIST_NODE *));
+
+	    hash_table_init(table, table_size);
+
+	    /* Test whether there are any links and also set the maximum length of
+	       an identifier in the keyword list. */
+
+	    for (temp = key_list.head, trail = NULL; temp;
+		 temp = temp->next) {
+		LIST_NODE *ptr =
+		    retrieve(temp, OPTION_ENABLED(option, NOLENGTH));
+
+		/* Check for links.  We deal with these by building an equivalence class
+		   of all duplicate values (i.e., links) so that only 1 keyword is
+		   representative of the entire collection.  This *greatly* simplifies
+		   processing during later stages of the program. */
+
+		if (ptr) {
+		    key_list.list_len--;
+		    trail->next = temp->next;
+		    temp->link = ptr->link;
+		    ptr->link = temp;
+		    link = TRUE;
+
+		    /* Complain if user hasn't enabled the duplicate option. */
+		    if (!OPTION_ENABLED(option, DUP))
+			fprintf(stderr,
+				"Key link: \"%s\" = \"%s\", with key set \"%s\".\n",
+				temp->key, ptr->key, temp->char_set);
+		    else if (OPTION_ENABLED(option, DEBUG))
+			fprintf(stderr,
+				"Key link: \"%s\" = \"%s\", with key set \"%s\".\n",
+				temp->key, ptr->key, temp->char_set);
+		} else
+		    trail = temp;
+
+		/* Update minimum and maximum keyword length, if needed. */
+		if (temp->length > key_list.max_key_len)
+		    key_list.max_key_len = temp->length;
+		if (temp->length < key_list.min_key_len)
+		    key_list.min_key_len = temp->length;
+	    }
+
+	    /* Free up the dynamic memory used in the hash table. */
+	    hash_table_destroy();
+
+	    /* Exit program if links exists and option[DUP] not set, since we can't continue safely. */
+	    if (link)
+		report_error(OPTION_ENABLED(option, DUP)
+			     ?
+			     "Some input keys have identical hash values, examine output carefully...\n"
+			     :
+			     "Some input keys have identical hash values,\ntry different key positions or use option -D.\n%a");
+	}
+	if (OPTION_ENABLED(option, ALLCHARS))
+	    SET_CHARSET_SIZE(option, key_list.max_key_len);
     }
 }
 
@@ -320,99 +317,95 @@ read_keys ()
    or by the hash value.  This is a kludge, but permits nice sharing of
    almost identical code without incurring the overhead of a function
    call comparison. */
-  
+
 static LIST_NODE *
-merge (list1, list2)
-     LIST_NODE *list1;
-     LIST_NODE *list2;
+merge(list1, list2)
+    LIST_NODE *list1;
+    LIST_NODE *list2;
 {
-  if (!list1)
-    return list2;
-  else if (!list2)
-    return list1;
-  else if (key_list.occurrence_sort && list1->occurrence < list2->occurrence
-           || key_list.hash_sort && list1->hash_value > list2->hash_value)
-    {
-      list2->next = merge (list2->next, list1);
-      return list2;
-    }
-  else
-    {
-      list1->next = merge (list1->next, list2);
-      return list1;
+    if (!list1)
+	return list2;
+    else if (!list2)
+	return list1;
+    else if (key_list.occurrence_sort
+	     && list1->occurrence < list2->occurrence || key_list.hash_sort
+	     && list1->hash_value > list2->hash_value) {
+	list2->next = merge(list2->next, list1);
+	return list2;
+    } else {
+	list1->next = merge(list1->next, list2);
+	return list1;
     }
 }
 
 /* Applies the merge sort algorithm to recursively sort the key list by
    frequency of occurrence of elements in the key set. */
-  
+
 static LIST_NODE *
-merge_sort (head)
-     LIST_NODE *head;
-{ 
-  if (!head || !head->next)
-    return head;
-  else
-    {
-      LIST_NODE *middle = head;
-      LIST_NODE *temp   = head->next->next;
-    
-      while (temp)
-        {
-          temp   = temp->next;
-          middle = middle->next;
-          if (temp)
-            temp = temp->next;
-        } 
-    
-      temp         = middle->next;
-      middle->next = NULL;
-      return merge (merge_sort (head), merge_sort (temp));
-    }   
+merge_sort(head)
+    LIST_NODE *head;
+{
+    if (!head || !head->next)
+	return head;
+    else {
+	LIST_NODE *middle = head;
+	LIST_NODE *temp = head->next->next;
+
+	while (temp) {
+	    temp = temp->next;
+	    middle = middle->next;
+	    if (temp)
+		temp = temp->next;
+	}
+
+	temp = middle->next;
+	middle->next = NULL;
+	return merge(merge_sort(head), merge_sort(temp));
+    }
 }
 
 /* Returns the frequency of occurrence of elements in the key set. */
 
-static int 
-get_occurrence (ptr)
-     LIST_NODE *ptr;
+static int
+get_occurrence(ptr)
+    LIST_NODE *ptr;
 {
-  int   value = 0;
-  char *temp;
+    int value = 0;
+    char *temp;
 
-  for (temp = ptr->char_set; *temp; temp++)
-    value += occurrences[*temp];
-  
-  return value;
+    for (temp = ptr->char_set; *temp; temp++)
+	value += occurrences[*temp];
+
+    return value;
 }
 
 /* Enables the index location of all key set elements that are now 
    determined. */
-  
-static void 
-set_determined (ptr)
-     LIST_NODE *ptr;
+
+static void
+set_determined(ptr)
+    LIST_NODE *ptr;
 {
-  char *temp;
-  
-  for (temp = ptr->char_set; *temp; temp++)
-    determined[*temp] = TRUE;
-  
+    char *temp;
+
+    for (temp = ptr->char_set; *temp; temp++)
+	determined[*temp] = TRUE;
+
 }
 
 /* Returns TRUE if PTR's key set is already completely determined. */
 
-static bool 
-already_determined (ptr)
-     LIST_NODE *ptr;
+static bool
+already_determined(ptr)
+    LIST_NODE *ptr;
 {
-  bool  is_determined = TRUE;
-  char *temp;
+    bool is_determined = TRUE;
+    char *temp;
 
-  for (temp = ptr->char_set; is_determined && *temp; temp++)
-    is_determined = determined[*temp];
-  
-  return is_determined;
+    for (temp = ptr->char_set; is_determined && *temp; temp++)
+	is_determined = determined[*temp];
+
+    return is_determined;
 }
 
 /* Reorders the table by first sorting the list so that frequently occuring 
@@ -421,99 +414,86 @@ already_determined (ptr)
    helps prune the search time by handling inevitable collisions early in the
    search process.  See Cichelli's paper from Jan 1980 JACM for details.... */
 
-void 
-reorder ()
+void
+reorder()
 {
-  LIST_NODE *ptr;
-
-  for (ptr = key_list.head; ptr; ptr = ptr->next)
-    ptr->occurrence = get_occurrence (ptr);
-  
-  key_list.hash_sort       = FALSE;
-  key_list.occurrence_sort = TRUE;
-  
-  for (ptr = key_list.head = merge_sort (key_list.head); ptr->next; ptr = ptr->next)
-    {
-      set_determined (ptr);
-    
-      if (already_determined (ptr->next))
-        continue;
-      else
-        {
-          LIST_NODE *trail_ptr = ptr->next;
-          LIST_NODE *run_ptr   = trail_ptr->next;
-      
-          for (; run_ptr; run_ptr = trail_ptr->next)
-            {
-        
-              if (already_determined (run_ptr))
-                {
-                  trail_ptr->next = run_ptr->next;
-                  run_ptr->next   = ptr->next;
-                  ptr = ptr->next = run_ptr;
-                }
-              else
-                trail_ptr = run_ptr;
-            }
-        }
-    }     
+    LIST_NODE *ptr;
+
+    for (ptr = key_list.head; ptr; ptr = ptr->next)
+	ptr->occurrence = get_occurrence(ptr);
+
+    key_list.hash_sort = FALSE;
+    key_list.occurrence_sort = TRUE;
+
+    for (ptr = key_list.head = merge_sort(key_list.head); ptr->next;
+	 ptr = ptr->next) {
+	set_determined(ptr);
+
+	if (already_determined(ptr->next))
+	    continue;
+	else {
+	    LIST_NODE *trail_ptr = ptr->next;
+	    LIST_NODE *run_ptr = trail_ptr->next;
+
+	    for (; run_ptr; run_ptr = trail_ptr->next) {
+
+		if (already_determined(run_ptr)) {
+		    trail_ptr->next = run_ptr->next;
+		    run_ptr->next = ptr->next;
+		    ptr = ptr->next = run_ptr;
+		} else
+		    trail_ptr = run_ptr;
+	    }
+	}
+    }
 }
 
 /* Determines the maximum and minimum hash values.  One notable feature is 
    Ira Pohl's optimal algorithm to calculate both the maximum and minimum
    items in a list in O(3n/2) time (faster than the O (2n) method). 
    Returns the maximum hash value encountered. */
-  
-static int 
-print_min_max ()
+
+static int
+print_min_max()
 {
-  int          min_hash_value;
-  int          max_hash_value;
-  LIST_NODE   *temp;
-  
-  if (ODD (key_list.list_len)) /* Pre-process first item, list now has an even length. */
-    {              
-      min_hash_value  = max_hash_value = key_list.head->hash_value;
-      temp            = key_list.head->next;
+    int min_hash_value;
+    int max_hash_value;
+    LIST_NODE *temp;
+
+    if (ODD(key_list.list_len)) {	/* Pre-process first item, list now has an even length. */
+	min_hash_value = max_hash_value = key_list.head->hash_value;
+	temp = key_list.head->next;
+    } else {			/* List is already even length, no extra work necessary. */
+
+	min_hash_value = MAX_INT;
+	max_hash_value = NEG_MAX_INT;
+	temp = key_list.head;
     }
-  else /* List is already even length, no extra work necessary. */
-    {                      
-      min_hash_value = MAX_INT;
-      max_hash_value = NEG_MAX_INT;
-      temp           = key_list.head;
+
+    for (; temp; temp = temp->next) {	/* Find max and min in optimal o(3n/2) time. */
+	static int i;
+	int key_2, key_1 = temp->hash_value;
+	temp = temp->next;
+	key_2 = temp->hash_value;
+	i++;
+
+	if (key_1 < key_2) {
+	    if (key_1 < min_hash_value)
+		min_hash_value = key_1;
+	    if (key_2 > max_hash_value)
+		max_hash_value = key_2;
+	} else {
+	    if (key_2 < min_hash_value)
+		min_hash_value = key_2;
+	    if (key_1 > max_hash_value)
+		max_hash_value = key_1;
+	}
     }
-  
-  for ( ; temp; temp = temp->next) /* Find max and min in optimal o(3n/2) time. */
-    { 
-      static int i;
-      int key_2, key_1 = temp->hash_value;
-      temp  = temp->next;
-      key_2 = temp->hash_value;
-      i++;
-      
-      if (key_1 < key_2)
-        {
-          if (key_1 < min_hash_value)
-            min_hash_value = key_1;
-          if (key_2 > max_hash_value)
-            max_hash_value = key_2;
-        }
-      else
-        {
-          if (key_2 < min_hash_value)
-            min_hash_value = key_2;
-          if (key_1 > max_hash_value)
-            max_hash_value = key_1;
-        }
-  }
-  
-  printf ("\n#define MIN_WORD_LENGTH %d\n#define MAX_WORD_LENGTH %d\
+
+    printf("\n#define MIN_WORD_LENGTH %d\n#define MAX_WORD_LENGTH %d\
 \n#define MIN_HASH_VALUE %d\n#define MAX_HASH_VALUE %d\
-\n/*\n%5d keywords\n%5d is the maximum key range\n*/\n\n",
-          key_list.min_key_len == MAX_INT ? key_list.max_key_len : key_list.min_key_len,
-          key_list.max_key_len, min_hash_value, max_hash_value,
-          key_list.total_keys, (max_hash_value - min_hash_value + 1));
-  return max_hash_value;
+\n/*\n%5d keywords\n%5d is the maximum key range\n*/\n\n", key_list.min_key_len == MAX_INT ? key_list.max_key_len : key_list.min_key_len, key_list.max_key_len, min_hash_value, max_hash_value, key_list.total_keys, (max_hash_value - min_hash_value + 1));
+    return max_hash_value;
 }
 
 /* Generates the output using a C switch.  This trades increased search
@@ -526,560 +506,612 @@ print_min_max ()
    fails to match, and otherwise returning a pointer to appropriate index
    location in the local static array. */
 
-static void 
-print_switch ()
+static void
+print_switch()
 {
-  char      *comp_buffer;
-  LIST_NODE *curr                     = key_list.head;
-  int        pointer_and_type_enabled = OPTION_ENABLED (option, POINTER) && OPTION_ENABLED (option, TYPE);
-  int        total_switches           = GET_TOTAL_SWITCHES (option);
-  int        switch_size              = keyword_list_length () / total_switches;
-  char	    *xlate_func		      = OPTION_ENABLED (option, NOCASE) ? "tolower" : "";
-  char	    *comp_func_prefix	      = OPTION_ENABLED (option, NOCASE) ? "case_" : "";
-
-  if (pointer_and_type_enabled)
-    {
-      comp_buffer = (char *) alloca (strlen ("tolower(*str) == *resword->%s && !case_strncmp (str + 1, resword->%s + 1, len - 1)")
-                                     + 2 * strlen (GET_KEY_NAME (option)) + 1);
-      sprintf (comp_buffer, OPTION_ENABLED (option, COMP)
-               ? "%s(*str) == *resword->%s && !%sstrncmp (str + 1, resword->%s + 1, len - 1)"
-               : "%s(*str) == *resword->%s && !%sstrcmp (str + 1, resword->%s + 1)",
-               xlate_func, GET_KEY_NAME (option), comp_func_prefix, GET_KEY_NAME (option));
-    }
-  else
-    sprintf (comp_buffer, OPTION_ENABLED (option, COMP) 
-	     ? "%s(*str) == *resword && !%sstrncmp (str + 1, resword + 1, len - 1)" 
-	     : "%s(*str) == *resword && !%sstrcmp (str + 1, resword + 1)",
-	     xlate_func, comp_func_prefix);
-
-  printf ("  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n\
+    char *comp_buffer;
+    LIST_NODE *curr = key_list.head;
+    int pointer_and_type_enabled = OPTION_ENABLED(option, POINTER)
+	&& OPTION_ENABLED(option, TYPE);
+    int total_switches = GET_TOTAL_SWITCHES(option);
+    int switch_size = keyword_list_length() / total_switches;
+    char *xlate_func = OPTION_ENABLED(option, NOCASE) ? "tolower" : "";
+    char *comp_func_prefix = OPTION_ENABLED(option, NOCASE) ? "case_" : "";
+
+    if (pointer_and_type_enabled) {
+	comp_buffer =
+	    (char *)
+	    alloca(strlen
+		   ("tolower(*str) == *resword->%s && !case_strncmp (str + 1, resword->%s + 1, len - 1)")
+		   + 2 * strlen(GET_KEY_NAME(option)) + 1);
+	sprintf(comp_buffer, OPTION_ENABLED(option, COMP)
+		?
+		"%s(*str) == *resword->%s && !%sstrncmp (str + 1, resword->%s + 1, len - 1)"
+		:
+		"%s(*str) == *resword->%s && !%sstrcmp (str + 1, resword->%s + 1)",
+		xlate_func, GET_KEY_NAME(option), comp_func_prefix,
+		GET_KEY_NAME(option));
+    } else
+	sprintf(comp_buffer, OPTION_ENABLED(option, COMP)
+		?
+		"%s(*str) == *resword && !%sstrncmp (str + 1, resword + 1, len - 1)"
+		:
+		"%s(*str) == *resword && !%sstrcmp (str + 1, resword + 1)",
+		xlate_func, comp_func_prefix);
+
+    printf("  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n\
       register int key = %s (str, len);\n\n\
-      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)\n        {\n", GET_HASH_NAME (option));
-  
-  /* Properly deal with user's who request multiple switch statements. */
-
-  while (curr)
-    {
-      LIST_NODE *temp              = curr;
-      int        lowest_case_value = curr->hash_value;
-      int        number_of_cases   = 0;
-
-      /* Figure out a good cut point to end this switch. */
-
-      for (; temp && ++number_of_cases < switch_size; temp = temp->next)
-        if (temp->next && temp->hash_value == temp->next->hash_value)
-          while (temp->next && temp->hash_value == temp->next->hash_value)
-            temp = temp->next;
-
-      if (temp)
-        printf ("          if (key <= %d)\n            {\n", temp->hash_value);
-      else
-        printf ("            {\n");
-
-      /* Output each keyword as part of a switch statement indexed by hash value. */
-      
-      if (OPTION_ENABLED (option, POINTER) || OPTION_ENABLED (option, DUP))
-        {
-          int i = 0;
-
-          printf ("              %s%s *resword; %s\n\n",
-                  OPTION_ENABLED (option, CONST) ? "const " : "",
-                  pointer_and_type_enabled ? key_list.struct_tag : "char", 
-                  OPTION_ENABLED (option, LENTABLE) && !OPTION_ENABLED (option, DUP) ? "int key_len;" : "");
-          printf ("              switch (key - %d)\n                {\n", lowest_case_value);
-
-          for (temp = curr; temp && ++i <= number_of_cases; temp = temp->next)
-            {
-              printf ("                case %*d:", field_width, temp->hash_value - lowest_case_value);
-              if (OPTION_ENABLED (option, DEBUG))
-                printf (" /* hash value = %4d, keyword = \"%s\" */", temp->hash_value, temp->key);
-              putchar ('\n');
-
-              /* Handle `natural links,' i.e., those that occur statically. */
-
-              if (temp->link)
-                {
-                  LIST_NODE *links;
-
-                  for (links = temp; links; links = links->link)
-                    {
-                      if (pointer_and_type_enabled)
-                        printf ("                  resword = &wordlist[%d];\n", links->index);
-                      else
-                        printf ("                  resword = \"%s\";\n", links->key); 
-                      printf ("                  if (%s) return resword;\n", comp_buffer);
-                    }
-                }
-              /* Handle unresolved duplicate hash values.  These are guaranteed
-                to be adjacent since we sorted the keyword list by increasing
-                  hash values. */
-              if (temp->next && temp->hash_value == temp->next->hash_value)
-                {
-
-                  for ( ; temp->next && temp->hash_value == temp->next->hash_value;
-                       temp = temp->next)
-                    {
-                      if (pointer_and_type_enabled)
-                        printf ("                  resword = &wordlist[%d];\n", temp->index);
-                      else
-                        printf ("                  resword = \"%s\";\n", temp->key);
-                      printf ("                  if (%s) return resword;\n", comp_buffer);
-                    }
-                  if (pointer_and_type_enabled)
-                    printf ("                  resword = &wordlist[%d];\n", temp->index);
-                  else
-                    printf ("                  resword = \"%s\";\n", temp->key);
-                  printf ("                  return %s ? resword : 0;\n", comp_buffer);
-                }
-              else if (temp->link)
-                printf ("                  return 0;\n");
-              else
-                {
-                  if (pointer_and_type_enabled)
-                    printf ("                  resword = &wordlist[%d];", temp->index);
-                  else 
-                    printf ("                  resword = \"%s\";", temp->key);
-                  if (OPTION_ENABLED (option, LENTABLE) && !OPTION_ENABLED (option, DUP))
-                    printf (" key_len = %d;", temp->length);
-                  printf (" break;\n");
-                }
-            }
-          printf ("                default: return 0;\n                }\n");
-          printf (OPTION_ENABLED (option, LENTABLE) && !OPTION_ENABLED (option, DUP)
-                  ? "              if (len == key_len && %s)\n                return resword;\n"
-                  : "              if (%s)\n                return resword;\n", comp_buffer);
-          printf ("              return 0;\n            }\n");
-          curr = temp;
-        }
-      else                          /* Nothing special required here. */
-        {                        
-          int i = 0;
-          printf ("              char *s;\n\n              switch (key - %d)\n                {\n",
-                  lowest_case_value);
-      
-          for (temp = curr; temp && ++i <= number_of_cases; temp = temp->next)
-            if (OPTION_ENABLED (option, LENTABLE))
-              printf ("                case %*d: if (len == %d) s = \"%s\"; else return 0; break;\n",
-                      field_width, temp->hash_value - lowest_case_value, 
-                      temp->length, temp->key);
-            else
-              printf ("                case %*d: s = \"%s\"; break;\n",
-                      field_width, temp->hash_value - lowest_case_value, temp->key);
-                      
-          printf ("                default: return 0;\n                }\n              ");
-          printf ("return *s == %s(*str) && !%s%s;\n            }\n",
-		  xlate_func, comp_func_prefix,
-                  OPTION_ENABLED (option, COMP) 
-                  ? "strncmp (s + 1, str + 1, len - 1)" : "strcmp (s + 1, str + 1)");
-          curr = temp;
-        }
+      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)\n        {\n",
+	   GET_HASH_NAME(option));
+
+    /* Properly deal with user's who request multiple switch statements. */
+
+    while (curr) {
+	LIST_NODE *temp = curr;
+	int lowest_case_value = curr->hash_value;
+	int number_of_cases = 0;
+
+	/* Figure out a good cut point to end this switch. */
+
+	for (; temp && ++number_of_cases < switch_size; temp = temp->next)
+	    if (temp->next && temp->hash_value == temp->next->hash_value)
+		while (temp->next
+		       && temp->hash_value == temp->next->hash_value)
+		    temp = temp->next;
+
+	if (temp)
+	    printf("          if (key <= %d)\n            {\n",
+		   temp->hash_value);
+	else
+	    printf("            {\n");
+
+	/* Output each keyword as part of a switch statement indexed by hash value. */
+
+	if (OPTION_ENABLED(option, POINTER) || OPTION_ENABLED(option, DUP)) {
+	    int i = 0;
+
+	    printf("              %s%s *resword; %s\n\n",
+		   OPTION_ENABLED(option, CONST) ? "const " : "",
+		   pointer_and_type_enabled ? key_list.struct_tag : "char",
+		   OPTION_ENABLED(option, LENTABLE)
+		   && !OPTION_ENABLED(option, DUP) ? "int key_len;" : "");
+	    printf("              switch (key - %d)\n                {\n",
+		   lowest_case_value);
+
+	    for (temp = curr; temp && ++i <= number_of_cases;
+		 temp = temp->next) {
+		printf("                case %*d:", field_width,
+		       temp->hash_value - lowest_case_value);
+		if (OPTION_ENABLED(option, DEBUG))
+		    printf(" /* hash value = %4d, keyword = \"%s\" */",
+			   temp->hash_value, temp->key);
+		putchar('\n');
+
+		/* Handle `natural links,' i.e., those that occur statically. */
+
+		if (temp->link) {
+		    LIST_NODE *links;
+
+		    for (links = temp; links; links = links->link) {
+			if (pointer_and_type_enabled)
+			    printf
+				("                  resword = &wordlist[%d];\n",
+				 links->index);
+			else
+			    printf("                  resword = \"%s\";\n",
+				   links->key);
+			printf
+			    ("                  if (%s) return resword;\n",
+			     comp_buffer);
+		    }
+		}
+		/* Handle unresolved duplicate hash values.  These are guaranteed
+		   to be adjacent since we sorted the keyword list by increasing
+		   hash values. */
+		if (temp->next
+		    && temp->hash_value == temp->next->hash_value) {
+
+		    for (;
+			 temp->next
+			 && temp->hash_value == temp->next->hash_value;
+			 temp = temp->next) {
+			if (pointer_and_type_enabled)
+			    printf
+				("                  resword = &wordlist[%d];\n",
+				 temp->index);
+			else
+			    printf("                  resword = \"%s\";\n",
+				   temp->key);
+			printf
+			    ("                  if (%s) return resword;\n",
+			     comp_buffer);
+		    }
+		    if (pointer_and_type_enabled)
+			printf
+			    ("                  resword = &wordlist[%d];\n",
+			     temp->index);
+		    else
+			printf("                  resword = \"%s\";\n",
+			       temp->key);
+		    printf("                  return %s ? resword : 0;\n",
+			   comp_buffer);
+		} else if (temp->link)
+		    printf("                  return 0;\n");
+		else {
+		    if (pointer_and_type_enabled)
+			printf
+			    ("                  resword = &wordlist[%d];",
+			     temp->index);
+		    else
+			printf("                  resword = \"%s\";",
+			       temp->key);
+		    if (OPTION_ENABLED(option, LENTABLE)
+			&& !OPTION_ENABLED(option, DUP))
+			printf(" key_len = %d;", temp->length);
+		    printf(" break;\n");
+		}
+	    }
+	    printf
+		("                default: return 0;\n                }\n");
+	    printf(OPTION_ENABLED(option, LENTABLE)
+		   && !OPTION_ENABLED(option, DUP)
+		   ?
+		   "              if (len == key_len && %s)\n                return resword;\n"
+		   :
+		   "              if (%s)\n                return resword;\n",
+		   comp_buffer);
+	    printf("              return 0;\n            }\n");
+	    curr = temp;
+	} else {		/* Nothing special required here. */
+
+	    int i = 0;
+	    printf
+		("              char *s;\n\n              switch (key - %d)\n                {\n",
+		 lowest_case_value);
+
+	    for (temp = curr; temp && ++i <= number_of_cases;
+		 temp = temp->next)
+		if (OPTION_ENABLED(option, LENTABLE))
+		    printf
+			("                case %*d: if (len == %d) s = \"%s\"; else return 0; break;\n",
+			 field_width, temp->hash_value - lowest_case_value,
+			 temp->length, temp->key);
+		else
+		    printf
+			("                case %*d: s = \"%s\"; break;\n",
+			 field_width, temp->hash_value - lowest_case_value,
+			 temp->key);
+
+	    printf
+		("                default: return 0;\n                }\n              ");
+	    printf("return *s == %s(*str) && !%s%s;\n            }\n",
+		   xlate_func, comp_func_prefix, OPTION_ENABLED(option,
+								COMP)
+		   ? "strncmp (s + 1, str + 1, len - 1)" :
+		   "strcmp (s + 1, str + 1)");
+	    curr = temp;
+	}
     }
-  printf ("         }\n    }\n  return 0;\n}\n");
+    printf("         }\n    }\n  return 0;\n}\n");
 }
 
 /* Prints out a table of keyword lengths, for use with the 
    comparison code in generated function ``in_word_set.'' */
 
-static void 
-print_keylength_table ()
+static void
+print_keylength_table()
 {
-  int        max_column = 15;
-  int        index      = 0;
-  int        column     = 0;
-  char      *indent     = OPTION_ENABLED (option, GLOBAL) ? "" : "  ";
-  LIST_NODE *temp;
-
-  if (!OPTION_ENABLED (option, DUP) && !OPTION_ENABLED (option, SWITCH)) 
-    {
-      printf ("\n%sstatic %sunsigned %s lengthtable[] =\n%s%s{\n    ",
-              indent, OPTION_ENABLED (option, CONST) ? "const " : "",
-              key_list.max_key_len < MAX_UNSIGNED_CHAR ? "char" :
-              (key_list.max_key_len < MAX_UNSIGNED_SHORT ? "short" : "long"),
-              indent, indent);
-  
-      for (temp = key_list.head; temp; temp = temp->next, index++)
-        {
-    
-          if (index < temp->hash_value)
-            {
-      
-              for ( ; index < temp->hash_value; index++)
-                printf ("%3d%s", 0, ++column % (max_column - 1) ? "," : ",\n    ");
-            }
-    
-          printf ("%3d%s", temp->length, ++column % (max_column - 1 ) ? "," : ",\n    ");
-        }
-  
-      printf ("\n%s%s};\n\n", indent, indent);
+    int max_column = 15;
+    int index = 0;
+    int column = 0;
+    char *indent = OPTION_ENABLED(option, GLOBAL) ? "" : "  ";
+    LIST_NODE *temp;
+
+    if (!OPTION_ENABLED(option, DUP) && !OPTION_ENABLED(option, SWITCH)) {
+	printf("\n%sstatic %sunsigned %s lengthtable[] =\n%s%s{\n    ",
+	       indent, OPTION_ENABLED(option, CONST) ? "const " : "",
+	       key_list.max_key_len < MAX_UNSIGNED_CHAR ? "char" :
+	       (key_list.max_key_len <
+		MAX_UNSIGNED_SHORT ? "short" : "long"), indent, indent);
+
+	for (temp = key_list.head; temp; temp = temp->next, index++) {
+
+	    if (index < temp->hash_value) {
+
+		for (; index < temp->hash_value; index++)
+		    printf("%3d%s", 0,
+			   ++column % (max_column - 1) ? "," : ",\n    ");
+	    }
+
+	    printf("%3d%s", temp->length,
+		   ++column % (max_column - 1) ? "," : ",\n    ");
+	}
+
+	printf("\n%s%s};\n\n", indent, indent);
     }
 }
 
 /* Prints out the array containing the key words for the Perfect
    hash function. */
-  
-static void 
-print_keyword_table ()
+
+static void
+print_keyword_table()
 {
-  char      *l_brace      = *key_list.head->rest ? "{" : "";
-  char      *r_brace      = *key_list.head->rest ? "}," : "";
-  int        doing_switch = OPTION_ENABLED (option, SWITCH);
-  char      *indent       = OPTION_ENABLED (option, GLOBAL) ? "" : "  ";
-  int        index        = 0;
-  LIST_NODE *temp;
-
-  printf ("\n%sstatic %s%s wordlist[] =\n%s%s{\n", 
-          indent, OPTION_ENABLED (option, CONST) ? "const " : "",
-          key_list.struct_tag, indent, indent);
-  
-  /* Generate an array of reserved words at appropriate locations. */
-  
-	for (temp = key_list.head; temp; temp = temp->next, index++)
-		{
-			temp->index = index;
-
-			if (!doing_switch && index < temp->hash_value)
-				{
-					int column;
-
-					printf ("      ");
-      
-					for (column = 1; index < temp->hash_value; index++, column++)
-						printf ("%s\"\",%s %s", l_brace, r_brace, column % 9 ? "" : "\n      ");
-      
-					if (column % 10)
-						printf ("\n");
-					else 
-						{
-							printf ("%s\"%s\", %s%s\n", l_brace, temp->key, temp->rest, r_brace);
-							continue;
-						}
-				}
-
-			printf ("      %s\"%s\", %s%s\n", l_brace, temp->key, temp->rest, r_brace);
-
-			/* Deal with links specially. */
-			if (temp->link)
-				{
-					LIST_NODE *links;
-
-					for (links = temp->link; links; links = links->link)
-						{
-							links->index = ++index;
-							printf ("      %s\"%s\", %s%s\n", l_brace, links->key, links->rest, r_brace);
-						}
-				}
+    char *l_brace = *key_list.head->rest ? "{" : "";
+    char *r_brace = *key_list.head->rest ? "}," : "";
+    int doing_switch = OPTION_ENABLED(option, SWITCH);
+    char *indent = OPTION_ENABLED(option, GLOBAL) ? "" : "  ";
+    int index = 0;
+    LIST_NODE *temp;
+
+    printf("\n%sstatic %s%s wordlist[] =\n%s%s{\n",
+	   indent, OPTION_ENABLED(option, CONST) ? "const " : "",
+	   key_list.struct_tag, indent, indent);
+
+    /* Generate an array of reserved words at appropriate locations. */
+
+    for (temp = key_list.head; temp; temp = temp->next, index++) {
+	temp->index = index;
+
+	if (!doing_switch && index < temp->hash_value) {
+	    int column;
+
+	    printf("      ");
+
+	    for (column = 1; index < temp->hash_value; index++, column++)
+		printf("%s\"\",%s %s", l_brace, r_brace,
+		       column % 9 ? "" : "\n      ");
+
+	    if (column % 10)
+		printf("\n");
+	    else {
+		printf("%s\"%s\", %s%s\n", l_brace, temp->key, temp->rest,
+		       r_brace);
+		continue;
+	    }
+	}
+
+	printf("      %s\"%s\", %s%s\n", l_brace, temp->key, temp->rest,
+	       r_brace);
+
+	/* Deal with links specially. */
+	if (temp->link) {
+	    LIST_NODE *links;
+
+	    for (links = temp->link; links; links = links->link) {
+		links->index = ++index;
+		printf("      %s\"%s\", %s%s\n", l_brace, links->key,
+		       links->rest, r_brace);
+	    }
+	}
 
-		}
+    }
 
-  printf ("%s%s};\n\n", indent, indent);
+    printf("%s%s};\n\n", indent, indent);
 }
 
 /* Generates C code for the hash function that returns the
    proper encoding for each key word. */
 
-static void 
-print_hash_function (max_hash_value)
-     int max_hash_value;
+static void
+print_hash_function(max_hash_value)
+    int max_hash_value;
 {
-  int max_column = 10;
-  int count       = max_hash_value;
-  char *xlate_func = OPTION_ENABLED (option, NOCASE) ? "tolower" : "";
-
-  /* Calculate maximum number of digits required for MAX_HASH_VALUE. */
-
-  while ((count /= 10) > 0)
-    field_width++;
-
-  if (OPTION_ENABLED (option, GNU))
-    printf ("#ifdef __GNUC__\ninline\n#endif\n");
-  
-  printf (OPTION_ENABLED (option, ANSI) 
-          ? "static int\n%s (register const char *str, register int len)\n{\n  static %sunsigned %s hash_table[] =\n    {"
-          : "static int\n%s (str, len)\n     register char *str;\n     register unsigned int  len;\n{\n  static %sunsigned %s hash_table[] =\n    {",
-          GET_HASH_NAME (option), OPTION_ENABLED (option, CONST) ? "const " : "",
-          max_hash_value < MAX_UNSIGNED_CHAR 
-          ? "char" : (max_hash_value < MAX_UNSIGNED_SHORT ? "short" : "int"));
-  
-  for (count = 0; count < ALPHABET_SIZE; ++count)
-    {
-      if (!(count % max_column))
-        printf ("\n    ");
-      
-      printf ("%*d,", field_width, occurrences[count] ? asso_values[count] : max_hash_value);
+    int max_column = 10;
+    int count = max_hash_value;
+    char *xlate_func = OPTION_ENABLED(option, NOCASE) ? "tolower" : "";
+
+    /* Calculate maximum number of digits required for MAX_HASH_VALUE. */
+
+    while ((count /= 10) > 0)
+	field_width++;
+
+    if (OPTION_ENABLED(option, GNU))
+	printf("#ifdef __GNUC__\ninline\n#endif\n");
+
+    printf(OPTION_ENABLED(option, ANSI)
+	   ?
+	   "static int\n%s (register const char *str, register int len)\n{\n  static %sunsigned %s hash_table[] =\n    {"
+	   :
+	   "static int\n%s (str, len)\n     register char *str;\n     register unsigned int  len;\n{\n  static %sunsigned %s hash_table[] =\n    {",
+	   GET_HASH_NAME(option), OPTION_ENABLED(option,
+						 CONST) ? "const " : "",
+	   max_hash_value < MAX_UNSIGNED_CHAR ? "char" : (max_hash_value <
+							  MAX_UNSIGNED_SHORT
+							  ? "short" :
+							  "int"));
+
+    for (count = 0; count < ALPHABET_SIZE; ++count) {
+	if (!(count % max_column))
+	    printf("\n    ");
+
+	printf("%*d,", field_width,
+	       occurrences[count] ? asso_values[count] : max_hash_value);
+    }
+
+    /* Optimize special case of ``-k 1,$'' */
+    if (OPTION_ENABLED(option, DEFAULTCHARS))
+	printf
+	    ("\n    };\n  return %s + hash_table[%s((unsigned char) str[len - 1])] + hash_table[%s((unsigned char) str[0])];\n}\n\n",
+	     OPTION_ENABLED(option, NOLENGTH) ? "0" : "len", xlate_func,
+	     xlate_func);
+    else {
+	int key_pos;
+
+	RESET(option);
+
+	/* Get first (also highest) key position. */
+	key_pos = GET(option);
+
+	/* We can perform additional optimizations here. */
+	if (!OPTION_ENABLED(option, ALLCHARS)
+	    && key_pos <= key_list.min_key_len) {
+	    printf("\n  };\n  return %s",
+		   OPTION_ENABLED(option, NOLENGTH) ? "0" : "len");
+
+	    for (; key_pos != EOS && key_pos != WORD_END;
+		 key_pos = GET(option))
+		printf(" + hash_table[%s((unsigned char) str[%d])]",
+		       xlate_func, key_pos - 1);
+
+	    if (key_pos == WORD_END)
+		printf(" + hash_table[%s((unsigned char) str[len - 1])]",
+		       xlate_func);
+	    printf(";\n}\n\n");
+	}
+
+	/* We've got to use the correct, but brute force, technique. */
+	else {
+	    printf
+		("\n    };\n  register int hval = %s;\n\n  switch (%s)\n    {\n      default:\n",
+		 OPTION_ENABLED(option, NOLENGTH)
+		 ? "0" : "len", OPTION_ENABLED(option,
+					       NOLENGTH) ? "len" : "hval");
+
+	    /* User wants *all* characters considered in hash. */
+	    if (OPTION_ENABLED(option, ALLCHARS)) {
+		int i;
+
+		for (i = key_list.max_key_len; i > 0; i--)
+		    printf
+			("      case %d:\n        hval += hash_table[%s((unsigned char) str[%d])];\n",
+			 i, xlate_func, i - 1);
+
+		printf("    }\n  return hval;\n}\n\n");
+	    } else {		/* do the hard part... */
+
+		count = key_pos + 1;
+
+		do {
+
+		    while (--count > key_pos)
+			printf("      case %d:\n", count);
+
+		    printf
+			("      case %d:\n        hval += hash_table[%s((unsigned char) str[%d])];\n",
+			 key_pos, xlate_func, key_pos - 1);
+		}
+		while ((key_pos = GET(option)) != EOS
+		       && key_pos != WORD_END);
+
+		printf("    }\n  return hval");
+		if (key_pos == WORD_END)
+		    printf
+			(" + hash_table[%s((unsigned char) str[len - 1])]",
+			 xlate_func);
+		printf(";\n}\n\n");
+	    }
+	}
     }
-  
-  /* Optimize special case of ``-k 1,$'' */
-  if (OPTION_ENABLED (option, DEFAULTCHARS)) 
-    printf ("\n    };\n  return %s + hash_table[%s((unsigned char) str[len - 1])] + hash_table[%s((unsigned char) str[0])];\n}\n\n",
-            OPTION_ENABLED (option, NOLENGTH) ? "0" : "len", xlate_func, xlate_func);
-  else
-    {
-      int key_pos;
-
-      RESET (option);
-
-      /* Get first (also highest) key position. */
-      key_pos = GET (option); 
-      
-      /* We can perform additional optimizations here. */
-      if (!OPTION_ENABLED (option, ALLCHARS) && key_pos <= key_list.min_key_len) 
-        { 
-          printf ("\n  };\n  return %s", OPTION_ENABLED (option, NOLENGTH) ? "0" : "len");
-          
-          for ( ; key_pos != EOS && key_pos != WORD_END; key_pos = GET (option))
-            printf (" + hash_table[%s((unsigned char) str[%d])]", xlate_func, key_pos - 1);
-
-	  if (key_pos == WORD_END)
-	    printf (" + hash_table[%s((unsigned char) str[len - 1])]", xlate_func);
-          printf (";\n}\n\n");
-        }
-
-      /* We've got to use the correct, but brute force, technique. */
-      else 
-        {                    
-          printf ("\n    };\n  register int hval = %s;\n\n  switch (%s)\n    {\n      default:\n",
-                  OPTION_ENABLED (option, NOLENGTH) 
-                  ? "0" : "len", OPTION_ENABLED (option, NOLENGTH) ? "len" : "hval");
-          
-          /* User wants *all* characters considered in hash. */
-          if (OPTION_ENABLED (option, ALLCHARS)) 
-            { 
-              int i;
-
-              for (i = key_list.max_key_len; i > 0; i--)
-                printf ("      case %d:\n        hval += hash_table[%s((unsigned char) str[%d])];\n",
-			i, xlate_func, i - 1);
-              
-              printf ("    }\n  return hval;\n}\n\n");
-            }
-          else /* do the hard part... */
-            {                
-              count = key_pos + 1;
-              
-              do
-                {
-                  
-                  while (--count > key_pos)
-                    printf ("      case %d:\n", count);
-                  
-                  printf ("      case %d:\n        hval += hash_table[%s((unsigned char) str[%d])];\n", 
-                          key_pos, xlate_func, key_pos - 1);
-                }
-              while ((key_pos = GET (option)) != EOS && key_pos != WORD_END);
-              
-              printf ("    }\n  return hval");
-	      if (key_pos == WORD_END)
-		printf(" + hash_table[%s((unsigned char) str[len - 1])]", xlate_func);
-	      printf(";\n}\n\n");
-          }
-      }
-  }
 }
 
 /* Generates C code to perform the keyword lookup. */
 
-static void 
-print_lookup_function ()
-{ 
-  printf ("  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n\
+static void
+print_lookup_function()
+{
+    printf("  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n\
       register int key = %s (str, len);\n\n\
       if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)\n        {\n\
-          register %schar *s = wordlist[key]", 
-          GET_HASH_NAME (option), OPTION_ENABLED (option, CONST) ? "const " : "");
-  if (key_list.array_type != default_array_type)
-    printf (".%s", GET_KEY_NAME (option));
-
-  printf (";\n\n          if (%s*s == %s(*str) && !%s%s)\n            return %s",
-          OPTION_ENABLED (option, LENTABLE) ? "len == lengthtable[key]\n              && " : "",
-	  OPTION_ENABLED (option, NOCASE) ? "tolower" : "",
-	  OPTION_ENABLED (option, NOCASE) ? "case_" : "",
-          OPTION_ENABLED (option, COMP) ? "strncmp (str + 1, s + 1, len - 1)" : "strcmp (str + 1, s + 1)",
-          OPTION_ENABLED (option, TYPE) && OPTION_ENABLED (option, POINTER) ? "&wordlist[key]" : "s");
-  printf (";\n        }\n    }\n  return 0;\n}\n");
+          register %schar *s = wordlist[key]",
+	   GET_HASH_NAME(option), OPTION_ENABLED(option, CONST) ? "const " : "");
+    if (key_list.array_type != default_array_type)
+	printf(".%s", GET_KEY_NAME(option));
+
+    printf
+	(";\n\n          if (%s*s == %s(*str) && !%s%s)\n            return %s",
+	 OPTION_ENABLED(option,
+			LENTABLE) ?
+	 "len == lengthtable[key]\n              && " : "",
+	 OPTION_ENABLED(option, NOCASE) ? "tolower" : "",
+	 OPTION_ENABLED(option, NOCASE) ? "case_" : "",
+	 OPTION_ENABLED(option,
+			COMP) ? "strncmp (str + 1, s + 1, len - 1)" :
+	 "strcmp (str + 1, s + 1)", OPTION_ENABLED(option, TYPE)
+	 && OPTION_ENABLED(option, POINTER) ? "&wordlist[key]" : "s");
+    printf(";\n        }\n    }\n  return 0;\n}\n");
 }
 
 /* Generates C function to do case-insensitive string comparisons. */
 
 static void
-print_compare_function ()
+print_compare_function()
 {
-  if (OPTION_ENABLED (option, COMP))
-    {
-      printf ("static int\n");
-      printf (OPTION_ENABLED (option, ANSI)
-	      ? "case_strncmp (register const char *str, register const char *key, int n)\n"
-	      : "case_strncmp (str, key, n)\n     register char *str, *key;\n     int n;\n");
-      printf ("{\n");
-      printf ("  int ans = 0;\n");
-      printf ("\n");
-      printf ("  while (n && !(ans = tolower(*str) - (int) *key) && *str)\n");
-      printf ("    str++, key++, n--;\n");
-      printf ("\n");
-      printf ("  return ans;\n");
-      printf ("}\n\n");
-    }
-  else
-    {
-      printf ("static int\n");
-      printf (OPTION_ENABLED (option, ANSI)
-	      ? "case_strcmp (register const char *str, register const char *key)\n"
-	      : "case_strcmp (str, key)\n     register char *str, *key;\n");
-      printf ("{\n");
-      printf ("  int ans = 0;\n");
-      printf ("\n");
-      printf ("  while (!(ans = tolower(*str) - (int) *key) && *str)\n");
-      printf ("    str++, key++;\n");
-      printf ("\n");
-      printf ("  return ans;\n");
-      printf ("}\n\n");
+    if (OPTION_ENABLED(option, COMP)) {
+	printf("static int\n");
+	printf(OPTION_ENABLED(option, ANSI)
+	       ?
+	       "case_strncmp (register const char *str, register const char *key, int n)\n"
+	       :
+	       "case_strncmp (str, key, n)\n     register char *str, *key;\n     int n;\n");
+	printf("{\n");
+	printf("  int ans = 0;\n");
+	printf("\n");
+	printf
+	    ("  while (n && !(ans = tolower(*str) - (int) *key) && *str)\n");
+	printf("    str++, key++, n--;\n");
+	printf("\n");
+	printf("  return ans;\n");
+	printf("}\n\n");
+    } else {
+	printf("static int\n");
+	printf(OPTION_ENABLED(option, ANSI)
+	       ?
+	       "case_strcmp (register const char *str, register const char *key)\n"
+	       :
+	       "case_strcmp (str, key)\n     register char *str, *key;\n");
+	printf("{\n");
+	printf("  int ans = 0;\n");
+	printf("\n");
+	printf("  while (!(ans = tolower(*str) - (int) *key) && *str)\n");
+	printf("    str++, key++;\n");
+	printf("\n");
+	printf("  return ans;\n");
+	printf("}\n\n");
     }
 }
 
 /* Generates the hash function and the key word recognizer function
    based upon the user's Options. */
 
-void 
-print_output ()
+void
+print_output()
 {
-  int global_table = OPTION_ENABLED (option, GLOBAL);
-
-  printf ("%s\n", key_list.include_src);
-  
-  /* Potentially output type declaration now, reference it later on.... */
-  if (OPTION_ENABLED (option, TYPE) && !OPTION_ENABLED (option, NOTYPE)) 
-    printf ("%s;\n", key_list.array_type);
-  
-  print_hash_function (print_min_max ());
-  
-  if (OPTION_ENABLED (option, NOCASE))
-    print_compare_function();
-
-  if (global_table)
-    if (OPTION_ENABLED (option, SWITCH))
-      {
-        if (OPTION_ENABLED (option, LENTABLE) && OPTION_ENABLED (option, DUP))
-          print_keylength_table ();
-        if (OPTION_ENABLED (option, POINTER) && OPTION_ENABLED (option, TYPE))
-          print_keyword_table ();
-      }
-    else
-      {
-        if (OPTION_ENABLED (option, LENTABLE))
-          print_keylength_table ();
-        print_keyword_table ();
-      }
-  /* Use the inline keyword to remove function overhead. */
-  if (OPTION_ENABLED (option, GNU)) 
-    printf ("#ifdef __GNUC__\ninline\n#endif\n");
-  
-  /* Use ANSI function prototypes. */
-  printf (OPTION_ENABLED (option, ANSI)
-          ? "%s%s\n%s (register const char *str, register int len)\n{\n"
-          : "%s%s\n%s (str, len)\n     register char *str;\n     register unsigned int len;\n{\n", 
-            OPTION_ENABLED (option, CONST) ? "const " : "", 
-            key_list.return_type, GET_FUNCTION_NAME (option));
-  
-  /* Use the switch in place of lookup table. */
-  if (OPTION_ENABLED (option, SWITCH))
-    {               
-      if (!global_table)
-        {
-          if (OPTION_ENABLED (option, LENTABLE) && OPTION_ENABLED (option, DUP))
-            print_keylength_table ();
-          if (OPTION_ENABLED (option, POINTER) && OPTION_ENABLED (option, TYPE)) 
-            print_keyword_table ();
-        }
-      print_switch ();
-    }
-  else                /* Use the lookup table, in place of switch. */
-    {           
-      if (!global_table)
-        {
-          if (OPTION_ENABLED (option, LENTABLE))
-            print_keylength_table ();
-          print_keyword_table ();
-        }
-      print_lookup_function ();
+    int global_table = OPTION_ENABLED(option, GLOBAL);
+
+    printf("%s\n", key_list.include_src);
+
+    /* Potentially output type declaration now, reference it later on.... */
+    if (OPTION_ENABLED(option, TYPE) && !OPTION_ENABLED(option, NOTYPE))
+	printf("%s;\n", key_list.array_type);
+
+    print_hash_function(print_min_max());
+
+    if (OPTION_ENABLED(option, NOCASE))
+	print_compare_function();
+
+    if (global_table)
+	if (OPTION_ENABLED(option, SWITCH)) {
+	    if (OPTION_ENABLED(option, LENTABLE)
+		&& OPTION_ENABLED(option, DUP))
+		print_keylength_table();
+	    if (OPTION_ENABLED(option, POINTER)
+		&& OPTION_ENABLED(option, TYPE))
+		print_keyword_table();
+	} else {
+	    if (OPTION_ENABLED(option, LENTABLE))
+		print_keylength_table();
+	    print_keyword_table();
+	}
+    /* Use the inline keyword to remove function overhead. */
+    if (OPTION_ENABLED(option, GNU))
+	printf("#ifdef __GNUC__\ninline\n#endif\n");
+
+    /* Use ANSI function prototypes. */
+    printf(OPTION_ENABLED(option, ANSI)
+	   ? "%s%s\n%s (register const char *str, register int len)\n{\n"
+	   :
+	   "%s%s\n%s (str, len)\n     register char *str;\n     register unsigned int len;\n{\n",
+	   OPTION_ENABLED(option, CONST) ? "const " : "",
+	   key_list.return_type, GET_FUNCTION_NAME(option));
+
+    /* Use the switch in place of lookup table. */
+    if (OPTION_ENABLED(option, SWITCH)) {
+	if (!global_table) {
+	    if (OPTION_ENABLED(option, LENTABLE)
+		&& OPTION_ENABLED(option, DUP))
+		print_keylength_table();
+	    if (OPTION_ENABLED(option, POINTER)
+		&& OPTION_ENABLED(option, TYPE))
+		print_keyword_table();
+	}
+	print_switch();
+    } else {			/* Use the lookup table, in place of switch. */
+
+	if (!global_table) {
+	    if (OPTION_ENABLED(option, LENTABLE))
+		print_keylength_table();
+	    print_keyword_table();
+	}
+	print_lookup_function();
     }
 
-  if (key_list.additional_code)
-    {
-      int c;
+    if (key_list.additional_code) {
+	int c;
 
-      while ((c = getchar ()) != EOF)
-        putchar (c);
+	while ((c = getchar()) != EOF)
+	    putchar(c);
     }
-  fflush (stdout);
+    fflush(stdout);
 }
 
 /* Sorts the keys by hash value. */
 
-void 
-sort ()
-{ 
-  key_list.hash_sort       = TRUE;
-  key_list.occurrence_sort = FALSE;
-  
-  key_list.head = merge_sort (key_list.head);
+void
+sort()
+{
+    key_list.hash_sort = TRUE;
+    key_list.occurrence_sort = FALSE;
+
+    key_list.head = merge_sort(key_list.head);
 }
 
 /* Dumps the key list to stderr stream. */
 
-static void 
-dump () 
-{      
-  LIST_NODE *ptr;
-
-  fprintf (stderr, "\nList contents are:\n(hash value, key length, index, key set, key):\n");
-  
-  for (ptr = key_list.head; ptr; ptr = ptr->next)
-    fprintf (stderr, "%7d,%7d,%6d, %s, %s\n",
-             ptr->hash_value, ptr->length, ptr->index,
-             ptr->char_set, ptr->key);
+static void
+dump()
+{
+    LIST_NODE *ptr;
+
+    fprintf(stderr,
+	    "\nList contents are:\n(hash value, key length, index, key set, key):\n");
+
+    for (ptr = key_list.head; ptr; ptr = ptr->next)
+	fprintf(stderr, "%7d,%7d,%6d, %s, %s\n",
+		ptr->hash_value, ptr->length, ptr->index,
+		ptr->char_set, ptr->key);
 }
 
 /* Simple-minded constructor action here... */
 
 void
-key_list_init ()
-{   
-  key_list.total_keys      = 1;
-  key_list.max_key_len     = NEG_MAX_INT;
-  key_list.min_key_len     = MAX_INT;
-  key_list.return_type     = default_return_type;
-  key_list.array_type      = key_list.struct_tag  = default_array_type;
-  key_list.head            = NULL;
-  key_list.additional_code = FALSE;
+key_list_init()
+{
+    key_list.total_keys = 1;
+    key_list.max_key_len = NEG_MAX_INT;
+    key_list.min_key_len = MAX_INT;
+    key_list.return_type = default_return_type;
+    key_list.array_type = key_list.struct_tag = default_array_type;
+    key_list.head = NULL;
+    key_list.additional_code = FALSE;
 }
 
 /* Returns the length of entire key list. */
 
-int 
-keyword_list_length () 
-{ 
-  return key_list.list_len;
+int
+keyword_list_length()
+{
+    return key_list.list_len;
 }
 
 /* Returns length of longest key read. */
 
-int 
-max_key_length ()
-{ 
-  return key_list.max_key_len;
+int
+max_key_length()
+{
+    return key_list.max_key_len;
 }
 
 /* DESTRUCTOR dumps diagnostics during debugging. */
 
 void
-key_list_destroy () 
-{ 
-  if (OPTION_ENABLED (option, DEBUG))
-    {
-      fprintf (stderr, "\nDumping key list information:\ntotal unique keywords = %d\
-\ntotal keywords = %d\nmaximum key length = %d.\n", 
-                    key_list.list_len, key_list.total_keys, key_list.max_key_len);
-      dump ();
-      fprintf (stderr, "End dumping list.\n\n");
+key_list_destroy()
+{
+    if (OPTION_ENABLED(option, DEBUG)) {
+	fprintf(stderr, "\nDumping key list information:\ntotal unique keywords = %d\
+\ntotal keywords = %d\nmaximum key length = %d.\n",
+		key_list.list_len, key_list.total_keys, key_list.max_key_len);
+	dump();
+	fprintf(stderr, "End dumping list.\n\n");
     }
 }
-
diff --git a/server/pgperf/keylist.h b/server/pgperf/keylist.h
index 38143b7..7b13522 100644
--- a/server/pgperf/keylist.h
+++ b/server/pgperf/keylist.h
@@ -29,26 +29,25 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 #include <stdio.h>
 #include "listnode.h"
 
-typedef struct key_list
-{
-  LIST_NODE *head;                  /* Points to the head of the linked list. */
-  char      *array_type;            /* Pointer to the type for word list. */
-  char      *return_type;           /* Pointer to return type for lookup function. */
-  char      *struct_tag;            /* Shorthand for user-defined struct tag type. */
-  char      *include_src;           /* C source code to be included verbatim. */
-  int        list_len;              /* Length of head's Key_List, not counting duplicates. */
-  int        total_keys;            /* Total number of keys, counting duplicates. */
-  int        max_key_len;           /* Maximum length of the longest keyword. */
-  int        min_key_len;           /* Minimum length of the shortest keyword. */
-  bool       occurrence_sort;       /* True if sorting by occurrence. */
-  bool       hash_sort;             /* True if sorting by hash value. */
-  bool       additional_code;       /* True if any additional C code is included. */
+typedef struct key_list {
+    LIST_NODE *head;		/* Points to the head of the linked list. */
+    char *array_type;		/* Pointer to the type for word list. */
+    char *return_type;		/* Pointer to return type for lookup function. */
+    char *struct_tag;		/* Shorthand for user-defined struct tag type. */
+    char *include_src;		/* C source code to be included verbatim. */
+    int list_len;		/* Length of head's Key_List, not counting duplicates. */
+    int total_keys;		/* Total number of keys, counting duplicates. */
+    int max_key_len;		/* Maximum length of the longest keyword. */
+    int min_key_len;		/* Minimum length of the shortest keyword. */
+    bool occurrence_sort;	/* True if sorting by occurrence. */
+    bool hash_sort;		/* True if sorting by hash value. */
+    bool additional_code;	/* True if any additional C code is included. */
 } KEY_LIST;
 
-extern void       key_list_init P ((void));
-extern void       key_list_destroy P ((void));
-extern void       print_output P ((void));
-extern int        keyword_list_length P ((void));
-extern int        max_key_length P ((void));
-extern KEY_LIST   key_list;
-#endif /* _keylist_h */
+extern void key_list_init P((void));
+extern void key_list_destroy P((void));
+extern void print_output P((void));
+extern int keyword_list_length P((void));
+extern int max_key_length P((void));
+extern KEY_LIST key_list;
+#endif				/* _keylist_h */
diff --git a/server/pgperf/listnode.c b/server/pgperf/listnode.c
index 9134f20..a79daab 100644
--- a/server/pgperf/listnode.c
+++ b/server/pgperf/listnode.c
@@ -25,26 +25,26 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 #include "stderr.h"
 
 /* See comments in perfect.cc. */
-extern int occurrences[ALPHABET_SIZE]; 
+extern int occurrences[ALPHABET_SIZE];
 
 /* Sorts the key set alphabetically to speed up subsequent operations.
    Uses insertion sort since the set is probably quite small. */
 
-static void 
-set_sort (base, len)
-     char *base;
-     int len;
+static void
+set_sort(base, len)
+    char *base;
+    int len;
 {
-  int i, j;
+    int i, j;
 
-  for (i = 0, j = len - 1; i < j; i++)
-    {
-      char curr, tmp;
-      
-      for (curr = i + 1, tmp = base[curr]; curr > 0 && tmp < base[curr-1]; curr--)
-        base[curr] = base[curr - 1];
+    for (i = 0, j = len - 1; i < j; i++) {
+	char curr, tmp;
 
-      base[curr] = tmp;
+	for (curr = i + 1, tmp = base[curr];
+	     curr > 0 && tmp < base[curr - 1]; curr--)
+	    base[curr] = base[curr - 1];
+
+	base[curr] = tmp;
 
     }
 }
@@ -60,57 +60,60 @@ set_sort (base, len)
    rather than just an array of keys. */
 
 LIST_NODE *
-make_list_node (k, len)
-     char *k;
-     int len;
+make_list_node(k, len)
+    char *k;
+    int len;
 {
-	LIST_NODE *buffered_malloc ();
-  int char_set_size = OPTION_ENABLED (option, ALLCHARS) ? len : GET_CHARSET_SIZE (option) + 1;
-  LIST_NODE *temp = buffered_malloc (sizeof (LIST_NODE) + char_set_size);
-  char *ptr;
-
-  k[len]       = '\0';        /* Null terminate KEY to separate it from REST. */
-  if (OPTION_ENABLED (option, NOCASE)) /* Downcase the key */
-    for (ptr = k; *ptr; ptr++)
-	*ptr = tolower(*ptr);
-  temp->key    = k;
-  temp->next   = 0;
-  temp->index  = 0;
-  temp->length = len;
-  temp->link   = 0;
-  temp->rest   = OPTION_ENABLED (option, TYPE) ? k + len + 1 : "";
-
-  ptr = temp->char_set;
-  if (OPTION_ENABLED (option, ALLCHARS)) /* Use all the character position in the KEY. */
-
-    for (; *k; k++, ptr++)
-      ++occurrences[*ptr = *k];
-
-  else                          /* Only use those character positions specified by the user. */
-    {                           
-      int i;
-
-      /* Iterate thru the list of key_positions, initializing occurrences table
-         and temp->char_set (via char * pointer ptr). */
-
-      for(RESET (option); (i = GET (option)) != EOS; )
-        {
-          if (i == WORD_END)    /* Special notation for last KEY position, i.e. '$'. */
-            *ptr = temp->key[len - 1];
-          else if (i <= len)    /* Within range of KEY length, so we'll keep it. */
-            *ptr = temp->key[i - 1];
-          else                  /* Out of range of KEY length, so we'll just skip it. */
-            continue;
-          ++occurrences[*ptr++];
-        }
-
-      if (ptr == temp->char_set) /* Didn't get any hits, i.e., no usable positions. */
-        report_error ("can't hash keyword %s with chosen key positions\n%a", temp->key);
+    LIST_NODE *buffered_malloc();
+    int char_set_size =
+	OPTION_ENABLED(option,
+		       ALLCHARS) ? len : GET_CHARSET_SIZE(option) + 1;
+    LIST_NODE *temp = buffered_malloc(sizeof(LIST_NODE) + char_set_size);
+    char *ptr;
+
+    k[len] = '\0';		/* Null terminate KEY to separate it from REST. */
+    if (OPTION_ENABLED(option, NOCASE))	/* Downcase the key */
+	for (ptr = k; *ptr; ptr++)
+	    *ptr = tolower(*ptr);
+    temp->key = k;
+    temp->next = 0;
+    temp->index = 0;
+    temp->length = len;
+    temp->link = 0;
+    temp->rest = OPTION_ENABLED(option, TYPE) ? k + len + 1 : "";
+
+    ptr = temp->char_set;
+    if (OPTION_ENABLED(option, ALLCHARS))
+	/* Use all the character position in the KEY. */
+	for (; *k; k++, ptr++)
+	    ++occurrences[*ptr = *k];
+
+    else {			/* Only use those character positions specified by the user. */
+
+	int i;
+
+	/* Iterate thru the list of key_positions, initializing occurrences table
+	   and temp->char_set (via char * pointer ptr). */
+
+	for (RESET(option); (i = GET(option)) != EOS;) {
+	    if (i == WORD_END)	/* Special notation for last KEY position, i.e. '$'. */
+		*ptr = temp->key[len - 1];
+	    else if (i <= len)	/* Within range of KEY length, so we'll keep it. */
+		*ptr = temp->key[i - 1];
+	    else		/* Out of range of KEY length, so we'll just skip it. */
+		continue;
+	    ++occurrences[*ptr++];
+	}
+
+	if (ptr == temp->char_set)	/* Didn't get any hits, i.e., no usable positions. */
+	    report_error
+		("can't hash keyword %s with chosen key positions\n%a",
+		 temp->key);
     }
 
-  *ptr = '\0';                  /* Terminate this bastard.... */
-  /* Sort the KEY_SET items alphabetically. */
-  set_sort (temp->char_set, ptr - temp->char_set); 
+    *ptr = '\0';		/* Terminate this bastard.... */
+    /* Sort the KEY_SET items alphabetically. */
+    set_sort(temp->char_set, ptr - temp->char_set);
 
-  return temp;
+    return temp;
 }
diff --git a/server/pgperf/listnode.h b/server/pgperf/listnode.h
index 3e64709..3cdf302 100644
--- a/server/pgperf/listnode.h
+++ b/server/pgperf/listnode.h
@@ -25,19 +25,18 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 
 #define ALPHABET_SIZE 128
 
-typedef struct list_node 
-{ 
-  struct list_node *link;       /* TRUE if key has an identical KEY_SET as another key. */
-  struct list_node *next;       /* Points to next element on the list. */  
-  int        length;            /* Length of the key. */
-  int        hash_value;        /* Hash value for the key. */
-  int        occurrence;        /* A metric for frequency of key set occurrences. */
-  int        index;             /* Position of this node relative to other nodes. */
-  char      *key;               /* Key string. */
-  char      *rest;              /* Additional information for building hash function. */
-  char       char_set[1];       /* Set of characters to hash, specified by user. */
+typedef struct list_node {
+    struct list_node *link;	/* TRUE if key has an identical KEY_SET as another key. */
+    struct list_node *next;	/* Points to next element on the list. */
+    int length;			/* Length of the key. */
+    int hash_value;		/* Hash value for the key. */
+    int occurrence;		/* A metric for frequency of key set occurrences. */
+    int index;			/* Position of this node relative to other nodes. */
+    char *key;			/* Key string. */
+    char *rest;			/* Additional information for building hash function. */
+    char char_set[1];		/* Set of characters to hash, specified by user. */
 } LIST_NODE;
 
-extern LIST_NODE *make_list_node P ((char *k, int len));
+extern LIST_NODE *make_list_node P((char *k, int len));
 
-#endif _listnode_h
+#endif	/* _listnode_h */
diff --git a/server/pgperf/main.c b/server/pgperf/main.c
index a54c1df..1eb3c9a 100644
--- a/server/pgperf/main.c
+++ b/server/pgperf/main.c
@@ -32,65 +32,67 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
    ADT.  Note that certain initialization routines require
    initialization *after* certain values are computed.  Therefore,
    they cannot be called here. */
-   
-static void 
-init_all (argc, argv)
-     int argc;
-     char *argv[];
+
+static void
+init_all(argc, argv)
+    int argc;
+    char *argv[];
 {
 #ifdef RLIMIT_STACK
-  /* Get rid of any avoidable limit on stack size.  */
-  {
-    struct rlimit rlim;
-
-    /* Set the stack limit huge so that alloca does not fail. */
-    getrlimit (RLIMIT_STACK, &rlim);
-    rlim.rlim_cur = rlim.rlim_max;
-    setrlimit (RLIMIT_STACK, &rlim);
-  }
-#endif /* RLIMIT_STACK */
-
-  options_init (argc, argv);    
-  key_list_init ();
-  perfect_init ();              
+    /* Get rid of any avoidable limit on stack size.  */
+    {
+	struct rlimit rlim;
+
+	/* Set the stack limit huge so that alloca does not fail. */
+	getrlimit(RLIMIT_STACK, &rlim);
+	rlim.rlim_cur = rlim.rlim_max;
+	setrlimit(RLIMIT_STACK, &rlim);
+    }
+#endif				/* RLIMIT_STACK */
+
+    options_init(argc, argv);
+    key_list_init();
+    perfect_init();
 }
 
 /* Calls appropriate destruction routines for each ADT.  These
    routines print diagnostics if the debugging option is enabled. */
 
 static void
-destroy_all ()
+destroy_all()
 {
-  options_destroy ();
-  key_list_destroy ();
-  perfect_destroy ();
+    options_destroy();
+    key_list_destroy();
+    perfect_destroy();
 }
 
 /* Driver for perfect hash function generation. */
 
 int
-main (argc, argv)
-     int argc;
-     char *argv[];
+main(argc, argv)
+    int argc;
+    char *argv[];
 {
-  struct tm *tm;
-  time_t     clock; 
-  int        status;
-
-  time (&clock);
-  tm = localtime (&clock);
-
-  fprintf (stderr, "/* starting time is %d:%d:%d */\n", tm->tm_hour, tm->tm_min, tm->tm_sec);
-  /* Sets the options. */
-  init_all (argc, argv);
-
-  /* Generates the perfect hash table.
-     Also prints generated code neatly to the output. */
-  status = perfect_generate ();
-  destroy_all ();
-
-  time (&clock);
-  tm = localtime (&clock);
-  fprintf (stderr, "/* ending time is %d:%d:%d */\n", tm->tm_hour, tm->tm_min, tm->tm_sec);
-  return status;
+    struct tm *tm;
+    time_t clock;
+    int status;
+
+    time(&clock);
+    tm = localtime(&clock);
+
+    fprintf(stderr, "/* starting time is %d:%d:%d */\n", tm->tm_hour,
+	    tm->tm_min, tm->tm_sec);
+    /* Sets the options. */
+    init_all(argc, argv);
+
+    /* Generates the perfect hash table.
+       Also prints generated code neatly to the output. */
+    status = perfect_generate();
+    destroy_all();
+
+    time(&clock);
+    tm = localtime(&clock);
+    fprintf(stderr, "/* ending time is %d:%d:%d */\n", tm->tm_hour,
+	    tm->tm_min, tm->tm_sec);
+    return status;
 }
diff --git a/server/pgperf/options.c b/server/pgperf/options.c
index e5bbc5f..22f68e3 100644
--- a/server/pgperf/options.c
+++ b/server/pgperf/options.c
@@ -47,10 +47,10 @@ OPTIONS option;
 
 /* Prints program usage to standard error stream. */
 
-void 
-usage ()
-{ 
-  report_error ("usage: %n [-acCdDef[num]gGhH<hashname>i<init>Ijk<keys>\
+void
+usage()
+{
+    report_error("usage: %n [-acCdDef[num]gGhH<hashname>i<init>Ijk<keys>\
 K<keyname>lnN<name>oprs<size>S<switches>tTv].\n(type %n -h for help)\n");
 }
 
@@ -59,37 +59,37 @@ K<keyname>lnN<name>oprs<size>S<switches>tTv].\n(type %n -h for help)\n");
    Uses a simple Insertion Sort since the set is probably ordered.
    Returns 1 if there are no duplicates, 0 otherwise. */
 
-static int 
-key_sort (base, len)
-     char *base;
-     int   len;
+static int
+key_sort(base, len)
+    char *base;
+    int len;
 {
-  int i, j;
+    int i, j;
 
-  for (i = 0, j = len - 1; i < j; i++) 
-    {
-      int curr, tmp;
-      
-      for (curr = i + 1,tmp = base[curr]; curr > 0 && tmp >= base[curr - 1]; curr--) 
-        if ((base[curr] = base[curr - 1]) == tmp) /* oh no, a duplicate!!! */
-          return 0;
+    for (i = 0, j = len - 1; i < j; i++) {
+	int curr, tmp;
 
-      base[curr] = tmp;
+	for (curr = i + 1, tmp = base[curr];
+	     curr > 0 && tmp >= base[curr - 1]; curr--)
+	    if ((base[curr] = base[curr - 1]) == tmp)	/* oh no, a duplicate!!! */
+		return 0;
+
+	base[curr] = tmp;
     }
 
-  return 1;
+    return 1;
 }
 
 /* Dumps option status when debug is set. */
 
 void
-options_destroy ()
-{ 
-  if (OPTION_ENABLED (option, DEBUG))
-    {
-      char *ptr;
+options_destroy()
+{
+    if (OPTION_ENABLED(option, DEBUG)) {
+	char *ptr;
 
-      fprintf (stderr, "\ndumping Options:\nDEBUG is.......: %s\nORDER is.......: %s\
+	fprintf(stderr,
+		"\ndumping Options:\nDEBUG is.......: %s\nORDER is.......: %s\
 \nANSI is........: %s\nTYPE is........: %s\nGNU is.........: %s\nRANDOM is......: %s\
 \nDEFAULTCHARS is: %s\nSWITCH is......: %s\nPOINTER is.....: %s\nNOLENGTH is....: %s\
 \nLENTABLE is....: %s\nDUP is.........: %s\nCOMP is........: %s\nFAST is........: %s\
@@ -97,131 +97,112 @@ options_destroy ()
 \nlookup function name = %s\nhash function name = %s\nkey name = %s\
 \njump value = %d\nmax associcated value = %d\ninitial associated value = %d\
 \ndelimiters = %s\nnumber of switch statements = %d\napproximate switch statement size = %d\n",
-               OPTION_ENABLED (option, DEBUG) ? "enabled" : "disabled", 
-               OPTION_ENABLED (option, ORDER) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, ANSI) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, TYPE) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, GNU) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, RANDOM) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, DEFAULTCHARS) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, SWITCH) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, POINTER) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, NOLENGTH) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, LENTABLE) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, DUP) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, COMP) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, FAST) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, NOTYPE) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, GLOBAL) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, CONST) ? "enabled" : "disabled",
-               OPTION_ENABLED (option, NOCASE) ? "enabled" : "disabled",
-               option.iterations, option.function_name, option.hash_name,
-               option.key_name, option.jump, option.size - 1, 
-               option.initial_asso_value, option.delimiters, option.total_switches,
-               keyword_list_length () / option.total_switches);
-
-      if (OPTION_ENABLED (option, ALLCHARS)) 
-        fprintf (stderr, "all characters are used in the hash function\n");
-      fprintf (stderr, "maximum charset size = %d\nkey positions are: \n", 
-               option.total_charset_size);
-
-      for (ptr = option.key_positions; *ptr != EOS; ptr++) 
-        if (*ptr == WORD_END) 
-          fprintf (stderr, "$\n");
-        else 
-          fprintf (stderr, "%d\n", *ptr);
-
-      fprintf (stderr, "finished dumping Options\n");
+		OPTION_ENABLED(option, DEBUG) ? "enabled" : "disabled", OPTION_ENABLED(option, ORDER) ? "enabled" : "disabled", OPTION_ENABLED(option, ANSI) ? "enabled" : "disabled", OPTION_ENABLED(option, TYPE) ? "enabled" : "disabled", OPTION_ENABLED(option, GNU) ? "enabled" : "disabled", OPTION_ENABLED(option, RANDOM) ? "enabled" : "disabled", OPTION_ENABLED(option, DEFAULTCHARS) ? "enabled" : "disabled", OPTION_ENABLED(option, SWITCH) ? "enabled" : "disabled", OPTION_ENABLED(option, POINTER) ? "enabled" : "disabled", OPTION_ENABLED(option, NOLENGTH) ? "enabled" : "disabled", OPTION_ENABLED(option, LENTABLE) ? "enabled" : "disabled", OPTION_ENABLED(option, DUP) ? "enabled" : "disabled", OPTION_ENABLED(option, COMP) ? "enabled" : "disabled", OPTION_ENABLED(option, FAST) ? "enabled" : "disabled", OPTION_ENABLED(option, NOTYPE) ? "enabled" : "disabled", OPTION_ENABLED(option, GLOBAL) ? "enabled" : "disabled", OPTION_ENABLED(option, CONST) ? "enabled" : "disabled", OPTION_ENABLED(option, NOCASE) ? "enabled" : "disabled", option.iterations, option.function_name, option.hash_name, option.key_name, option.jump, option.size - 1, option.initial_asso_value, option.delimiters, option.total_switches, keyword_list_length() / option.total_switches);
+
+	if (OPTION_ENABLED(option, ALLCHARS))
+	    fprintf(stderr,
+		    "all characters are used in the hash function\n");
+	fprintf(stderr, "maximum charset size = %d\nkey positions are: \n",
+		option.total_charset_size);
+
+	for (ptr = option.key_positions; *ptr != EOS; ptr++)
+	    if (*ptr == WORD_END)
+		fprintf(stderr, "$\n");
+	    else
+		fprintf(stderr, "%d\n", *ptr);
+
+	fprintf(stderr, "finished dumping Options\n");
     }
 }
 
 /* Parses the command line Options and sets appropriate flags in option.option_word. */
 
 void
-options_init (argc, argv)
-     int argc;
-     char *argv[];
-{ 
-  extern int   optind;
-  extern char *optarg;
-  int   option_char;
-  
-  option.key_positions[0]   = WORD_START;
-  option.key_positions[1]   = WORD_END;
-  option.key_positions[2]   = EOS;
-  option.total_charset_size = 2;
-  option.jump               = DEFAULT_JUMP_VALUE;
-  option.option_word        = (int) DEFAULTCHARS;
-  option.function_name      = DEFAULT_NAME;
-  option.hash_name          = DEFAULT_HASH_NAME;
-  option.key_name           = DEFAULT_KEY;
-  option.delimiters         = DEFAULT_DELIMITERS;
-  option.initial_asso_value = option.size = option.iterations = 0;
-  option.total_switches     = 1;
-  option.argument_count     = argc;
-  option.argument_vector    = argv;
-  set_program_name (argv[0]);
-  
-  while ((option_char = getopt (argc, argv, "adcCDe:f:gGhH:i:Ij:k:K:lnN:oprs:S:tTv")) != EOF)
-    {
-      switch (option_char)
-        {
-        case 'a':               /* Generated coded uses the ANSI prototype format. */
-          { 
-            SET_OPTION (option, ANSI);
-            break;
-          }
-        case 'c':               /* Generate strncmp rather than strcmp. */
-          {
-            SET_OPTION (option, COMP);
-            break;
-          }
-        case 'C':               /* Make the generated tables readonly (const). */
-          {
-            SET_OPTION (option, CONST);
-            break;
-          }
-        case 'd':               /* Enable debugging option. */
-          { 
-            SET_OPTION (option, DEBUG);
-            report_error ("starting program %n, version %s, with debuggin on.\n",
-                          version_string);
-            break;
-          }   
-        case 'D':               /* Enable duplicate option. */
-          { 
-            SET_OPTION (option, DUP);
-            break;
-          }   
-        case 'e': /* Allows user to provide keyword/attribute separator */
-          {
-            SET_DELIMITERS (option, optarg);
-            break;
-          }
-        case 'f':               /* Generate the hash table ``fast.'' */
-          {
-            SET_OPTION (option, FAST);
-            if ((option.iterations = atoi (optarg)) < 0) 
-              {
-                report_error ("iterations value must not be negative, assuming 0\n");
-                option.iterations = 0;
-              }
-            break;
-          }
-        case 'g':               /* Use the ``inline'' keyword for generated sub-routines. */
-          { 
-            SET_OPTION (option, GNU);
-            break;
-          }
-        case 'G':               /* Make the keyword table a global variable. */
-          { 
-            SET_OPTION (option, GLOBAL);
-            break;
-          }
-        case 'h':               /* Displays a list of helpful Options to the user. */
-          { 
-            report_error (
-"-a\tGenerate ANSI standard C output code, i.e., function prototypes.\n\
+options_init(argc, argv)
+    int argc;
+    char *argv[];
+{
+    extern int optind;
+    extern char *optarg;
+    int option_char;
+
+    option.key_positions[0] = WORD_START;
+    option.key_positions[1] = WORD_END;
+    option.key_positions[2] = EOS;
+    option.total_charset_size = 2;
+    option.jump = DEFAULT_JUMP_VALUE;
+    option.option_word = (int) DEFAULTCHARS;
+    option.function_name = DEFAULT_NAME;
+    option.hash_name = DEFAULT_HASH_NAME;
+    option.key_name = DEFAULT_KEY;
+    option.delimiters = DEFAULT_DELIMITERS;
+    option.initial_asso_value = option.size = option.iterations = 0;
+    option.total_switches = 1;
+    option.argument_count = argc;
+    option.argument_vector = argv;
+    set_program_name(argv[0]);
+
+    while ((option_char =
+	    getopt(argc, argv,
+		   "adcCDe:f:gGhH:i:Ij:k:K:lnN:oprs:S:tTv")) != EOF) {
+	switch (option_char) {
+	case 'a':		/* Generated coded uses the ANSI prototype format. */
+	    {
+		SET_OPTION(option, ANSI);
+		break;
+	    }
+	case 'c':		/* Generate strncmp rather than strcmp. */
+	    {
+		SET_OPTION(option, COMP);
+		break;
+	    }
+	case 'C':		/* Make the generated tables readonly (const). */
+	    {
+		SET_OPTION(option, CONST);
+		break;
+	    }
+	case 'd':		/* Enable debugging option. */
+	    {
+		SET_OPTION(option, DEBUG);
+		report_error
+		    ("starting program %n, version %s, with debuggin on.\n",
+		     version_string);
+		break;
+	    }
+	case 'D':		/* Enable duplicate option. */
+	    {
+		SET_OPTION(option, DUP);
+		break;
+	    }
+	case 'e':		/* Allows user to provide keyword/attribute separator */
+	    {
+		SET_DELIMITERS(option, optarg);
+		break;
+	    }
+	case 'f':		/* Generate the hash table ``fast.'' */
+	    {
+		SET_OPTION(option, FAST);
+		if ((option.iterations = atoi(optarg)) < 0) {
+		    report_error
+			("iterations value must not be negative, assuming 0\n");
+		    option.iterations = 0;
+		}
+		break;
+	    }
+	case 'g':		/* Use the ``inline'' keyword for generated sub-routines. */
+	    {
+		SET_OPTION(option, GNU);
+		break;
+	    }
+	case 'G':		/* Make the keyword table a global variable. */
+	    {
+		SET_OPTION(option, GLOBAL);
+		break;
+	    }
+	case 'h':		/* Displays a list of helpful Options to the user. */
+	    {
+		report_error
+		    ("-a\tGenerate ANSI standard C output code, i.e., function prototypes.\n\
 -c\tGenerate comparison code using strncmp rather than strcmp.\n\
 -C\tMake the contents of generated lookup tables constant, i.e., readonly.\n\
 -d\tEnables the debugging option (produces verbose output to Std_Err).\n\
@@ -239,8 +220,7 @@ options_init (argc, argv)
 \trather than hiding it inside of the lookup function (which is the\n\
 \tdefault behavior).\n\
 -h\tPrints this mesage.\n");
-              report_error (
-"-H\tAllow user to specify name of generated hash function. Default is `hash'.\n\
+		report_error("-H\tAllow user to specify name of generated hash function. Default is `hash'.\n\
 -i\tProvide an initial value for the associate values array.  Default is 0.\n\
 \tSetting this value larger helps inflate the size of the final table.\n\
 -I\tMake the keyword lookup case-insensitive.\n\
@@ -263,10 +243,9 @@ options_init (argc, argv)
 -p\tChanges the return value of the generated function ``in_word_set''\n\
 \tfrom its default boolean value (i.e., 0 or 1), to type ``pointer\n\
 \tto wordlist array''  This is most useful when the -t option, allowing\n\
-\tuser-defined structs, is used.\n",
-                          DEFAULT_JUMP_VALUE, MAX_KEY_POS - 1);
-            report_error (
-"-r\tUtilizes randomness to initialize the associated values table.\n\
+\tuser-defined structs, is used.\n", DEFAULT_JUMP_VALUE,
+			     MAX_KEY_POS - 1);
+		report_error("-r\tUtilizes randomness to initialize the associated values table.\n\
 -s\tAffects the size of the generated hash table.  The numeric argument\n\
 \tfor this option indicates ``how many times larger'' the table range\n\
 \tshould be, in relationship to the number of keys, e.g. a value of 3\n\
@@ -291,161 +270,176 @@ options_init (argc, argv)
 -T\tPrevents the transfer of the type declaration to the output file.\n\
 \tUse this option if the type is already defined elsewhere.\n\
 -v\tPrints out the current version number\n%e%a\n",
-                          usage);
-          }
-        case 'H':               /* Sets the name for the hash function */
-          {
-            option.hash_name = optarg;
-            break;
-          }
-        case 'i':               /* Sets the initial value for the associated values array. */
-          { 
-            if ((option.initial_asso_value = atoi (optarg)) < 0) 
-              report_error ("initial value %d must be non-zero, ignoring and continuing\n", 
-                            option.initial_asso_value);
-            if (OPTION_ENABLED (option, RANDOM))
-              report_error ("warning, -r option superceeds -i, ignoring -i option and continuing\n");
-            break;
-          }
-        case 'I':               /* Make the keyword lookup case-insensitive. */
-          { 
-            SET_OPTION (option, NOCASE);
-            break;
-          }
-        case 'j':               /* Sets the jump value, must be odd for later algorithms. */
-          { 
-            if ((option.jump = atoi (optarg)) < 0)
-              report_error ("jump value %d must be a positive number\n%e%a", 
-              option.jump, usage);
-            else if (option.jump && EVEN (option.jump)) 
-              report_error ("jump value %d should be odd, adding 1 and continuing...\n", 
-              option.jump++);
-            break;
-          }
-        case 'k':               /* Sets key positions used for hash function. */
-          { 
-            int BAD_VALUE = -1;
-            int value;
-
-            iterator_init (optarg, 1, MAX_KEY_POS - 1, WORD_END, BAD_VALUE, EOS);
-            
-            if (*optarg == '*') /* Use all the characters for hashing!!!! */
-              {
-                UNSET_OPTION (option, DEFAULTCHARS);
-                SET_OPTION (option, ALLCHARS);
-              }
-            else 
-              {
-                char *key_pos;
-
-                for (key_pos = option.key_positions; (value = next ()) != EOS; key_pos++)
-                  if (value == BAD_VALUE) 
-                    report_error ("illegal key value or range, use 1,2,3-%d,'$' or '*'.\n%e%a", 
-                    (MAX_KEY_POS - 1),usage);
-                  else 
-                    *key_pos = value;;
-
-                *key_pos = EOS;
-
-                if (! (option.total_charset_size = (key_pos - option.key_positions))) 
-                  report_error ("no keys selected\n%e%a", usage);
-                else if (! key_sort (option.key_positions, option.total_charset_size))
-                  report_error ("duplicate keys selected\n%e%a", usage);
-
-                if (option.total_charset_size != 2 
-                    || (option.key_positions[0] != 1 || option.key_positions[1] != WORD_END))
-                  UNSET_OPTION (option, DEFAULTCHARS);
-              }
-            break;
-          }
-        case 'K':               /* Make this the keyname for the keyword component field. */
-          {
-            option.key_name = optarg;
-            break;
-          }
-        case 'l':               /* Create length table to avoid extra string compares. */
-          { 
-            SET_OPTION (option, LENTABLE);
-            break;
-          }
-        case 'n':               /* Don't include the length when computing hash function. */
-          { 
-            SET_OPTION (option, NOLENGTH);
-            break; 
-          }
-        case 'N':               /* Make generated lookup function name be optarg */
-          { 
-            option.function_name = optarg;
-            break;
-          }
-        case 'o':               /* Order input by frequency of key set occurrence. */
-          { 
-            SET_OPTION (option, ORDER);
-            break;
-          }   
-        case 'p':               /* Generated lookup function now a pointer instead of int. */
-          { 
-            SET_OPTION (option, POINTER);
-            break;
-          }
-        case 'r':               /* Utilize randomness to initialize the associated values table. */
-          { 
-            SET_OPTION (option, RANDOM);
-            if (option.initial_asso_value != 0)
-              report_error ("warning, -r option superceeds -i, disabling -i option and continuing\n");
-            break;
-          }
-        case 's':               /* Range of associated values, determines size of final table. */
-          { 
-            if ((option.size = atoi (optarg)) <= 0) 
-              report_error ("improper range argument %s\n%e%a", optarg, usage);
-            else if (option.size > 50) 
-              report_error ("%d is excessive, did you really mean this?! (type %n -h for help)\n", 
-              option.size);
-            break; 
-          }       
-        case 'S':               /* Generate switch statement output, rather than lookup table. */
-          { 
-            SET_OPTION (option, SWITCH);
-            if ((option.total_switches = atoi (optarg)) <= 0)
-              report_error ("number of switches %s must be a positive number\n%e%a", optarg, usage);
-            break;
-          }
-        case 't':               /* Enable the TYPE mode, allowing arbitrary user structures. */
-          { 
-            SET_OPTION (option, TYPE);
-            break;
-          }
-        case 'T':               /* Don't print structure definition. */
-          {
-            SET_OPTION (option, NOTYPE);
-            break;
-          }
-        case 'v':               /* Print out the version and quit. */
-          report_error ("%n: version %s\n%e%a\n", version_string, usage);
-        default: 
-          report_error ("%e%a", usage);
-        }
+			     usage);
+	    }
+	case 'H':		/* Sets the name for the hash function */
+	    {
+		option.hash_name = optarg;
+		break;
+	    }
+	case 'i':		/* Sets the initial value for the associated values array. */
+	    {
+		if ((option.initial_asso_value = atoi(optarg)) < 0)
+		    report_error
+			("initial value %d must be non-zero, ignoring and continuing\n",
+			 option.initial_asso_value);
+		if (OPTION_ENABLED(option, RANDOM))
+		    report_error
+			("warning, -r option superceeds -i, ignoring -i option and continuing\n");
+		break;
+	    }
+	case 'I':		/* Make the keyword lookup case-insensitive. */
+	    {
+		SET_OPTION(option, NOCASE);
+		break;
+	    }
+	case 'j':		/* Sets the jump value, must be odd for later algorithms. */
+	    {
+		if ((option.jump = atoi(optarg)) < 0)
+		    report_error
+			("jump value %d must be a positive number\n%e%a",
+			 option.jump, usage);
+		else if (option.jump && EVEN(option.jump))
+		    report_error
+			("jump value %d should be odd, adding 1 and continuing...\n",
+			 option.jump++);
+		break;
+	    }
+	case 'k':		/* Sets key positions used for hash function. */
+	    {
+		int BAD_VALUE = -1;
+		int value;
+
+		iterator_init(optarg, 1, MAX_KEY_POS - 1, WORD_END,
+			      BAD_VALUE, EOS);
+
+		if (*optarg == '*') {	/* Use all the characters for hashing!!!! */
+		    UNSET_OPTION(option, DEFAULTCHARS);
+		    SET_OPTION(option, ALLCHARS);
+		} else {
+		    char *key_pos;
+
+		    for (key_pos = option.key_positions;
+			 (value = next()) != EOS; key_pos++)
+			if (value == BAD_VALUE)
+			    report_error
+				("illegal key value or range, use 1,2,3-%d,'$' or '*'.\n%e%a",
+				 (MAX_KEY_POS - 1), usage);
+			else
+			    *key_pos = value;;
+
+		    *key_pos = EOS;
+
+		    if (!
+			(option.total_charset_size =
+			 (key_pos - option.key_positions)))
+			report_error("no keys selected\n%e%a", usage);
+		    else if (!key_sort
+			     (option.key_positions,
+			      option.total_charset_size))
+			report_error("duplicate keys selected\n%e%a",
+				     usage);
+
+		    if (option.total_charset_size != 2
+			|| (option.key_positions[0] != 1
+			    || option.key_positions[1] != WORD_END))
+			UNSET_OPTION(option, DEFAULTCHARS);
+		}
+		break;
+	    }
+	case 'K':		/* Make this the keyname for the keyword component field. */
+	    {
+		option.key_name = optarg;
+		break;
+	    }
+	case 'l':		/* Create length table to avoid extra string compares. */
+	    {
+		SET_OPTION(option, LENTABLE);
+		break;
+	    }
+	case 'n':		/* Don't include the length when computing hash function. */
+	    {
+		SET_OPTION(option, NOLENGTH);
+		break;
+	    }
+	case 'N':		/* Make generated lookup function name be optarg */
+	    {
+		option.function_name = optarg;
+		break;
+	    }
+	case 'o':		/* Order input by frequency of key set occurrence. */
+	    {
+		SET_OPTION(option, ORDER);
+		break;
+	    }
+	case 'p':		/* Generated lookup function now a pointer instead of int. */
+	    {
+		SET_OPTION(option, POINTER);
+		break;
+	    }
+	case 'r':		/* Utilize randomness to initialize the associated values table. */
+	    {
+		SET_OPTION(option, RANDOM);
+		if (option.initial_asso_value != 0)
+		    report_error
+			("warning, -r option superceeds -i, disabling -i option and continuing\n");
+		break;
+	    }
+	case 's':		/* Range of associated values, determines size of final table. */
+	    {
+		if ((option.size = atoi(optarg)) <= 0)
+		    report_error("improper range argument %s\n%e%a",
+				 optarg, usage);
+		else if (option.size > 50)
+		    report_error
+			("%d is excessive, did you really mean this?! (type %n -h for help)\n",
+			 option.size);
+		break;
+	    }
+	case 'S':		/* Generate switch statement output, rather than lookup table. */
+	    {
+		SET_OPTION(option, SWITCH);
+		if ((option.total_switches = atoi(optarg)) <= 0)
+		    report_error
+			("number of switches %s must be a positive number\n%e%a",
+			 optarg, usage);
+		break;
+	    }
+	case 't':		/* Enable the TYPE mode, allowing arbitrary user structures. */
+	    {
+		SET_OPTION(option, TYPE);
+		break;
+	    }
+	case 'T':		/* Don't print structure definition. */
+	    {
+		SET_OPTION(option, NOTYPE);
+		break;
+	    }
+	case 'v':		/* Print out the version and quit. */
+	    report_error("%n: version %s\n%e%a\n", version_string, usage);
+	default:
+	    report_error("%e%a", usage);
+	}
     }
 
-  if (argv[optind] && ! freopen (argv[optind], "r", stdin))
-    report_error ("unable to read key word file %s\n%e%a", argv[optind], usage);
-  
-  if (++optind < argc) 
-    report_error ("extra trailing arguments to %n\n%e%a", usage);
+    if (argv[optind] && !freopen(argv[optind], "r", stdin))
+	report_error("unable to read key word file %s\n%e%a", argv[optind],
+		     usage);
+
+    if (++optind < argc)
+	report_error("extra trailing arguments to %n\n%e%a", usage);
 }
 
 /* Output command-line Options. */
-void 
-print_options ()
-{ 
-  int i;
+void
+print_options()
+{
+    int i;
 
-  printf ("/* Command-line: ");
+    printf("/* Command-line: ");
 
-  for (i = 0; i < option.argument_count; i++) 
-    printf ("%s ", option.argument_vector[i]);
-   
-  printf (" */\n\n");
-}
+    for (i = 0; i < option.argument_count; i++)
+	printf("%s ", option.argument_vector[i]);
 
+    printf(" */\n\n");
+}
diff --git a/server/pgperf/options.h b/server/pgperf/options.h
index 9aa297c..539c7f0 100644
--- a/server/pgperf/options.h
+++ b/server/pgperf/options.h
@@ -35,28 +35,27 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 
 /* Enumerate the potential debugging Options. */
 
-enum option_type 
-{
-  DEBUG        = 01,            /* Enable debugging (prints diagnostics to Std_Err). */
-  ORDER        = 02,            /* Apply ordering heuristic to speed-up search time. */
-  ANSI         = 04,            /* Generate ANSI prototypes. */
-  ALLCHARS     = 010,           /* Use all characters in hash function. */
-  GNU          = 020,           /* Assume GNU extensions (primarily function inline). */
-  TYPE         = 040,           /* Handle user-defined type structured keyword input. */
-  RANDOM       = 0100,          /* Randomly initialize the associated values table. */
-  DEFAULTCHARS = 0200,          /* Make default char positions be 1,$ (end of keyword). */
-  SWITCH       = 0400,          /* Generate switch output to save space. */
-  POINTER      = 01000,         /* Have in_word_set function return pointer, not boolean. */
-  NOLENGTH     = 02000,         /* Don't include keyword length in hash computations. */
-  LENTABLE     = 04000,         /* Generate a length table for string comparison. */
-  DUP          = 010000,        /* Handle duplicate hash values for keywords. */
-  FAST         = 020000,        /* Generate the hash function ``fast.'' */
-  NOTYPE       = 040000,	      /* Don't include user-defined type definition
-                                   in output -- it's already defined elsewhere. */
-  COMP         = 0100000,       /* Generate strncmp rather than strcmp. */
-  GLOBAL       = 0200000,       /* Make the keyword table a global variable. */
-  CONST        = 0400000,       /* Make the generated tables readonly (const). */
-  NOCASE       = 01000000,	/* Make the keyword lookup case-insensitive. */
+enum option_type {
+    DEBUG = 01,			/* Enable debugging (prints diagnostics to Std_Err). */
+    ORDER = 02,			/* Apply ordering heuristic to speed-up search time. */
+    ANSI = 04,			/* Generate ANSI prototypes. */
+    ALLCHARS = 010,		/* Use all characters in hash function. */
+    GNU = 020,			/* Assume GNU extensions (primarily function inline). */
+    TYPE = 040,			/* Handle user-defined type structured keyword input. */
+    RANDOM = 0100,		/* Randomly initialize the associated values table. */
+    DEFAULTCHARS = 0200,	/* Make default char positions be 1,$ (end of keyword). */
+    SWITCH = 0400,		/* Generate switch output to save space. */
+    POINTER = 01000,		/* Have in_word_set function return pointer, not boolean. */
+    NOLENGTH = 02000,		/* Don't include keyword length in hash computations. */
+    LENTABLE = 04000,		/* Generate a length table for string comparison. */
+    DUP = 010000,		/* Handle duplicate hash values for keywords. */
+    FAST = 020000,		/* Generate the hash function ``fast.'' */
+    NOTYPE = 040000,		/* Don't include user-defined type definition
+				   in output -- it's already defined elsewhere. */
+    COMP = 0100000,		/* Generate strncmp rather than strcmp. */
+    GLOBAL = 0200000,		/* Make the keyword table a global variable. */
+    CONST = 0400000,		/* Make the generated tables readonly (const). */
+    NOCASE = 01000000,		/* Make the keyword lookup case-insensitive. */
 };
 
 /* Define some useful constants. */
@@ -65,13 +64,13 @@ enum option_type
 #define MAX_KEY_POS (128 - 1)
 
 /* Signals the start of a word. */
-#define WORD_START 1           
+#define WORD_START 1
 
 /* Signals the end of a word. */
-#define WORD_END 0             
+#define WORD_END 0
 
 /* Signals end of the key list. */
-#define EOS MAX_KEY_POS        
+#define EOS MAX_KEY_POS
 
 /* Returns TRUE if option O is enabled. */
 #define OPTION_ENABLED(OW,O) (OW.option_word & (int)O)
@@ -129,26 +128,25 @@ enum option_type
 
 /* Class manager for gperf program options. */
 
-typedef struct options
-{
-  int    option_word;           /* Holds the user-specified Options. */
-  int    total_charset_size;   /* Total number of distinct key_positions. */
-  int    size;                  /* Range of the hash table. */
-  int    key_pos;               /* Tracks current key position for Iterator. */
-  int    jump;                  /* Jump length when trying alternative values. */
-  int    initial_asso_value;    /* Initial value for asso_values table. */
-  int    argument_count;        /* Records count of command-line arguments. */
-  int    iterations;            /* Amount to iterate when a collision occurs. */
-  int    total_switches;        /* Number of switch statements to generate. */     
-  char **argument_vector;       /* Stores a pointer to command-line vector. */
-  char  *function_name;         /* Name used for generated lookup function. */
-  char  *key_name;              /* Name used for keyword key. */
-  char  *hash_name;             /* Name used for generated hash function. */
-  char  *delimiters;            /* Separates keywords from other attributes. */
-  char   key_positions[MAX_KEY_POS]; /* Contains user-specified key choices. */
+typedef struct options {
+    int option_word;		/* Holds the user-specified Options. */
+    int total_charset_size;	/* Total number of distinct key_positions. */
+    int size;			/* Range of the hash table. */
+    int key_pos;		/* Tracks current key position for Iterator. */
+    int jump;			/* Jump length when trying alternative values. */
+    int initial_asso_value;	/* Initial value for asso_values table. */
+    int argument_count;		/* Records count of command-line arguments. */
+    int iterations;		/* Amount to iterate when a collision occurs. */
+    int total_switches;		/* Number of switch statements to generate. */
+    char **argument_vector;	/* Stores a pointer to command-line vector. */
+    char *function_name;	/* Name used for generated lookup function. */
+    char *key_name;		/* Name used for keyword key. */
+    char *hash_name;		/* Name used for generated hash function. */
+    char *delimiters;		/* Separates keywords from other attributes. */
+    char key_positions[MAX_KEY_POS];	/* Contains user-specified key choices. */
 } OPTIONS;
 
-extern void    options_init P ((int argc, char *argv[]));
-extern void    options_destroy P ((void));
-extern OPTIONS option;       
-#endif /* _options_h */
+extern void options_init P((int argc, char *argv[]));
+extern void options_destroy P((void));
+extern OPTIONS option;
+#endif				/* _options_h */
diff --git a/server/pgperf/perfect.c b/server/pgperf/perfect.c
index a516c64..9652f95 100644
--- a/server/pgperf/perfect.c
+++ b/server/pgperf/perfect.c
@@ -30,10 +30,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 extern char *version_string;
 
 /* Counts occurrences of each key set character. */
-int occurrences[ALPHABET_SIZE]; 
+int occurrences[ALPHABET_SIZE];
 
 /* Value associated with each character. */
-int asso_values[ALPHABET_SIZE]; 
+int asso_values[ALPHABET_SIZE];
 
 /* Locally visible PERFECT object. */
 PERFECT perfect;
@@ -48,56 +48,51 @@ PERFECT perfect;
    though not as deterministic, of course! */
 
 void
-perfect_init ()
+perfect_init()
 {
-  int asso_value_max;
-  int len;
-
-  perfect.num_done = 1;
-  perfect.fewest_collisions = 0;
-  read_keys ();
-  if (OPTION_ENABLED (option, ORDER))
-    reorder ();
-  asso_value_max = GET_ASSO_MAX (option);
-  len            = keyword_list_length ();
-  asso_value_max = (asso_value_max ? asso_value_max * len : len);
-  SET_ASSO_MAX (option, POW (asso_value_max));
-  
-  if (OPTION_ENABLED (option, RANDOM))
-    {
-      int i;
-
-      srandom (time (0));
-      
-      for (i = 0; i < ALPHABET_SIZE; i++)
-        asso_values[i] = (random () & asso_value_max - 1);
+    int asso_value_max;
+    int len;
+
+    perfect.num_done = 1;
+    perfect.fewest_collisions = 0;
+    read_keys();
+    if (OPTION_ENABLED(option, ORDER))
+	reorder();
+    asso_value_max = GET_ASSO_MAX(option);
+    len = keyword_list_length();
+    asso_value_max = (asso_value_max ? asso_value_max * len : len);
+    SET_ASSO_MAX(option, POW(asso_value_max));
+
+    if (OPTION_ENABLED(option, RANDOM)) {
+	int i;
+
+	srandom(time(0));
+
+	for (i = 0; i < ALPHABET_SIZE; i++)
+	    asso_values[i] = (random() & asso_value_max - 1);
+    } else {
+	int asso_value = INITIAL_VALUE(option);
+	if (asso_value) {	/* Initialize array if user requests non-zero default. */
+	    int i;
+
+	    for (i = ALPHABET_SIZE - 1; i >= 0; i--)
+		asso_values[i] = asso_value & GET_ASSO_MAX(option) - 1;
+	}
     }
-  else
-    {
-      int asso_value = INITIAL_VALUE (option);
-      if (asso_value)           /* Initialize array if user requests non-zero default. */
-        {
-          int i;
-
-          for (i = ALPHABET_SIZE - 1; i >= 0; i--)
-            asso_values[i] = asso_value & GET_ASSO_MAX (option) - 1;
-        }
-    }
-  perfect.max_hash_value = max_key_length () + GET_ASSO_MAX (option) * 
-    GET_CHARSET_SIZE (option);
-  
-  printf ("/* C code produced by gperf version %s */\n", version_string);
-  print_options ();
-
-  if (OPTION_ENABLED (option, NOCASE))
-    printf ("#include <ctype.h>\n\n");
-
-  if (OPTION_ENABLED (option, DEBUG))
-    {
-      int i;
-      fprintf (stderr, "\nnumber of keys = %d\nmaximum associated value is %d\
-\nmaximum possible size of generated hash table is %d\n", 
-               len, asso_value_max, perfect.max_hash_value);
+    perfect.max_hash_value = max_key_length() + GET_ASSO_MAX(option) *
+	GET_CHARSET_SIZE(option);
+
+    printf("/* C code produced by gperf version %s */\n", version_string);
+    print_options();
+
+    if (OPTION_ENABLED(option, NOCASE))
+	printf("#include <ctype.h>\n\n");
+
+    if (OPTION_ENABLED(option, DEBUG)) {
+	int i;
+	fprintf(stderr, "\nnumber of keys = %d\nmaximum associated value is %d\
+\nmaximum possible size of generated hash table is %d\n",
+		len, asso_value_max, perfect.max_hash_value);
     }
 }
 
@@ -105,76 +100,76 @@ perfect_init ()
    (In a multiset, an element can occur multiple times). Precondition: both 
    set_1 and set_2 must be ordered. Returns the length of the combined set. */
 
-static int 
-compute_disjoint_union (set_1, set_2, set_3)
-     char *set_1;
-     char *set_2;
-     char *set_3;
+static int
+compute_disjoint_union(set_1, set_2, set_3)
+    char *set_1;
+    char *set_2;
+    char *set_3;
 {
-  char *base = set_3;
-  
-  while (*set_1 && *set_2)
-    if (*set_1 == *set_2)
-      set_1++, set_2++; 
-    else
-      {
-        *set_3 = *set_1 < *set_2 ? *set_1++ : *set_2++;
-        if (set_3 == base || *set_3 != *(set_3-1)) set_3++;
-      }
-   
-  while (*set_1)
-    {
-      *set_3 = *set_1++; 
-      if (set_3 == base || *set_3 != *(set_3-1)) set_3++;
+    char *base = set_3;
+
+    while (*set_1 && *set_2)
+	if (*set_1 == *set_2)
+	    set_1++, set_2++;
+	else {
+	    *set_3 = *set_1 < *set_2 ? *set_1++ : *set_2++;
+	    if (set_3 == base || *set_3 != *(set_3 - 1))
+		set_3++;
+	}
+
+    while (*set_1) {
+	*set_3 = *set_1++;
+	if (set_3 == base || *set_3 != *(set_3 - 1))
+	    set_3++;
     }
-   
-  while (*set_2)
-    {
-      *set_3 = *set_2++; 
-      if (set_3 == base || *set_3 != *(set_3-1)) set_3++;
+
+    while (*set_2) {
+	*set_3 = *set_2++;
+	if (set_3 == base || *set_3 != *(set_3 - 1))
+	    set_3++;
     }
-  *set_3 = '\0';
-  return set_3 - base;
+    *set_3 = '\0';
+    return set_3 - base;
 }
 
 /* Sort the UNION_SET in increasing frequency of occurrence.
    This speeds up later processing since we may assume the resulting
    set (Set_3, in this case), is ordered. Uses insertion sort, since
    the UNION_SET is typically short. */
-  
-static void 
-sort_set (union_set, len)
-     char *union_set;
-     int   len;
+
+static void
+sort_set(union_set, len)
+    char *union_set;
+    int len;
 {
-  int i, j;
-  
-  for (i = 0, j = len - 1; i < j; i++)
-    {
-      char curr, tmp;
-
-      for (curr = i+1, tmp = union_set[curr]; 
-           curr > 0 && occurrences[tmp] < occurrences[union_set[curr-1]]; 
-           curr--)
-        union_set[curr] = union_set[curr - 1];
-      
-      union_set[curr] = tmp;
+    int i, j;
+
+    for (i = 0, j = len - 1; i < j; i++) {
+	char curr, tmp;
+
+	for (curr = i + 1, tmp = union_set[curr];
+	     curr > 0
+	     && occurrences[tmp] < occurrences[union_set[curr - 1]];
+	     curr--)
+	    union_set[curr] = union_set[curr - 1];
+
+	union_set[curr] = tmp;
     }
 }
 
 /* Generate a key set's hash value. */
 
-static int 
-hash (key_node)
-     LIST_NODE *key_node;
-{                             
-  int   sum = OPTION_ENABLED (option, NOLENGTH) ? 0 : key_node->length;
-  char *ptr;
-
-  for (ptr = key_node->char_set; *ptr; ptr++)
-      sum += asso_values[*ptr];
-  
-  return key_node->hash_value = sum;
+static int
+hash(key_node)
+    LIST_NODE *key_node;
+{
+    int sum = OPTION_ENABLED(option, NOLENGTH) ? 0 : key_node->length;
+    char *ptr;
+
+    for (ptr = key_node->char_set; *ptr; ptr++)
+	sum += asso_values[*ptr];
+
+    return key_node->hash_value = sum;
 }
 
 /* Find out how associated value changes affect successfully hashed items.
@@ -183,92 +178,94 @@ hash (key_node)
    that all legal ASSO_VALUES are visited without repetition since
    GET_JUMP (option) was forced to be an odd value! */
 
-static bool 
-affects_prev (c, curr)
-     char c;
-     LIST_NODE *curr;
+static bool
+affects_prev(c, curr)
+    char c;
+    LIST_NODE *curr;
 {
-  int original_char = asso_values[c];
-  int i = !OPTION_ENABLED (option, FAST) ? GET_ASSO_MAX (option) : 
-    GET_ITERATIONS (option) == 0 ? key_list.list_len : GET_ITERATIONS (option);
-
-  /* Try all asso_values. */
-
-  while (--i >= 0)
-    { 
-      int        collisions = 0;
-      LIST_NODE *ptr;
-
-      asso_values[c] = asso_values[c] + (GET_JUMP (option) ? GET_JUMP (option) : random ())
-        & GET_ASSO_MAX (option) - 1;
-      bool_array_reset ();
-
-      /* See how this asso_value change affects previous keywords.  If
-         it does better than before we'll take it! */
-
-      for (ptr = key_list.head; 
-           !lookup (hash (ptr)) || ++collisions < perfect.fewest_collisions; 
-           ptr = ptr->next)
-        if (ptr == curr)
-          {
-            perfect.fewest_collisions = collisions;
-            return FALSE;        
-          }    
+    int original_char = asso_values[c];
+    int i = !OPTION_ENABLED(option, FAST) ? GET_ASSO_MAX(option) :
+	GET_ITERATIONS(option) ==
+	0 ? key_list.list_len : GET_ITERATIONS(option);
+
+    /* Try all asso_values. */
+
+    while (--i >= 0) {
+	int collisions = 0;
+	LIST_NODE *ptr;
+
+	asso_values[c] =
+	    asso_values[c] +
+	    (GET_JUMP(option) ? GET_JUMP(option) : random())
+	    & GET_ASSO_MAX(option) - 1;
+	bool_array_reset();
+
+	/* See how this asso_value change affects previous keywords.  If
+	   it does better than before we'll take it! */
+
+	for (ptr = key_list.head;
+	     !lookup(hash(ptr))
+	     || ++collisions < perfect.fewest_collisions; ptr = ptr->next)
+	    if (ptr == curr) {
+		perfect.fewest_collisions = collisions;
+		return FALSE;
+	    }
     }
-  
-  asso_values[c] = original_char; /* Restore original values, no more tries. */
-  return TRUE; /* If we're this far it's time to try the next character.... */
+
+    asso_values[c] = original_char;	/* Restore original values, no more tries. */
+    return TRUE;		/* If we're this far it's time to try the next character.... */
 }
 
 /* Change a character value, try least-used characters first. */
 
-static void 
-change (prior, curr)
-     LIST_NODE *prior;
-     LIST_NODE *curr;
+static void
+change(prior, curr)
+    LIST_NODE *prior;
+    LIST_NODE *curr;
 {
-  char        *xmalloc ();
-  static char *union_set = 0;
-  char        *temp;
-  LIST_NODE   *ptr;
-
-  if (!union_set)
-    union_set = xmalloc (2 * GET_CHARSET_SIZE (option) + 1);
-
-  if (OPTION_ENABLED (option, DEBUG)) /* Very useful for debugging. */
-    {
-      fprintf (stderr, "collision on keyword #%d, prior=\"%s\", curr=\"%s\", hash=%d\n",
-               perfect.num_done, prior->key, curr->key, curr->hash_value);
-      fflush (stderr);
+    char *xmalloc();
+    static char *union_set = 0;
+    char *temp;
+    LIST_NODE *ptr;
+
+    if (!union_set)
+	union_set = xmalloc(2 * GET_CHARSET_SIZE(option) + 1);
+
+    if (OPTION_ENABLED(option, DEBUG)) {	/* Very useful for debugging. */
+	fprintf(stderr,
+		"collision on keyword #%d, prior=\"%s\", curr=\"%s\", hash=%d\n",
+		perfect.num_done, prior->key, curr->key, curr->hash_value);
+	fflush(stderr);
     }
-  sort_set (union_set, compute_disjoint_union (prior->char_set, curr->char_set, union_set));
-  
-  /* Try changing some values, if change doesn't alter other values continue normal action. */
-  
-  perfect.fewest_collisions++;
-  
-  for (temp = union_set; *temp; temp++)
-    if (!affects_prev (*temp, curr))
-      {
-        if (OPTION_ENABLED (option, DEBUG))
-          {
-            fprintf (stderr, "- resolved by changing asso_value['%c'] (char #%d) to %d\n", 
-                     *temp, temp - union_set + 1, asso_values[*temp]);
-            fflush (stderr);
-          }
-        return; /* Good, doesn't affect previous hash values, we'll take it. */
-      }
-
-  for (ptr = key_list.head; ptr != curr; ptr = ptr->next)
-    hash (ptr);
-
-  hash (curr);
-
-  if (OPTION_ENABLED (option, DEBUG))
-    {
-      fprintf (stderr, "** collision not resolved, %d duplicates remain, continuing...\n", 
-               perfect.fewest_collisions); 
-      fflush (stderr);
+    sort_set(union_set,
+	     compute_disjoint_union(prior->char_set, curr->char_set,
+				    union_set));
+
+    /* Try changing some values, if change doesn't alter other values continue normal action. */
+
+    perfect.fewest_collisions++;
+
+    for (temp = union_set; *temp; temp++)
+	if (!affects_prev(*temp, curr)) {
+	    if (OPTION_ENABLED(option, DEBUG)) {
+		fprintf(stderr,
+			"- resolved by changing asso_value['%c'] (char #%d) to %d\n",
+			*temp, temp - union_set + 1, asso_values[*temp]);
+		fflush(stderr);
+	    }
+	    return;		/* Good, doesn't affect previous hash values, we'll take it. */
+	}
+
+    for (ptr = key_list.head; ptr != curr; ptr = ptr->next)
+	hash(ptr);
+
+    hash(curr);
+
+    if (OPTION_ENABLED(option, DEBUG)) {
+	fprintf(stderr,
+		"** collision not resolved, %d duplicates remain, continuing...\n",
+		perfect.fewest_collisions);
+	fflush(stderr);
     }
 }
 
@@ -284,70 +281,67 @@ change (prior, curr)
    exponential in the number of keys. */
 
 int
-perfect_generate ()
+perfect_generate()
 {
-  LIST_NODE *curr;
-  bool_array_init (perfect.max_hash_value);
-  
-  for (curr = key_list.head; curr; curr = curr->next)
-    {
-      LIST_NODE *ptr;
-      hash (curr);
-      
-      for (ptr = key_list.head; ptr != curr; ptr = ptr->next)
-        if (ptr->hash_value == curr->hash_value)
-          {
-            change (ptr, curr);
-            break;
-          }
-      perfect.num_done++;
-    } 
-  
-
-  /* Make one final check, just to make sure nothing weird happened.... */
-  bool_array_reset ();
-
-  for (curr = key_list.head; curr; curr = curr->next)
-    if (lookup (hash (curr)))
-      if (OPTION_ENABLED (option, DUP)) /* We'll try to deal with this later..... */
-        break;
-      else /* Yow, big problems.  we're outta here! */
-        { 
-          report_error ("\nInternal error, duplicate value %d:\n\
-try options -D or -r, or use new key positions.\n\n", 
-                        hash (curr));
-          return 1;
-        }
-
-  bool_array_destroy ();
-
-  /* First sorts the key word list by hash value, and the outputs the
-     list to the proper ostream. The generated hash table code is only 
-     output if the early stage of processing turned out O.K. */
-
-  sort ();
-  print_output ();
-  return 0;
+    LIST_NODE *curr;
+    bool_array_init(perfect.max_hash_value);
+
+    for (curr = key_list.head; curr; curr = curr->next) {
+	LIST_NODE *ptr;
+	hash(curr);
+
+	for (ptr = key_list.head; ptr != curr; ptr = ptr->next)
+	    if (ptr->hash_value == curr->hash_value) {
+		change(ptr, curr);
+		break;
+	    }
+	perfect.num_done++;
+    }
+
+
+    /* Make one final check, just to make sure nothing weird happened.... */
+    bool_array_reset();
+
+    for (curr = key_list.head; curr; curr = curr->next)
+	if (lookup(hash(curr)))
+	    if (OPTION_ENABLED(option, DUP))	/* We'll try to deal with this later..... */
+		break;
+	    else {		/* Yow, big problems.  we're outta here! */
+
+		report_error("\nInternal error, duplicate value %d:\n\
+try options -D or -r, or use new key positions.\n\n", hash(curr));
+		return 1;
+	    }
+
+    bool_array_destroy();
+
+    /* First sorts the key word list by hash value, and the outputs the
+       list to the proper ostream. The generated hash table code is only 
+       output if the early stage of processing turned out O.K. */
+
+    sort();
+    print_output();
+    return 0;
 }
 
 /* Prints out some diagnostics upon completion. */
 
-void 
-perfect_destroy ()
-{                             
-  if (OPTION_ENABLED (option, DEBUG))
-    {
-      int i;
-
-      fprintf (stderr, "\ndumping occurrence and associated values tables\n");
-      
-      for (i = 0; i < ALPHABET_SIZE; i++)
-        if (occurrences[i])
-          fprintf (stderr, "asso_values[%c] = %3d, occurrences[%c] = %3d\n",
-                   i, asso_values[i], i, occurrences[i]);
-      
-      fprintf (stderr, "end table dumping\n");
-      
+void
+perfect_destroy()
+{
+    if (OPTION_ENABLED(option, DEBUG)) {
+	int i;
+
+	fprintf(stderr,
+		"\ndumping occurrence and associated values tables\n");
+
+	for (i = 0; i < ALPHABET_SIZE; i++)
+	    if (occurrences[i])
+		fprintf(stderr,
+			"asso_values[%c] = %3d, occurrences[%c] = %3d\n",
+			i, asso_values[i], i, occurrences[i]);
+
+	fprintf(stderr, "end table dumping\n");
+
     }
 }
-
diff --git a/server/pgperf/perfect.h b/server/pgperf/perfect.h
index c5b9443..eb99da2 100644
--- a/server/pgperf/perfect.h
+++ b/server/pgperf/perfect.h
@@ -27,19 +27,16 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 #include "keylist.h"
 #include "boolarray.h"
 
-typedef struct perfect
-{
-  KEY_LIST   list;              /* List of key words provided by the user. */
-  BOOL_ARRAY duplicate;         /* Speeds up check for redundant hash values. */
-  int        max_hash_value;    /* Maximum possible hash value. */
-  int        fewest_collisions; /* Records fewest # of collisions for asso value. */
-  int        num_done;          /* Number of keywords processed without a collision. */
+typedef struct perfect {
+    KEY_LIST list;		/* List of key words provided by the user. */
+    BOOL_ARRAY duplicate;	/* Speeds up check for redundant hash values. */
+    int max_hash_value;		/* Maximum possible hash value. */
+    int fewest_collisions;	/* Records fewest # of collisions for asso value. */
+    int num_done;		/* Number of keywords processed without a collision. */
 } PERFECT;
 
-extern void perfect_init P ((void));
-extern void perfect_destroy P ((void));
-extern int  perfect_generate P ((void));
-extern void perfect_print P ((void));
-#endif /* _perfect_h */
-
-
+extern void perfect_init P((void));
+extern void perfect_destroy P((void));
+extern int perfect_generate P((void));
+extern void perfect_print P((void));
+#endif				/* _perfect_h */
diff --git a/server/pgperf/prototype.h b/server/pgperf/prototype.h
index a6077b6..e8b6f0b 100644
--- a/server/pgperf/prototype.h
+++ b/server/pgperf/prototype.h
@@ -12,4 +12,4 @@ typedef char bool;
 
 #define ODD(X) ((X) & 1)
 #define EVEN(X) (!((X) & 1))
-#endif /* _prototype_h */
+#endif				/* _prototype_h */
diff --git a/server/pgperf/readline.c b/server/pgperf/readline.c
index 19ac5e5..9e1978e 100644
--- a/server/pgperf/readline.c
+++ b/server/pgperf/readline.c
@@ -28,60 +28,52 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 /* Recursively fills up the buffer. */
 
 static char *
-readln_aux (chunks) 
-     int chunks;
+readln_aux(chunks)
+    int chunks;
 {
-  char *buffered_malloc ();
-  char buf[CHUNK_SIZE];
-  register char *bufptr = buf;
-  register char *ptr;
-  int c;
-
-  while ((c = getchar ()) != EOF && c != '\n') /* fill the current buffer */
-    {
-      *bufptr++ = c;
-      if (bufptr - buf >= CHUNK_SIZE) /* prepend remainder to ptr buffer */
-        {
-          if (ptr = readln_aux (chunks + 1))
-
-            for (; bufptr != buf; *--ptr = *--bufptr);
-
-          return ptr;
-        }
+    char *buffered_malloc();
+    char buf[CHUNK_SIZE];
+    register char *bufptr = buf;
+    register char *ptr;
+    int c;
+
+    while ((c = getchar()) != EOF && c != '\n') {	/* fill the current buffer */
+	*bufptr++ = c;
+	if (bufptr - buf >= CHUNK_SIZE) {	/* prepend remainder to ptr buffer */
+	    if (ptr = readln_aux(chunks + 1))
+
+		for (; bufptr != buf; *--ptr = *--bufptr);
+
+	    return ptr;
+	}
     }
 
-  if (c == EOF && bufptr == buf)
-    return NULL;
+    if (c == EOF && bufptr == buf)
+	return NULL;
 
-  c = (chunks * CHUNK_SIZE + bufptr - buf) + 1;
+    c = (chunks * CHUNK_SIZE + bufptr - buf) + 1;
 
-  if (ptr = buffered_malloc (c))
-    {
+    if (ptr = buffered_malloc(c)) {
 
-      for (*(ptr += (c - 1)) = '\0'; bufptr != buf; *--ptr = *--bufptr)
-        ;
+	for (*(ptr += (c - 1)) = '\0'; bufptr != buf; *--ptr = *--bufptr);
 
-      return ptr;
-    } 
-  else 
-    return NULL;
+	return ptr;
+    } else
+	return NULL;
 }
 
 /* Returns the ``next'' line, ignoring comments beginning with '#'. */
 
-char *read_line () 
+char *
+read_line()
 {
-  int c;
-  if ((c = getchar ()) == '#')
-    {
-      while ((c = getchar ()) != '\n' && c != EOF)
-        ;
-
-      return c != EOF ? read_line () : NULL;
-    }
-  else
-    {
-      ungetc (c, stdin);
-      return readln_aux (0);
+    int c;
+    if ((c = getchar()) == '#') {
+	while ((c = getchar()) != '\n' && c != EOF);
+
+	return c != EOF ? read_line() : NULL;
+    } else {
+	ungetc(c, stdin);
+	return readln_aux(0);
     }
 }
diff --git a/server/pgperf/readline.h b/server/pgperf/readline.h
index 13164d9..3b266ed 100644
--- a/server/pgperf/readline.h
+++ b/server/pgperf/readline.h
@@ -26,6 +26,5 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 #define _readline_h
 #include "prototype.h"
 
-extern char *read_line P ((void));
-#endif /* _readline_h */
-
+extern char *read_line P((void));
+#endif				/* _readline_h */
diff --git a/server/pgperf/stderr.c b/server/pgperf/stderr.c
index 3f00dd5..e5c96ff 100644
--- a/server/pgperf/stderr.c
+++ b/server/pgperf/stderr.c
@@ -27,11 +27,11 @@ static char *program_name;
 
 /* Sets name of program. */
 
-void 
-set_program_name (prog_name)
-     char *prog_name;
-{ 
-  program_name = prog_name;
+void
+set_program_name(prog_name)
+    char *prog_name;
+{
+    program_name = prog_name;
 }
 
 /* Valid Options (prefixed by '%', as in printf format strings) include:
@@ -45,46 +45,60 @@ set_program_name (prog_name)
    's': print out a character string
    '%': print out a single percent sign, '%' */
 
-void 
-report_error (va_alist) 
-     va_dcl
+void
+report_error(va_alist)
+    va_dcl
 {
-  extern int errno, sys_nerr;
-  extern char *sys_errlist[];
-  typedef void (*PTF)();
-	typedef char *CHARP;
-  va_list argp;
-  int     abort = 0;
-  char   *format;
+    extern int errno, sys_nerr;
+    extern char *sys_errlist[];
+    typedef void (*PTF) ();
+    typedef char *CHARP;
+    va_list argp;
+    int abort = 0;
+    char *format;
 
-  va_start (argp);
+    va_start(argp);
 
-  for (format = va_arg (argp, char *); *format; format++) 
-    {
-      if (*format != '%') 
-        putc (*format, stderr);
-      else 
-        {
-          switch(*++format) 
-            {
-            case '%' : putc ('%', stderr); break;
-            case 'a' : abort = 1; break;
-            case 'c' : putc (va_arg (argp, int), stderr); break;
-            case 'd' : fprintf (stderr, "%d", va_arg (argp, int)); break;
-            case 'e' : (*va_arg (argp, PTF))(); break;
-            case 'f' : fprintf (stderr, "%g", va_arg (argp, double)); break;
-            case 'n' : fputs (program_name ? program_name : "error", stderr); break;
-            case 'p' : 
-              if (errno < sys_nerr) 
-                fprintf (stderr, "%s: %s", va_arg (argp, CHARP), sys_errlist[errno]);
-              else 
-                fprintf (stderr, "<unknown error> %d", errno);
-              break;
-            case 's' : fputs (va_arg (argp, CHARP), stderr); break;
-            }
-        }
-      if (abort) 
-        exit (1);
+    for (format = va_arg(argp, char *); *format; format++) {
+	if (*format != '%')
+	    putc(*format, stderr);
+	else {
+	    switch (*++format) {
+	    case '%':
+		putc('%', stderr);
+		break;
+	    case 'a':
+		abort = 1;
+		break;
+	    case 'c':
+		putc(va_arg(argp, int), stderr);
+		break;
+	    case 'd':
+		fprintf(stderr, "%d", va_arg(argp, int));
+		break;
+	    case 'e':
+		(*va_arg(argp, PTF)) ();
+		break;
+	    case 'f':
+		fprintf(stderr, "%g", va_arg(argp, double));
+		break;
+	    case 'n':
+		fputs(program_name ? program_name : "error", stderr);
+		break;
+	    case 'p':
+		if (errno < sys_nerr)
+		    fprintf(stderr, "%s: %s", va_arg(argp, CHARP),
+			    sys_errlist[errno]);
+		else
+		    fprintf(stderr, "<unknown error> %d", errno);
+		break;
+	    case 's':
+		fputs(va_arg(argp, CHARP), stderr);
+		break;
+	    }
+	}
+	if (abort)
+	    exit(1);
     }
-  va_end (argp);
+    va_end(argp);
 }
diff --git a/server/pgperf/stderr.h b/server/pgperf/stderr.h
index a94255e..10e4b0d 100644
--- a/server/pgperf/stderr.h
+++ b/server/pgperf/stderr.h
@@ -24,6 +24,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 #include "prototype.h"
 #include <varargs.h>
 
-extern void set_program_name P ((char *prog_name));
-extern void report_error ();
-#endif /* _stderr_h */
+extern void set_program_name P((char *prog_name));
+extern void report_error();
+#endif				/* _stderr_h */
diff --git a/server/pgperf/xmalloc.c b/server/pgperf/xmalloc.c
index 09cc022..39ce48d 100644
--- a/server/pgperf/xmalloc.c
+++ b/server/pgperf/xmalloc.c
@@ -24,23 +24,25 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 /* Grabs SIZE bytes of dynamic memory or dies trying! */
 
 char *
-xmalloc (size)
-     int size;
+xmalloc(size)
+    int size;
 {
-  char *malloc ();
-  char *temp = malloc (size);
-  
-  if (temp == 0)
-    {
-      fprintf (stderr, "out of virtual memory\n");
-      exit (1);
+    char *malloc();
+    char *temp = malloc(size);
+
+    if (temp == 0) {
+	fprintf(stderr, "out of virtual memory\n");
+	exit(1);
     }
-  return temp;
+    return temp;
 }
 
 /* Determine default alignment.  If your C compiler does not
    like this then try something like #define DEFAULT_ALIGNMENT 8. */
-struct fooalign {char x; double d;};
+struct fooalign {
+    char x;
+    double d;
+};
 #define ALIGNMENT ((char *)&((struct fooalign *) 0)->d - (char *)0)
 
 /* Provide an abstraction that cuts down on the number of
@@ -48,31 +50,30 @@ struct fooalign {char x; double d;};
    items are allocated. */
 
 char *
-buffered_malloc (size)
-     int size;
+buffered_malloc(size)
+    int size;
 {
-  char *temp;
-  static char *buf_start = 0;   /* Large array used to reduce calls to NEW. */
-  static char *buf_end = 0;     /* Indicates end of BUF_START. */
-  static int   buf_size = 4 * BUFSIZ; /* Size of buffer pointed to by BUF_START. */
+    char *temp;
+    static char *buf_start = 0;	/* Large array used to reduce calls to NEW. */
+    static char *buf_end = 0;	/* Indicates end of BUF_START. */
+    static int buf_size = 4 * BUFSIZ;	/* Size of buffer pointed to by BUF_START. */
+
+    /* Align this on correct boundaries, just to be safe... */
+    size = ((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;
 
-  /* Align this on correct boundaries, just to be safe... */
-  size = ((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;
+    /* If we are about to overflow our buffer we'll just grab another
+       chunk of memory.  Since we never free the original memory it
+       doesn't matter that no one points to the beginning of that
+       chunk.  Furthermore, as a heuristic, we double the
+       size of the new buffer! */
 
-  /* If we are about to overflow our buffer we'll just grab another
-     chunk of memory.  Since we never free the original memory it
-     doesn't matter that no one points to the beginning of that
-     chunk.  Furthermore, as a heuristic, we double the
-     size of the new buffer! */
-  
-  if (buf_start + size >= buf_end)
-    {
-      buf_size = buf_size * 2 > size ? buf_size * 2 : size;
-      buf_start = xmalloc (buf_size);
-      buf_end = buf_start + buf_size;
+    if (buf_start + size >= buf_end) {
+	buf_size = buf_size * 2 > size ? buf_size * 2 : size;
+	buf_start = xmalloc(buf_size);
+	buf_end = buf_start + buf_size;
     }
 
-  temp = buf_start;
-  buf_start += size;
-  return temp;
+    temp = buf_start;
+    buf_start += size;
+    return temp;
 }
diff --git a/server/program.c b/server/program.c
index c416527..6408f20 100644
--- a/server/program.c
+++ b/server/program.c
@@ -112,7 +112,8 @@ free_program(Program * p)
     }
 }
 
-char rcsid_program[] = "$Id: program.c,v 1.6 2006-09-07 00:55:02 bjj Exp $";
+char rcsid_program[] =
+    "$Id: program.c,v 1.6 2006-09-07 00:55:02 bjj Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/program.h b/server/program.h
index b66c555..73e377a 100644
--- a/server/program.h
+++ b/server/program.h
@@ -24,8 +24,8 @@
 typedef unsigned char Byte;
 
 typedef struct {
-    Byte numbytes_label, numbytes_literal, numbytes_fork, numbytes_var_name,
-     numbytes_stack;
+    Byte numbytes_label, numbytes_literal, numbytes_fork,
+	numbytes_var_name, numbytes_stack;
     Byte *vector;
     unsigned size;
     unsigned max_stack;
diff --git a/server/property.c b/server/property.c
index 15322f2..6409cc8 100644
--- a/server/property.c
+++ b/server/property.c
@@ -102,7 +102,8 @@ bf_prop_info(Var arglist, Byte next, void *vdata, Objid progr)
 }
 
 static enum error
-validate_prop_info(Var v, Objid * owner, unsigned *flags, const char **name)
+validate_prop_info(Var v, Objid * owner, unsigned *flags,
+		   const char **name)
 {
     const char *s;
     int len = (v.type == TYPE_LIST ? v.v.list[0].v.num : 0);
@@ -300,7 +301,8 @@ bf_is_clear_prop(Var arglist, Byte next, void *vdata, Objid progr)
 	    e = E_PERM;
 	else {
 	    r.type = TYPE_INT;
-	    r.v.num = (!h.built_in && db_property_value(h).type == TYPE_CLEAR);
+	    r.v.num = (!h.built_in
+		       && db_property_value(h).type == TYPE_CLEAR);
 	    e = E_NONE;
 	}
     }
@@ -330,7 +332,8 @@ register_property(void)
 			     TYPE_OBJ, TYPE_STR);
 }
 
-char rcsid_property[] = "$Id: property.c,v 1.4 2008-08-20 04:25:23 bjj Exp $";
+char rcsid_property[] =
+    "$Id: property.c,v 1.4 2008-08-20 04:25:23 bjj Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/ref_count.c b/server/ref_count.c
index 64cca1d..098d7c7 100644
--- a/server/ref_count.c
+++ b/server/ref_count.c
@@ -185,7 +185,8 @@ addref(const void *p)
 	reftab_entry **new_table;
 	table_power++;
 	table_size *= 2;
-	new_table = mymalloc(table_size * sizeof(reftab_entry *), M_REF_TABLE);
+	new_table =
+	    mymalloc(table_size * sizeof(reftab_entry *), M_REF_TABLE);
 	for (index = 0; index < table_size; index++)
 	    new_table[index] = 0;
 	ref_table = rehash(ref_table, new_table);	/* frees old table */
@@ -208,7 +209,8 @@ delref(const void *p)
 }
 #endif
 
-char rcsid_ref_count[] = "$Id: ref_count.c,v 1.4 1998-12-14 13:18:54 nop Exp $";
+char rcsid_ref_count[] =
+    "$Id: ref_count.c,v 1.4 1998-12-14 13:18:54 nop Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/regexpr.c b/server/regexpr.c
index 33e0ce1..6dd0f3c 100644
--- a/server/regexpr.c
+++ b/server/regexpr.c
@@ -224,7 +224,7 @@ re_compile_initialize()
     regexp_ansi_sequences = (regexp_syntax & RE_ANSI_HEX) != 0;
 }
 
-int 
+int
 re_set_syntax(int syntax)
 {
     int ret;
@@ -258,7 +258,8 @@ re_compile_pattern(char *regex, int size, regexp_t bufp)
     int future_jumps[MAX_NESTING], num_jumps;
     unsigned char ch = 0;	/* silence warnings */
     char *pattern, *translate;
-    int next_register, paren_depth, num_open_registers, open_registers[RE_NREGS];
+    int next_register, paren_depth, num_open_registers,
+	open_registers[RE_NREGS];
     int beginning_context;
 
 #define NEXTCHAR(var)			\
@@ -408,24 +409,26 @@ re_compile_pattern(char *regex, int size, regexp_t bufp)
 	if (pos >= size)
 	    op = Rend;
 	else {
-            //NEXTCHAR(ch);
+	    //NEXTCHAR(ch);
 
-            do {
-              if (pos >= size) goto ends_prematurely;
-              (ch) = regex[pos];
-              pos++;
-            } while (0);
+	    do {
+		if (pos >= size)
+		    goto ends_prematurely;
+		(ch) = regex[pos];
+		pos++;
+	    } while (0);
 
 	    if (translate)
 		ch = translate[(unsigned char) ch];
 	    op = regexp_plain_ops[(unsigned char) ch];
 	    if (op == Rquote) {
-                //NEXTCHAR(ch);
-              do {
-                if (pos >= size) goto ends_prematurely;
-                (ch) = regex[pos];
-                pos++;
-              } while (0);
+		//NEXTCHAR(ch);
+		do {
+		    if (pos >= size)
+			goto ends_prematurely;
+		    (ch) = regex[pos];
+		    pos++;
+		} while (0);
 		op = regexp_quoted_ops[(unsigned char) ch];
 		if (op == Rnormal && regexp_ansi_sequences)
 		    ANSI_TRANSLATE(ch);
@@ -454,7 +457,14 @@ re_compile_pattern(char *regex, int size, regexp_t bufp)
 	  store_opcode_and_arg:	/* opcode & ch must be set */
 	    SET_LEVEL_START;
 	    //ALLOC(2);
-            do { if (pattern_offset+(2) > alloc) { alloc += 256 + (2); pattern = (char *) realloc(pattern, alloc); if (!pattern) goto out_of_memory; } } while (0);
+	    do {
+		if (pattern_offset + (2) > alloc) {
+		    alloc += 256 + (2);
+		    pattern = (char *) realloc(pattern, alloc);
+		    if (!pattern)
+			goto out_of_memory;
+		}
+	    } while (0);
 	    STORE(opcode);
 	    STORE(ch);
 	    break;
@@ -463,7 +473,14 @@ re_compile_pattern(char *regex, int size, regexp_t bufp)
 	  store_opcode:
 	    SET_LEVEL_START;
 	    //ALLOC(1);
-            do { if (pattern_offset+(1) > alloc) { alloc += 256 + (1); pattern = (char *) realloc(pattern, alloc); if (!pattern) goto out_of_memory; } } while (0);
+	    do {
+		if (pattern_offset + (1) > alloc) {
+		    alloc += 256 + (1);
+		    pattern = (char *) realloc(pattern, alloc);
+		    if (!pattern)
+			goto out_of_memory;
+		}
+	    } while (0);
 
 	    STORE(opcode);
 	    break;
@@ -508,7 +525,14 @@ re_compile_pattern(char *regex, int size, regexp_t bufp)
 	    if (CURRENT_LEVEL_START == pattern_offset)
 		break;		/* ignore empty patterns for ? */
 	    //ALLOC(3);
-            do { if (pattern_offset+(3) > alloc) { alloc += 256 + (3); pattern = (char *) realloc(pattern, alloc); if (!pattern) goto out_of_memory; } } while (0);
+	    do {
+		if (pattern_offset + (3) > alloc) {
+		    alloc += 256 + (3);
+		    pattern = (char *) realloc(pattern, alloc);
+		    if (!pattern)
+			goto out_of_memory;
+		}
+	    } while (0);
 	    INSERT_JUMP(CURRENT_LEVEL_START, Cfailure_jump,
 			pattern_offset + 3);
 	    break;
@@ -523,7 +547,14 @@ re_compile_pattern(char *regex, int size, regexp_t bufp)
 	    if (CURRENT_LEVEL_START == pattern_offset)
 		break;		/* ignore empty patterns for + and * */
 	    //ALLOC(9);
-            do { if (pattern_offset+(9) > alloc) { alloc += 256 + (9); pattern = (char *) realloc(pattern, alloc); if (!pattern) goto out_of_memory; } } while (0);
+	    do {
+		if (pattern_offset + (9) > alloc) {
+		    alloc += 256 + (9);
+		    pattern = (char *) realloc(pattern, alloc);
+		    if (!pattern)
+			goto out_of_memory;
+		}
+	    } while (0);
 	    INSERT_JUMP(CURRENT_LEVEL_START, Cfailure_jump,
 			pattern_offset + 6);
 	    INSERT_JUMP(pattern_offset, Cstar_jump, CURRENT_LEVEL_START);
@@ -532,8 +563,15 @@ re_compile_pattern(char *regex, int size, regexp_t bufp)
 			    CURRENT_LEVEL_START + 6);
 	    break;
 	case Ror:
-            //ALLOC(6);
-          do { if (pattern_offset+(6) > alloc) { alloc += 256 + (6); pattern = (char *) realloc(pattern, alloc); if (!pattern) goto out_of_memory; } } while (0);
+	    //ALLOC(6);
+	    do {
+		if (pattern_offset + (6) > alloc) {
+		    alloc += 256 + (6);
+		    pattern = (char *) realloc(pattern, alloc);
+		    if (!pattern)
+			goto out_of_memory;
+		}
+	    } while (0);
 	    INSERT_JUMP(CURRENT_LEVEL_START, Cfailure_jump,
 			pattern_offset + 6);
 	    if (num_jumps >= MAX_NESTING)
@@ -549,7 +587,14 @@ re_compile_pattern(char *regex, int size, regexp_t bufp)
 	    if (next_register < RE_NREGS) {
 		bufp->uses_registers = 1;
 		//ALLOC(2);
-                do { if (pattern_offset+(2) > alloc) { alloc += 256 + (2); pattern = (char *) realloc(pattern, alloc); if (!pattern) goto out_of_memory; } } while (0);
+		do {
+		    if (pattern_offset + (2) > alloc) {
+			alloc += 256 + (2);
+			pattern = (char *) realloc(pattern, alloc);
+			if (!pattern)
+			    goto out_of_memory;
+		    }
+		} while (0);
 		STORE(Cstart_memory);
 		STORE(next_register);
 		open_registers[num_open_registers++] = next_register;
@@ -569,7 +614,14 @@ re_compile_pattern(char *regex, int size, regexp_t bufp)
 	    if (paren_depth < num_open_registers) {
 		bufp->uses_registers = 1;
 		//ALLOC(2);
-                do { if (pattern_offset+(2) > alloc) { alloc += 256 + (2); pattern = (char *) realloc(pattern, alloc); if (!pattern) goto out_of_memory; } } while (0);
+		do {
+		    if (pattern_offset + (2) > alloc) {
+			alloc += 256 + (2);
+			pattern = (char *) realloc(pattern, alloc);
+			if (!pattern)
+			    goto out_of_memory;
+		    }
+		} while (0);
 		STORE(Cend_memory);
 		num_open_registers--;
 		STORE(open_registers[num_open_registers]);
@@ -602,7 +654,14 @@ re_compile_pattern(char *regex, int size, regexp_t bufp)
 
 		SET_LEVEL_START;
 		//ALLOC(1 + 256 / 8);
-                do { if (pattern_offset+(1 + 256 / 8) > alloc) { alloc += 256 + (1 + 256 / 8); pattern = (char *) realloc(pattern, alloc); if (!pattern) goto out_of_memory; } } while (0);
+		do {
+		    if (pattern_offset + (1 + 256 / 8) > alloc) {
+			alloc += 256 + (1 + 256 / 8);
+			pattern = (char *) realloc(pattern, alloc);
+			if (!pattern)
+			    goto out_of_memory;
+		    }
+		} while (0);
 		STORE(Cset);
 		offset = pattern_offset;
 		for (a = 0; a < 256 / 8; a++)
@@ -703,7 +762,14 @@ re_compile_pattern(char *regex, int size, regexp_t bufp)
 	goto parenthesis_error;
     assert(num_jumps == 0);
     //ALLOC(1);
-    do { if (pattern_offset+(1) > alloc) { alloc += 256 + (1); pattern = (char *) realloc(pattern, alloc); if (!pattern) goto out_of_memory; } } while (0);
+    do {
+	if (pattern_offset + (1) > alloc) {
+	    alloc += 256 + (1);
+	    pattern = (char *) realloc(pattern, alloc);
+	    if (!pattern)
+		goto out_of_memory;
+	}
+    } while (0);
     STORE(Cend);
     SET_FIELDS;
     return NULL;
@@ -736,6 +802,7 @@ re_compile_pattern(char *regex, int size, regexp_t bufp)
     SET_FIELDS;
     return "Regular expression too complex";
 }
+
 #undef CHARAT
 #undef NEXTCHAR
 #undef GETHEX
@@ -753,7 +820,8 @@ re_compile_pattern(char *regex, int size, regexp_t bufp)
 static void re_compile_fastmap_aux(char *, int, char *, char *, char *);
 
 static void
-re_compile_fastmap_aux(char *code, int pos, char *visited, char *can_be_null, char *fastmap)
+re_compile_fastmap_aux(char *code, int pos, char *visited,
+		       char *can_be_null, char *fastmap)
 {
     int a, b, syntaxcode;
 
@@ -847,14 +915,15 @@ re_compile_fastmap_aux(char *code, int pos, char *visited, char *can_be_null, ch
 
 static int re_do_compile_fastmap(char *, int, int, char *, char *);
 static int
-re_do_compile_fastmap(char *buffer, int used, int pos, char *can_be_null, char *fastmap)
+re_do_compile_fastmap(char *buffer, int used, int pos, char *can_be_null,
+		      char *fastmap)
 {
     char small_visited[512], *visited;
 
     if (used <= sizeof(small_visited))
 	visited = small_visited;
     else {
-      visited = (char *) malloc(used);
+	visited = (char *) malloc(used);
 	if (!visited)
 	    return 0;
     }
@@ -873,8 +942,8 @@ re_compile_fastmap(regexp_t bufp)
     if (!bufp->fastmap || bufp->fastmap_accurate)
 	return;
     assert(bufp->used > 0);
-    if (!re_do_compile_fastmap(bufp->buffer, bufp->used, 0, &bufp->can_be_null,
-			       bufp->fastmap))
+    if (!re_do_compile_fastmap
+	(bufp->buffer, bufp->used, 0, &bufp->can_be_null, bufp->fastmap))
 	return;
     if (bufp->buffer[0] == Cbol)
 	bufp->anchor = 1;	/* begline */
@@ -890,12 +959,13 @@ re_compile_fastmap(regexp_t bufp)
 
 
 int
-re_match_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, int pos, regexp_registers_t regs, int mstop)
+re_match_2(regexp_t bufp, char *string1, int size1, char *string2,
+	   int size2, int pos, regexp_registers_t regs, int mstop)
 {
     struct failure_point {
 	char *text, *partend, *code;
     } *failure_stack_start, *failure_sp, *failure_stack_end,
-     initial_failure_stack[INITIAL_FAILURES];
+	initial_failure_stack[INITIAL_FAILURES];
     int failure_stack_size;
     char *code, *translate, *text, *textend, *partend, *part_2_end;
     char *regmaybe_text[RE_NREGS], *regmaybe_partend[RE_NREGS];
@@ -999,11 +1069,13 @@ re_match_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, in
 			if (regstart_partend[a] != part_2_end)
 			    regs->start[a] = regstart_text[a] - string1;
 			else
-			    regs->start[a] = regstart_text[a] - string2 + size1;
+			    regs->start[a] =
+				regstart_text[a] - string2 + size1;
 			if (regend_partend[a] != part_2_end)
 			    regs->end[a] = regend_text[a] - string1;
 			else
-			    regs->end[a] = regend_text[a] - string2 + size1;
+			    regs->end[a] =
+				regend_text[a] - string2 + size1;
 		    }
 		}
 	    }
@@ -1017,8 +1089,7 @@ re_match_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, in
 	case Ceol:
 	    if (text == string2 + size2 ||
 		(text == string1 + size1 ?
-		 (size2 == 0 || *string2 == '\n') :
-		 *text == '\n'))
+		 (size2 == 0 || *string2 == '\n') : *text == '\n'))
 		break;
 	    goto fail;
 	case Cset:
@@ -1101,7 +1172,8 @@ re_match_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, in
 		p2 = code;
 		/* p1 points inside loop, p2 points to after loop */
 		if (!re_do_compile_fastmap(bufp->buffer, bufp->used,
-				   p2 - bufp->buffer, &can_be_null, map))
+					   p2 - bufp->buffer, &can_be_null,
+					   map))
 		    goto make_normal_jump;
 		/* If we might introduce a new update point inside the loop,
 		   we can't optimize because then update_jump would update a
@@ -1181,7 +1253,9 @@ re_match_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, in
 		    case Cdummy_failure_jump:
 			goto make_normal_jump;
 		    default:
-			printf("regexpr.c: processing star_jump: unknown op %d\n", p1[-1]);
+			printf
+			    ("regexpr.c: processing star_jump: unknown op %d\n",
+			     p1[-1]);
 			break;
 		    }
 		}
@@ -1217,7 +1291,8 @@ re_match_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, in
 		if (2 * failure_stack_size > MAX_FAILURES)
 		    goto error;
 		new_stack_start = (struct failure_point *)
-		    malloc(2 * failure_stack_size * sizeof(*failure_stack_start));
+		    malloc(2 * failure_stack_size *
+			   sizeof(*failure_stack_start));
 		if (new_stack_start == NULL)
 		    goto error;
 		memcpy((char *) new_stack_start,
@@ -1228,7 +1303,8 @@ re_match_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, in
 		failure_stack_start = new_stack_start;
 		failure_sp = failure_stack_start + failure_stack_size;
 		failure_stack_size *= 2;
-		failure_stack_end = failure_stack_start + failure_stack_size;
+		failure_stack_end =
+		    failure_stack_start + failure_stack_size;
 	    }
 	    a = (unsigned char) *code++;
 	    a |= (unsigned char) *code++ << 8;
@@ -1252,7 +1328,8 @@ re_match_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, in
 		break;
 	    goto fail;
 	case Cendbuf:
-	    if (size2 == 0 ? text == string1 + size1 : text == string2 + size2)
+	    if (size2 == 0 ? text == string1 + size1 : text ==
+		string2 + size2)
 		break;
 	    goto fail;
 	case Cwordbeg:
@@ -1260,7 +1337,8 @@ re_match_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, in
 		goto fail;
 	    if (size2 == 0 && text == string1 + size1)
 		goto fail;
-	    if (SYNTAX(text == string1 + size1 ? *string1 : *text) != Sword)
+	    if (SYNTAX(text == string1 + size1 ? *string1 : *text) !=
+		Sword)
 		goto fail;
 	    if (text == string1)
 		break;
@@ -1286,7 +1364,8 @@ re_match_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, in
 		(size2 == 0 && text == string1 + size1))
 		break;
 	    if ((SYNTAX(text[-1]) == Sword) ^
-	    (SYNTAX(text == string1 + size1 ? *string2 : *text) == Sword))
+		(SYNTAX(text == string1 + size1 ? *string2 : *text) ==
+		 Sword))
 		break;
 	    goto fail;
 	case Cnotwordbound:
@@ -1296,7 +1375,8 @@ re_match_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, in
 		(size2 == 0 && text == string1 + size1))
 		goto fail;
 	    if (!((SYNTAX(text[-1]) == Sword) ^
-		  (SYNTAX(text == string1 + size1 ? *string2 : *text) == Sword)))
+		  (SYNTAX(text == string1 + size1 ? *string2 : *text) ==
+		   Sword)))
 		goto fail;
 	    break;
 	case Csyntaxspec:
@@ -1350,13 +1430,16 @@ re_match_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, in
 #undef PUSH_FAILURE
 
 int
-re_match(regexp_t bufp, char *string, int size, int pos, regexp_registers_t regs)
+re_match(regexp_t bufp, char *string, int size, int pos,
+	 regexp_registers_t regs)
 {
-    return re_match_2(bufp, string, size, (char *) NULL, 0, pos, regs, size);
+    return re_match_2(bufp, string, size, (char *) NULL, 0, pos, regs,
+		      size);
 }
 
 int
-re_search_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, int pos, int range, regexp_registers_t regs,
+re_search_2(regexp_t bufp, char *string1, int size1, char *string2,
+	    int size2, int pos, int range, regexp_registers_t regs,
 	    int mstop)
 {
     char *fastmap, *translate, *text, *partstart, *partend;
@@ -1400,12 +1483,14 @@ re_search_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, i
 		}
 		partstart = text;
 		if (translate)
-		    while (text != partend &&
-			   !fastmap[(unsigned char)
-				    translate[(unsigned char) *text]])
+		    while (text != partend && !fastmap[(unsigned char)
+						       translate[(unsigned
+								  char)
+								 *text]])
 			text++;
 		else
-		    while (text != partend && !fastmap[(unsigned char) *text])
+		    while (text != partend
+			   && !fastmap[(unsigned char) *text])
 			text++;
 		pos += text - partstart;
 		range -= text - partstart;
@@ -1424,9 +1509,8 @@ re_search_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, i
 		}
 		partend = text;
 		if (translate)
-		    while (text != partstart &&
-			   !fastmap[(unsigned char)
-				    translate[(unsigned char) *text]])
+		    while (text != partstart && !fastmap[(unsigned char)
+							 translate[(unsigned char) *text]])
 			text--;
 		else
 		    while (text != partstart &&
@@ -1443,7 +1527,9 @@ re_search_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, i
 		continue;
 	}
 	assert(pos >= 0 && pos <= size1 + size2);
-	ret = re_match_2(bufp, string1, size1, string2, size2, pos, regs, mstop);
+	ret =
+	    re_match_2(bufp, string1, size1, string2, size2, pos, regs,
+		       mstop);
 	if (ret >= 0)
 	    return pos;
 	if (ret == -2)
@@ -1453,7 +1539,8 @@ re_search_2(regexp_t bufp, char *string1, int size1, char *string2, int size2, i
 }
 
 int
-re_search(regexp_t bufp, char *string, int size, int startpos, int range, regexp_registers_t regs)
+re_search(regexp_t bufp, char *string, int size, int startpos, int range,
+	  regexp_registers_t regs)
 {
     return re_search_2(bufp, string, size, (char *) NULL, 0,
 		       startpos, range, regs, size);
@@ -1488,7 +1575,8 @@ re_exec(s)
 {
     int len = strlen(s);
 
-    return re_search(&re_comp_buf, s, len, 0, len, (regexp_registers_t) NULL) >= 0;
+    return re_search(&re_comp_buf, s, len, 0, len,
+		     (regexp_registers_t) NULL) >= 0;
 }
 
 #endif
@@ -1628,7 +1716,8 @@ main()
 	    printf("search returns %d\n", a);
 	    if (a != -1) {
 		for (a = 0; a < RE_NREGS; a++) {
-		    printf("buf %d: %d to %d\n", a, regs.start[a], regs.end[a]);
+		    printf("buf %d: %d to %d\n", a, regs.start[a],
+			   regs.end[a]);
 		}
 	    }
 	}
diff --git a/server/server.c b/server/server.c
index 12cf10d..c979d6c 100644
--- a/server/server.c
+++ b/server/server.c
@@ -92,7 +92,7 @@ typedef struct slistener {
 
 static slistener *all_slisteners = 0;
 
-server_listener null_server_listener = {0};
+server_listener null_server_listener = { 0 };
 
 static void
 free_shandle(shandle * h)
@@ -115,7 +115,8 @@ new_slistener(Objid oid, Var desc, int print_messages, enum error *ee)
     const char *name;
 
     sl.ptr = l;
-    e = network_make_listener(sl, desc, &(l->nlistener), &(l->desc), &name);
+    e = network_make_listener(sl, desc, &(l->nlistener), &(l->desc),
+			      &name);
 
     if (ee)
 	*ee = e;
@@ -144,7 +145,8 @@ start_listener(slistener * l)
 	oklog("LISTEN: #%d now listening on %s\n", l->oid, l->name);
 	return 1;
     } else {
-	errlog("LISTEN: Can't start #%d listening on %s!\n", l->oid, l->name);
+	errlog("LISTEN: Can't start #%d listening on %s!\n", l->oid,
+	       l->name);
 	return 0;
     }
 }
@@ -228,7 +230,7 @@ panic(const char *message)
 
 enum Fork_Result
 /* bg_name_lookup - Throw pid in *child_pid if child_pid not NULL */
-fork_server(const char *subtask_name, pid_t *child_pid)
+fork_server(const char *subtask_name, pid_t * child_pid)
 /* !bg_name_lookup */
 {
     pid_t pid;
@@ -248,9 +250,9 @@ fork_server(const char *subtask_name, pid_t *child_pid)
     } else
 /* bg_name_lookup */
     {
-        if (child_pid != NULL)
-          *child_pid=pid;
-        return FORK_PARENT;
+	if (child_pid != NULL)
+	    *child_pid = pid;
+	return FORK_PARENT;
     }
 /* !bg_name_lookup */
 }
@@ -296,30 +298,30 @@ child_completed_signal(int sig)
 
     /* bg_name_lookup */
     pid_t pid;
-     
+
 #   define CHECKPID                                   \
     if (pid && pid == checkpoint_pid)                 \
     {                                                 \
       /* 1 = failure, 2 = success */                  \
       checkpoint_finished = (status == 0) + 1;        \
     }                                                 \
-     
+
 #if HAVE_WAITPID
     do {
-      pid = waitpid(-1, (int *) &status, WNOHANG);
-      CHECKPID;
+	pid = waitpid(-1, (int *) &status, WNOHANG);
+	CHECKPID;
     } while (pid > 0);
 #else
 #if HAVE_WAIT3
     do {
-      pid = wait3((int *) &status, WNOHANG, 0);
-      CHECKPID;
+	pid = wait3((int *) &status, WNOHANG, 0);
+	CHECKPID;
     } while (pid > 0)
 #else
 #if HAVE_WAIT2
     do {
-      pid = wait2((int *) &status, WNOHANG);
-      CHECKPID;
+	pid = wait2((int *) &status, WNOHANG);
+	CHECKPID;
     } while (pid > 0)
 #else
     pid = wait((int *) &status);
@@ -327,7 +329,7 @@ child_completed_signal(int sig)
 #endif
 #endif
 #endif
-     
+
     signal(sig, child_completed_signal);
     /* !bg_name_lookup */
 }
@@ -348,7 +350,7 @@ setup_signals(void)
     signal(SIGINT, shutdown_signal);
     signal(SIGTERM, shutdown_signal);
     signal(SIGUSR1, shutdown_signal);	/* remote shutdown signal */
-    signal(SIGUSR2, checkpoint_signal);		/* remote checkpoint signal */
+    signal(SIGUSR2, checkpoint_signal);	/* remote checkpoint signal */
 
     signal(SIGCHLD, child_completed_signal);
 }
@@ -408,12 +410,10 @@ call_notifier(Objid player, Objid handler, const char *verb_name)
 int
 get_server_option(Objid oid, const char *name, Var * r)
 {
-    if (((valid(oid) &&
-	  db_find_property(oid, "server_options", r).ptr)
+    if (((valid(oid) && db_find_property(oid, "server_options", r).ptr)
 	 || (valid(SYSTEM_OBJECT) &&
 	     db_find_property(SYSTEM_OBJECT, "server_options", r).ptr))
-	&& r->type == TYPE_OBJ
-	&& valid(r->v.obj)
+	&& r->type == TYPE_OBJ && valid(r->v.obj)
 	&& db_find_property(r->v.obj, name, r).ptr)
 	return 1;
 
@@ -421,7 +421,7 @@ get_server_option(Objid oid, const char *name, Var * r)
 }
 
 static void
-send_message(Objid listener, network_handle nh, const char *msg_name,...)
+send_message(Objid listener, network_handle nh, const char *msg_name, ...)
 {
     va_list args;
     Var msg;
@@ -440,7 +440,7 @@ send_message(Objid listener, network_handle nh, const char *msg_name,...)
 	}
     } else			/* Use default message */
 	while ((line = va_arg(args, const char *)) != 0)
-	    network_send_line(nh, line, 1);
+	     network_send_line(nh, line, 1);
 
     va_end(args);
 }
@@ -461,22 +461,22 @@ main_loop(void)
     free_var(checkpointed_connections);
 
     /* Second, run #0:server_started() */
-    run_server_task(-1, SYSTEM_OBJECT, "server_started", new_list(0), "", 0);
+    run_server_task(-1, SYSTEM_OBJECT, "server_started", new_list(0), "",
+		    0);
     set_checkpoint_timer(1);
 
     /* Now, we enter the main server loop */
     while (shutdown_message == 0) {
-        struct timeval task_seconds;
-        int            any_tasks;
+	struct timeval task_seconds;
+	int any_tasks;
 
-        any_tasks = next_task_start(&task_seconds);
+	any_tasks = next_task_start(&task_seconds);
 
-        /* Set maximum timeout of 1 second if no tasks or if the next task is farther than 1 second away */
-        if ((!any_tasks) || (task_seconds.tv_sec > 0))
-        {
-          task_seconds.tv_sec  = 1;
-          task_seconds.tv_usec = 0;
-        }
+	/* Set maximum timeout of 1 second if no tasks or if the next task is farther than 1 second away */
+	if ((!any_tasks) || (task_seconds.tv_sec > 0)) {
+	    task_seconds.tv_sec = 1;
+	    task_seconds.tv_usec = 0;
+	}
 
 	shandle *h, *nexth;
 
@@ -518,25 +518,26 @@ main_loop(void)
 		nexth = h->next;
 
 		if (!h->outbound && h->connection_time == 0
-		    && (get_server_option(h->listener, "connect_timeout", &v)
-			? (v.type == TYPE_INT && v.v.num > 0
-			   && now - h->last_activity_time > v.v.num)
-			: (now - h->last_activity_time
-			   > DEFAULT_CONNECT_TIMEOUT))) {
-		    call_notifier(h->player, h->listener, "user_disconnected");
-		    oklog("TIMEOUT: #%d on %s\n",
-			  h->player,
+		    &&
+		    (get_server_option(h->listener, "connect_timeout", &v)
+		     ? (v.type == TYPE_INT && v.v.num > 0
+			&& now - h->last_activity_time > v.v.num)
+		     : (now - h->last_activity_time >
+			DEFAULT_CONNECT_TIMEOUT))) {
+		    call_notifier(h->player, h->listener,
+				  "user_disconnected");
+		    oklog("TIMEOUT: #%d on %s\n", h->player,
 			  network_connection_name(h->nhandle));
 		    if (h->print_messages)
-			send_message(h->listener, h->nhandle, "timeout_msg",
+			send_message(h->listener, h->nhandle,
+				     "timeout_msg",
 				     "*** Timed-out waiting for login. ***",
 				     0);
 		    network_close(h->nhandle);
 		    free_shandle(h);
 		} else if (h->connection_time != 0 && !valid(h->player)) {
 		    oklog("RECYCLED: #%d on %s\n",
-			  h->player,
-			  network_connection_name(h->nhandle));
+			  h->player, network_connection_name(h->nhandle));
 		    if (h->print_messages)
 			send_message(h->listener, h->nhandle,
 				     "recycle_msg", "*** Recycled ***", 0);
@@ -624,41 +625,47 @@ server_connection_options(shandle * h, Var list)
 static int
 server_set_connection_option(shandle * h, const char *option, Var value)
 {
-  do {
-    if (!mystrcasecmp((option), "binary")) {
-      { (h)->binary = is_true((value));
-        network_set_connection_binary((h)->nhandle, (h)->binary);
-      };
-      return 1; }
-    return 0; }
-  while (0);
+    do {
+	if (!mystrcasecmp((option), "binary")) {
+	    {
+		(h)->binary = is_true((value));
+		network_set_connection_binary((h)->nhandle, (h)->binary);
+	    };
+	    return 1;
+	}
+	return 0;
+    }
+    while (0);
 }
 
 static int
 server_connection_option(shandle * h, const char *option, Var * value)
 {
-  do {
-    if (!mystrcasecmp((option), "binary")) {
-      (value)->type = (TYPE_INT);
-      (value)->v.num = ((h)->binary);
-      return 1; } 
-    return 0; } 
-  while (0);
+    do {
+	if (!mystrcasecmp((option), "binary")) {
+	    (value)->type = (TYPE_INT);
+	    (value)->v.num = ((h)->binary);
+	    return 1;
+	}
+	return 0;
+    }
+    while (0);
 }
 
 static Var
 server_connection_options(shandle * h, Var list)
 {
-  do {
-    { Var pair = new_list(2);
-      pair.v.list[1].type = (var_type)(_TYPE_STR | 0x80);
-      pair.v.list[1].v.str = str_dup("binary");
-      pair.v.list[2].type = (TYPE_INT);
-      pair.v.list[2].v.num = ((h)->binary);
-      (list) = listappend((list), pair);
-    }
-    return (list);
-  } while (0);
+    do {
+	{
+	    Var pair = new_list(2);
+	    pair.v.list[1].type = (var_type) (_TYPE_STR | 0x80);
+	    pair.v.list[1].v.str = str_dup("binary");
+	    pair.v.list[2].type = (TYPE_INT);
+	    pair.v.list[2].v.num = ((h)->binary);
+	    (list) = listappend((list), pair);
+	}
+	return (list);
+    } while (0);
 }
 
 #undef SERVER_CO_TABLE
@@ -742,7 +749,8 @@ emergency_mode()
 		db_set_object_flag(wizard, FLAG_WIZARD);
 		printf("** No wizards in database; wizzed #%d.\n", wizard);
 	    }
-	    printf("** Now running emergency commands as #%d ...\n", wizard);
+	    printf("** Now running emergency commands as #%d ...\n",
+		   wizard);
 	}
 	printf("\nMOO (#%d)%s: ", wizard, debug ? "" : "[!d]");
 	line = read_stdin_line();
@@ -754,7 +762,7 @@ emergency_mode()
 	    Program *program;
 	    Var str;
 
-	    str.type = (var_type)TYPE_STR;
+	    str.type = (var_type) TYPE_STR;
 	    code = new_list(0);
 
 	    if (*++line == ';')
@@ -840,7 +848,7 @@ emergency_mode()
 		    Program *program;
 
 		    code = new_list(0);
-		    str.type = (var_type)TYPE_STR;
+		    str.type = (var_type) TYPE_STR;
 
 		    while (strcmp(line = read_stdin_line(), ".")) {
 			str.v.str = str_dup(line);
@@ -888,7 +896,7 @@ emergency_mode()
 		else
 		    printf("%s\n", message);
 	    } else if (!mystrcasecmp(command, "abort") && nargs == 0) {
-	        printf("Bye.  (%s)\n\n", "NOT saving database");
+		printf("Bye.  (%s)\n\n", "NOT saving database");
 		exit(1);
 	    } else if (!mystrcasecmp(command, "quit") && nargs == 0) {
 		start_ok = 0;
@@ -897,7 +905,8 @@ emergency_mode()
 	    } else if (!mystrcasecmp(command, "debug") && nargs == 0) {
 		debug = !debug;
 	    } else if (!mystrcasecmp(command, "wizard") && nargs == 1
-		       && sscanf(words.v.list[2].v.str, "#%d", &wizard) == 1) {
+		       && sscanf(words.v.list[2].v.str, "#%d",
+				 &wizard) == 1) {
 		printf("** Switching to wizard #%d...\n", wizard);
 	    } else {
 		if (mystrcasecmp(command, "help")
@@ -928,12 +937,12 @@ emergency_mode()
 		       "Exit server normally, saving database.\n");
 		printf("abort                 "
 		       "Exit server *without* saving database.\n");
-		printf("help, ?               "
-		       "Print this text.\n\n");
+		printf("help, ?               " "Print this text.\n\n");
 
 		printf("NOTE: *NO* forked or suspended tasks will run "
 		       "until you exit this mode.\n\n");
-		printf("\"Please remember to turn me off when you go...\"\n");
+		printf
+		    ("\"Please remember to turn me off when you go...\"\n");
 	    }
 
 	    free_var(words);
@@ -1018,7 +1027,7 @@ static Objid next_unconnected_player = NOTHING - 1;
 server_handle
 server_new_connection(server_listener sl, network_handle nh, int outbound)
 {
-  slistener *l = (slistener *) sl.ptr;
+    slistener *l = (slistener *) sl.ptr;
     shandle *h = (shandle *) mymalloc(sizeof(shandle), M_NETWORK);
     server_handle result;
 
@@ -1061,14 +1070,13 @@ server_new_connection(server_listener sl, network_handle nh, int outbound)
 void
 server_refuse_connection(server_listener sl, network_handle nh)
 {
-  slistener *l = (slistener *) sl.ptr;
+    slistener *l = (slistener *) sl.ptr;
 
     if (l->print_messages)
 	send_message(l->oid, nh, "server_full_msg",
 		     "*** Sorry, but the server cannot accept any more"
 		     " connections right now.",
-		     "*** Please try again later.",
-		     0);
+		     "*** Please try again later.", 0);
     errlog("SERVER FULL: refusing connection on %s from %s\n",
 	   l->name, network_connection_name(nh));
 }
@@ -1081,12 +1089,13 @@ server_receive_line(server_handle sh, const char *line)
     shandle *h = (shandle *) sh.ptr;
 
     if ((time(0) - h->last_activity_time) > v) {
-        args = new_list(2);
-        args.v.list[1].type = TYPE_OBJ;
-        args.v.list[1].v.obj = h->player;
-        args.v.list[2].type = TYPE_INT;
-        args.v.list[2].v.num = (time(0) - h->last_activity_time);
-        run_server_task(h->player, h->listener, "user_unidled", args, "", 0);
+	args = new_list(2);
+	args.v.list[1].type = TYPE_OBJ;
+	args.v.list[1].v.obj = h->player;
+	args.v.list[2].type = TYPE_INT;
+	args.v.list[2].v.num = (time(0) - h->last_activity_time);
+	run_server_task(h->player, h->listener, "user_unidled", args, "",
+			0);
     }
     h->last_activity_time = time(0);
     new_input_task(h->tasks, line, h->binary);
@@ -1098,8 +1107,7 @@ server_close(server_handle sh)
     shandle *h = (shandle *) sh.ptr;
 
     oklog("CLIENT DISCONNECTED: %s on %s\n",
-	  object_name(h->player),
-	  network_connection_name(h->nhandle));
+	  object_name(h->player), network_connection_name(h->nhandle));
     h->disconnect_me = 1;
     call_notifier(h->player, h->listener, "user_client_disconnected");
     free_shandle(h);
@@ -1143,20 +1151,22 @@ player_connected(Objid old_id, Objid new_id, int is_newly_created)
 	/* network_connection_name is allowed to reuse the same string
 	 * storage, so we have to copy one of them.
 	 */
-	char *name1 = str_dup(network_connection_name(existing_h->nhandle));
+	char *name1 =
+	    str_dup(network_connection_name(existing_h->nhandle));
 
 	oklog("REDIRECTED: %s, was %s, now %s\n",
 	      object_name(new_id),
-	      name1,
-	      network_connection_name(new_h->nhandle));
+	      name1, network_connection_name(new_h->nhandle));
 	free_str(name1);
 	if (existing_h->print_messages)
 	    send_message(existing_listener, existing_h->nhandle,
 			 "redirect_from_msg",
 			 "*** Redirecting connection to new port ***", 0);
 	if (new_h->print_messages)
-	    send_message(new_h->listener, new_h->nhandle, "redirect_to_msg",
-			 "*** Redirecting old connection to this port ***", 0);
+	    send_message(new_h->listener, new_h->nhandle,
+			 "redirect_to_msg",
+			 "*** Redirecting old connection to this port ***",
+			 0);
 	network_close(existing_h->nhandle);
 	free_shandle(existing_h);
 	if (existing_listener == new_h->listener)
@@ -1178,11 +1188,12 @@ player_connected(Objid old_id, Objid new_id, int is_newly_created)
 		send_message(new_h->listener, new_h->nhandle, "create_msg",
 			     "*** Created ***", 0);
 	    else
-		send_message(new_h->listener, new_h->nhandle, "connect_msg",
-			     "*** Connected ***", 0);
+		send_message(new_h->listener, new_h->nhandle,
+			     "connect_msg", "*** Connected ***", 0);
 	}
 	call_notifier(new_id, new_h->listener,
-		      is_newly_created ? "user_created" : "user_connected");
+		      is_newly_created ? "user_created" :
+		      "user_connected");
     }
 }
 
@@ -1251,7 +1262,8 @@ read_active_connections(void)
 
 	if (have_listeners) {
 	    if (dbio_scanf("%d %d\n", &who, &listener) != 2) {
-		errlog("READ_ACTIVE_CONNECTIONS: Bad conn/listener pair.\n");
+		errlog
+		    ("READ_ACTIVE_CONNECTIONS: Bad conn/listener pair.\n");
 		return 0;
 	    }
 	} else {
@@ -1326,7 +1338,8 @@ main(int argc, char **argv)
     if (log_file)
 	fclose(stderr);
 
-    oklog("STARTING: Version %s of the LambdaMOO server\n", server_version);
+    oklog("STARTING: Version %s of the LambdaMOO server\n",
+	  server_version);
     oklog("          (Using %s protocol)\n", network_protocol_name());
     oklog("          (Task timeouts measured in %s seconds.)\n",
 	  virtual_timer_available()? "server CPU" : "wall-clock");
@@ -1371,7 +1384,7 @@ static package
 bf_server_version(Var arglist, Byte next, void *vdata, Objid progr)
 {
     Var r;
-    r.type = (var_type)TYPE_STR;
+    r.type = (var_type) TYPE_STR;
     r.v.str = str_dup(server_version);
     free_var(arglist);
     return make_var_pack(r);
@@ -1460,7 +1473,8 @@ bf_db_disk_size(Var arglist, Byte next, void *vdata, Objid progr)
     free_var(arglist);
     v.type = TYPE_INT;
     if ((v.v.num = db_disk_size()) < 0)
-	return make_raise_pack(E_QUOTA, "No database file(s) available", zero);
+	return make_raise_pack(E_QUOTA, "No database file(s) available",
+			       zero);
     else
 	return make_var_pack(v);
 }
@@ -1477,10 +1491,11 @@ find_slistener_by_oid(Objid obj)
 
     return 0;
 }
-#endif /* OUTBOUND_NETWORK */
+#endif				/* OUTBOUND_NETWORK */
 
 static package
-bf_open_network_connection(Var arglist, Byte next, void *vdata, Objid progr)
+bf_open_network_connection(Var arglist, Byte next, void *vdata,
+			   Objid progr)
 {
 #ifdef OUTBOUND_NETWORK
 
@@ -1490,8 +1505,8 @@ bf_open_network_connection(Var arglist, Byte next, void *vdata, Objid progr)
     slistener l;
 
     if (!is_wizard(progr)) {
-        free_var(arglist);
-        return make_error_pack(E_PERM);
+	free_var(arglist);
+	return make_error_pack(E_PERM);
     }
 
     if (arglist.v.list[0].v.num == 3) {
@@ -1628,7 +1643,7 @@ bf_connection_name(Var arglist, Byte next, void *vdata, Objid progr)
     else if (!conn_name)
 	return make_error_pack(E_INVARG);
     else {
-      r.type = (var_type)TYPE_STR;
+	r.type = (var_type) TYPE_STR;
 	r.v.str = str_dup(conn_name);
 	return make_var_pack(r);
     }
@@ -1637,10 +1652,10 @@ bf_connection_name(Var arglist, Byte next, void *vdata, Objid progr)
 static package
 bf_connection_user(Var arglist, Byte next, void *vdata, Objid progr)
 {
-    Objid       who = arglist.v.list[1].v.obj;
-    shandle    *h = find_shandle(who);
+    Objid who = arglist.v.list[1].v.obj;
+    shandle *h = find_shandle(who);
     const char *user_name;
-    Var         r;
+    Var r;
 
 /*    free_var(arglist);
     r.type = TYPE_STR;
@@ -1648,50 +1663,50 @@ bf_connection_user(Var arglist, Byte next, void *vdata, Objid progr)
     return make_var_pack(r);*/
 
     if (h)
-        user_name = network_connection_user(h->nhandle);
+	user_name = network_connection_user(h->nhandle);
     else
-        user_name = 0;
+	user_name = 0;
 
     free_var(arglist);
-    if (!is_wizard(progr)  &&  progr != who)
-        return make_error_pack(E_PERM);
+    if (!is_wizard(progr) && progr != who)
+	return make_error_pack(E_PERM);
     else if (!user_name)
-        return make_error_pack(E_INVARG);
+	return make_error_pack(E_INVARG);
     else {
-        r.type = TYPE_STR;
-        r.v.str = str_dup(user_name);
-        return make_var_pack(r);
+	r.type = TYPE_STR;
+	r.v.str = str_dup(user_name);
+	return make_var_pack(r);
     }
 }
 
 Objid
 connection_listener(Objid player)
 {
-    shandle    *h = find_shandle(player);
+    shandle *h = find_shandle(player);
 
     if (h)
-        return h->listener;
+	return h->listener;
     else
-        return -1;
+	return -1;
 }
 
 static package
 bf_connection_listener(Var arglist, Byte next, void *vdata, Objid progr)
 {
-    Objid       who = arglist.v.list[1].v.obj;
-    shandle    *h = find_shandle(who);
-    Var         r;
+    Objid who = arglist.v.list[1].v.obj;
+    shandle *h = find_shandle(who);
+    Var r;
 
     free_var(arglist);
-    if (!is_wizard(progr)  &&  progr != who)
-        return make_error_pack(E_PERM);
+    if (!is_wizard(progr) && progr != who)
+	return make_error_pack(E_PERM);
 
     if (h) {
-        r.type = TYPE_OBJ;
-        r.v.obj = h->listener;
-        return make_var_pack(r);
+	r.type = TYPE_OBJ;
+	r.v.obj = h->listener;
+	return make_var_pack(r);
     } else {
-        return make_error_pack(E_INVARG);
+	return make_error_pack(E_INVARG);
     }
 }
 
@@ -1720,7 +1735,8 @@ bf_notify(Var arglist, Byte next, void *vdata, Objid progr)
 		free_var(arglist);
 		return make_error_pack(E_INVARG);
 	    }
-	    r.v.num = network_send_bytes(h->nhandle, line, length, !no_flush);
+	    r.v.num =
+		network_send_bytes(h->nhandle, line, length, !no_flush);
 	} else
 	    r.v.num = network_send_line(h->nhandle, line, !no_flush);
     } else {
@@ -1760,7 +1776,8 @@ bf_set_connection_option(Var arglist, Byte next, void *vdata, Objid progr)
     else if (!h || h->disconnect_me
 	     || (!server_set_connection_option(h, option, value)
 		 && !tasks_set_connection_option(h->tasks, option, value)
-		 && !network_set_connection_option(h->nhandle, option, value)))
+		 && !network_set_connection_option(h->nhandle, option,
+						   value)))
 	e = E_INVARG;
 
     free_var(arglist);
@@ -1827,27 +1844,30 @@ bf_listen(Var arglist, Byte next, void *vdata, Objid progr)
     slistener *l = 0;
 
     if (arglist.v.list[2].type == TYPE_LIST) {
-        if (arglist.v.list[2].v.list[0].v.num == 2 && arglist.v.list[2].v.list[1].type == TYPE_STR && arglist.v.list[2].v.list[2].type == TYPE_INT) {
-            desc = new_list(2);
-            desc.v.list[1].type = TYPE_STR;
-            desc.v.list[1].v.str = str_dup(arglist.v.list[2].v.list[1].v.str);
-            desc.v.list[2] = arglist.v.list[2].v.list[2];
-        } else {
-            e = E_INVARG;
-        }
+	if (arglist.v.list[2].v.list[0].v.num == 2
+	    && arglist.v.list[2].v.list[1].type == TYPE_STR
+	    && arglist.v.list[2].v.list[2].type == TYPE_INT) {
+	    desc = new_list(2);
+	    desc.v.list[1].type = TYPE_STR;
+	    desc.v.list[1].v.str =
+		str_dup(arglist.v.list[2].v.list[1].v.str);
+	    desc.v.list[2] = arglist.v.list[2].v.list[2];
+	} else {
+	    e = E_INVARG;
+	}
     } else if (arglist.v.list[2].type == TYPE_INT) {
-        desc = arglist.v.list[2];
+	desc = arglist.v.list[2];
     } else {
-      e = E_INVARG;
+	e = E_INVARG;
     }
 
     if (e == E_NONE) {
-        if (!is_wizard(progr))
+	if (!is_wizard(progr))
 	    e = E_PERM;
-        else if (!valid(oid) || find_slistener(desc))
+	else if (!valid(oid) || find_slistener(desc))
 	    e = E_INVARG;
-        else if (!(l = new_slistener(oid, desc, print_messages, &e)));	/* Do nothing; e is already set */
-        else if (!start_listener(l))
+	else if (!(l = new_slistener(oid, desc, print_messages, &e)));	/* Do nothing; e is already set */
+	else if (!start_listener(l))
 	    e = E_QUOTA;
     }
 
@@ -1928,20 +1948,20 @@ bf_buffered_output_length(Var arglist, Byte next, void *vdata, Objid progr)
 
 static package
 bf_chr(Var arglist, Byte next, void *vdata, Objid progr)
-{ /* (number) */
+{				/* (number) */
     Var r;
     char c[2];
 
     if (!is_wizard(progr)) {
-      free_var(arglist);
-      return make_error_pack(E_PERM);
+	free_var(arglist);
+	return make_error_pack(E_PERM);
     }
 
     c[0] = arglist.v.list[1].v.num;
     c[1] = 0;
 
     if (arglist.v.list[1].v.num == 10)
-      return make_error_pack(E_INVARG);
+	return make_error_pack(E_INVARG);
 
     free_var(arglist);
 
@@ -1967,26 +1987,33 @@ register_server(void)
     register_function("connected_seconds", 1, 1, bf_connected_seconds,
 		      TYPE_OBJ);
     register_function("idle_seconds", 1, 1, bf_idle_seconds, TYPE_OBJ);
-    register_function("connection_name", 1, 1, bf_connection_name, TYPE_OBJ);
-    register_function("notify", 2, 3, bf_notify, TYPE_OBJ, TYPE_STR, TYPE_ANY);
+    register_function("connection_name", 1, 1, bf_connection_name,
+		      TYPE_OBJ);
+    register_function("notify", 2, 3, bf_notify, TYPE_OBJ, TYPE_STR,
+		      TYPE_ANY);
     register_function("boot_player", 1, 1, bf_boot_player, TYPE_OBJ);
-    register_function("set_connection_option", 3, 3, bf_set_connection_option,
-		      TYPE_OBJ, TYPE_STR, TYPE_ANY);
+    register_function("set_connection_option", 3, 3,
+		      bf_set_connection_option, TYPE_OBJ, TYPE_STR,
+		      TYPE_ANY);
     register_function("connection_option", 2, 2, bf_connection_options,
 		      TYPE_OBJ, TYPE_STR);
     register_function("connection_options", 1, 1, bf_connection_options,
 		      TYPE_OBJ);
-    register_function("listen", 2, 3, bf_listen, TYPE_OBJ, TYPE_ANY, TYPE_ANY);
+    register_function("listen", 2, 3, bf_listen, TYPE_OBJ, TYPE_ANY,
+		      TYPE_ANY);
     register_function("unlisten", 1, 1, bf_unlisten, TYPE_ANY);
     register_function("listeners", 0, 0, bf_listeners);
     register_function("buffered_output_length", 0, 1,
 		      bf_buffered_output_length, TYPE_OBJ);
-    register_function("connection_listener", 1, 1, bf_connection_listener, TYPE_OBJ);
-    register_function("connection_user", 1, 1, bf_connection_user, TYPE_OBJ);
+    register_function("connection_listener", 1, 1, bf_connection_listener,
+		      TYPE_OBJ);
+    register_function("connection_user", 1, 1, bf_connection_user,
+		      TYPE_OBJ);
     register_function("chr", 1, 1, bf_chr, TYPE_INT);
 }
 
-char rcsid_server[] = "$Id: server.c,v 1.12 2007-06-02 21:34:36 wrog Exp $";
+char rcsid_server[] =
+    "$Id: server.c,v 1.12 2007-06-02 21:34:36 wrog Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/server.h b/server/server.h
index cb0b6a7..6662d7c 100644
--- a/server/server.h
+++ b/server/server.h
@@ -27,7 +27,7 @@
 #define Server_H 1
 
 /* bg_name_lookup */
-#include <sys/types.h> /* pid_t */
+#include <sys/types.h>		/* pid_t */
 /* !bg_name_lookup */
 
 #include "my-stdio.h"
@@ -47,7 +47,7 @@ typedef struct {		/* Server's handle on a listening point */
 extern server_listener null_server_listener;
 
 extern server_handle server_new_connection(server_listener l,
-					 network_handle h, int outbound);
+					   network_handle h, int outbound);
 				/* Called by the network whenever a new player
 				 * connection is created.  If `outbound' is
 				 * true, then the connection is being made from
@@ -60,8 +60,7 @@ extern server_handle server_new_connection(server_listener l,
 				 * calls on each other.
 				 */
 
-extern void server_refuse_connection(server_listener l,
-				     network_handle h);
+extern void server_refuse_connection(server_listener l, network_handle h);
 				/* Called by the network whenever it has
 				 * temporarily accepted a connection just to
 				 * explain to the user that the server is too
@@ -155,7 +154,8 @@ enum Fork_Result {
 
 /* bg_name_lookup */
 extern pid_t checkpoint_pid;
-extern enum Fork_Result fork_server(const char *subtask_name, pid_t *child_pid);
+extern enum Fork_Result fork_server(const char *subtask_name,
+				    pid_t * child_pid);
 /* !bg_name_lookup */
 
 extern void player_connected(Objid old_id, Objid new_id,
diff --git a/server/storage.c b/server/storage.c
index 35b6249..3be6da3 100644
--- a/server/storage.c
+++ b/server/storage.c
@@ -28,7 +28,8 @@
 
 static unsigned alloc_num[Sizeof_Memory_Type];
 #ifdef USE_GNU_MALLOC
-static unsigned alloc_size[Sizeof_Memory_Type], alloc_real_size[Sizeof_Memory_Type];
+static unsigned alloc_size[Sizeof_Memory_Type],
+    alloc_real_size[Sizeof_Memory_Type];
 #endif
 
 static inline int
@@ -47,7 +48,7 @@ refcount_overhead(Memory_Type type)
 	return sizeof(int) + sizeof(int);
 #else
 	return sizeof(int);
-#endif /* MEMO_STRLEN */
+#endif				/* MEMO_STRLEN */
     case M_LIST:
 	/* for systems with picky pointer alignment */
 	return MAX(sizeof(int), sizeof(Var *));
@@ -89,7 +90,7 @@ mymalloc(unsigned size, Memory_Type type)
 #ifdef MEMO_STRLEN
 	if (type == M_STRING)
 	    ((int *) memptr)[-2] = size - 1;
-#endif /* MEMO_STRLEN */
+#endif				/* MEMO_STRLEN */
     }
     return memptr;
 }
@@ -229,7 +230,8 @@ memory_usage(void)
     return r;
 }
 
-char rcsid_storage[] = "$Id: storage.c,v 1.6 2006-09-07 00:55:02 bjj Exp $";
+char rcsid_storage[] =
+    "$Id: storage.c,v 1.6 2006-09-07 00:55:02 bjj Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/storage.h b/server/storage.h
index dc77794..a0a8546 100644
--- a/server/storage.h
+++ b/server/storage.h
@@ -38,7 +38,6 @@ typedef enum Memory_Type {
     M_XML_DATA,
 
     Sizeof_Memory_Type
-
 } Memory_Type;
 
 extern char *str_dup(const char *);
@@ -65,7 +64,7 @@ free_str(const char *s)
 #else
 #define memo_strlen(X)		strlen(X)
 
-#endif /* MEMO_STRLEN */
+#endif				/* MEMO_STRLEN */
 
 #endif				/* Storage_h */
 
diff --git a/server/str_intern.c b/server/str_intern.c
index 99adf8f..e7f8716 100644
--- a/server/str_intern.c
+++ b/server/str_intern.c
@@ -33,16 +33,20 @@ struct intern_entry_hunk {
 static struct intern_entry_hunk *intern_alloc = NULL;
 
 static struct intern_entry_hunk *
-new_intern_entry_hunk(int size) 
+new_intern_entry_hunk(int size)
 {
     struct intern_entry_hunk *_new;
-    
-    _new = (intern_entry_hunk *) mymalloc(sizeof(struct intern_entry_hunk), M_INTERN_HUNK);
+
+    _new =
+	(intern_entry_hunk *) mymalloc(sizeof(struct intern_entry_hunk),
+				       M_INTERN_HUNK);
     _new->size = size;
     _new->handout = 0;
-    _new->contents = (intern_entry *) mymalloc(sizeof(struct intern_entry) * size, M_INTERN_ENTRY);
+    _new->contents =
+	(intern_entry *) mymalloc(sizeof(struct intern_entry) * size,
+				  M_INTERN_ENTRY);
     _new->next = NULL;
-    
+
     return _new;
 }
 
@@ -54,22 +58,23 @@ static struct intern_entry *
 allocate_intern_entry(void)
 {
     if (intern_alloc == NULL) {
-        intern_alloc = new_intern_entry_hunk(INTERN_ENTRY_HUNK_SIZE);
+	intern_alloc = new_intern_entry_hunk(INTERN_ENTRY_HUNK_SIZE);
     }
-    
-    if (intern_alloc->handout  < intern_alloc->size) {
-        struct intern_entry *e;
-        
-        e = &(intern_alloc->contents[intern_alloc->handout]);
-        intern_alloc->handout++;
-        
-        return e;
+
+    if (intern_alloc->handout < intern_alloc->size) {
+	struct intern_entry *e;
+
+	e = &(intern_alloc->contents[intern_alloc->handout]);
+	intern_alloc->handout++;
+
+	return e;
     } else {
-        struct intern_entry_hunk *new_hunk = new_intern_entry_hunk(INTERN_ENTRY_HUNK_SIZE);
-        
-        new_hunk->next = intern_alloc;
-        intern_alloc = new_hunk;
-        return allocate_intern_entry();
+	struct intern_entry_hunk *new_hunk =
+	    new_intern_entry_hunk(INTERN_ENTRY_HUNK_SIZE);
+
+	new_hunk->next = intern_alloc;
+	intern_alloc = new_hunk;
+	return allocate_intern_entry();
     }
 }
 
@@ -77,13 +82,13 @@ static void
 free_intern_entry_hunks(void)
 {
     struct intern_entry_hunk *h, *next;
-    
+
     for (h = intern_alloc; h; h = next) {
-        next = h->next;
-        myfree(h->contents, M_INTERN_ENTRY);
-        myfree(h, M_INTERN_HUNK);
+	next = h->next;
+	myfree(h->contents, M_INTERN_ENTRY);
+	myfree(h, M_INTERN_HUNK);
     }
-    
+
     intern_alloc = NULL;
 }
 
@@ -99,28 +104,31 @@ static int intern_allocations_saved = 0;
 #define INTERN_TABLE_SIZE_INITIAL 10007
 
 static struct intern_entry **
-make_intern_table(int size) {
+make_intern_table(int size)
+{
     struct intern_entry **table;
     int i;
 
-    table = (intern_entry **) mymalloc(sizeof(struct intern_entry *) * size, M_INTERN_POINTER);
+    table =
+	(intern_entry **) mymalloc(sizeof(struct intern_entry *) * size,
+				   M_INTERN_POINTER);
     for (i = 0; i < size; i++) {
-        table[i] = NULL;
+	table[i] = NULL;
     }
-    
+
     return table;
 }
 
 
-void 
+void
 str_intern_open(int table_size)
 {
     if (table_size == 0) {
-        table_size = INTERN_TABLE_SIZE_INITIAL;
+	table_size = INTERN_TABLE_SIZE_INITIAL;
     }
     intern_table = make_intern_table(table_size);
     intern_table_size = table_size;
-    
+
     intern_bytes_saved = 0;
     intern_allocations_saved = 0;
 }
@@ -130,24 +138,26 @@ str_intern_close(void)
 {
     int i;
     struct intern_entry *e, *next;
-    
+
     for (i = 0; i < intern_table_size; i++) {
-        for (e = intern_table[i]; e; e = next) {
-            next = e->next;
-            
-            free_str(e->s);
-            
-            /* myfree(e, M_INTERN_ENTRY); */
-        }
+	for (e = intern_table[i]; e; e = next) {
+	    next = e->next;
+
+	    free_str(e->s);
+
+	    /* myfree(e, M_INTERN_ENTRY); */
+	}
     }
-    
+
     myfree(intern_table, M_INTERN_POINTER);
     intern_table = NULL;
-    
+
     free_intern_entry_hunks();
-    
-    oklog("INTERN: %d allocations saved, %d bytes\n", intern_allocations_saved, intern_bytes_saved);
-    oklog("INTERN: at end, %d entries in a %d bucket hash table.\n", intern_table_count, intern_table_size);
+
+    oklog("INTERN: %d allocations saved, %d bytes\n",
+	  intern_allocations_saved, intern_bytes_saved);
+    oklog("INTERN: at end, %d entries in a %d bucket hash table.\n",
+	  intern_table_count, intern_table_size);
 }
 
 static struct intern_entry *
@@ -155,15 +165,15 @@ find_interned_string(const char *s, unsigned hash)
 {
     int bucket = hash % intern_table_size;
     struct intern_entry *p;
-    
+
     for (p = intern_table[bucket]; p; p = p->next) {
-        if (hash == p->hash) {
-            if (!strcmp(s, p->s)) {
-                return p;
-            }
-        }
+	if (hash == p->hash) {
+	    if (!strcmp(s, p->s)) {
+		return p;
+	    }
+	}
     }
-    
+
     return NULL;
 }
 
@@ -174,44 +184,47 @@ add_interned_string(const char *s, unsigned hash)
 {
     int bucket = hash % intern_table_size;
     struct intern_entry *p;
-    
+
     /* p = mymalloc(sizeof(struct intern_entry), M_INTERN_ENTRY); */
     p = allocate_intern_entry();
     p->s = s;
     p->hash = hash;
     p->next = intern_table[bucket];
-    
+
     intern_table[bucket] = p;
 
     intern_table_count++;
 }
 
-static void 
-intern_rehash(int new_size) {
+static void
+intern_rehash(int new_size)
+{
     struct intern_entry **new_table;
     int i, count;
     struct intern_entry *e, *next;
-    
-    count =  0;
+
+    count = 0;
     new_table = make_intern_table(new_size);
-    
+
     for (i = 0; i < intern_table_size; i++) {
-        for (e = intern_table[i]; e; e = next) {
-            int new_bucket = e->hash % new_size;
-            /* Keep the next pointer, since we're gonna nuke it. */
-            next = e->next;
-            
-            e->next = new_table[new_bucket];
-            new_table[new_bucket] = e;
-            
-            count++;
-        }
+	for (e = intern_table[i]; e; e = next) {
+	    int new_bucket = e->hash % new_size;
+	    /* Keep the next pointer, since we're gonna nuke it. */
+	    next = e->next;
+
+	    e->next = new_table[new_bucket];
+	    new_table[new_bucket] = e;
+
+	    count++;
+	}
     }
-    
+
     if (count != intern_table_count) {
-        errlog("counted %d entries in intern hash table, but intern_table_count says %d!\n", count, intern_table_count);
+	errlog
+	    ("counted %d entries in intern hash table, but intern_table_count says %d!\n",
+	     count, intern_table_count);
     }
-    
+
     intern_table_size = new_size;
 
     myfree(intern_table, M_INTERN_POINTER);
@@ -227,55 +240,55 @@ str_intern(const char *s)
     struct intern_entry *e;
     unsigned hash;
     const char *r;
-    
+
     if (s == NULL || *s == '\0') {
-        /* str_dup already has a canonical empty string */
-        return str_dup(s);
+	/* str_dup already has a canonical empty string */
+	return str_dup(s);
     }
-    
+
     if (intern_table == NULL) {
-        return str_dup(s);
+	return str_dup(s);
     }
-    
+
     hash = str_hash(s);
-    
+
     e = find_interned_string(s, hash);
-    
+
     if (e != NULL) {
-        intern_allocations_saved++;
-        intern_bytes_saved += memo_strlen(e->s);
-        return str_ref(e->s);
+	intern_allocations_saved++;
+	intern_bytes_saved += memo_strlen(e->s);
+	return str_ref(e->s);
     }
-    
+
     if (intern_table_count > intern_table_size) {
-        intern_rehash(intern_table_size * 2);
+	intern_rehash(intern_table_size * 2);
     }
-    
+
     r = str_dup(s);
     r = str_ref(r);
     add_interned_string(r, hash);
-    
+
     return r;
 }
 
-#else /* STRING_INTERNING */
+#else				/* STRING_INTERNING */
 
 const char *
 str_intern(const char *s)
 {
-	return str_dup(s);
+    return str_dup(s);
 }
 
 void
 str_intern_close(void)
 {
-	;
+    ;
 }
 
 void
 str_intern_open(int table_size)
 {
-	;
+    ;
 }
 
-#endif /* STRING_INTERNING */
+#endif				/* STRING_INTERNING */
diff --git a/server/streams.c b/server/streams.c
index 131b3fa..b377dfd 100644
--- a/server/streams.c
+++ b/server/streams.c
@@ -62,7 +62,7 @@ void
 stream_delete_char(Stream * s)
 {
     if (s->current > 0)
-      s->current--;
+	s->current--;
 }
 
 void
@@ -132,7 +132,7 @@ dbl_fmt(void)
 }
 
 void
-stream_printf(Stream * s, const char *fmt,...)
+stream_printf(Stream * s, const char *fmt, ...)
 {
     char buffer[40];
     va_list args;
@@ -185,8 +185,9 @@ stream_printf(Stream * s, const char *fmt,...)
 		    width = width * 10 + c - '0';
 		    continue;
 		default:
-		    errlog("STREAM_PRINTF: Unknown format directive: %%%c\n",
-			   c);
+		    errlog
+			("STREAM_PRINTF: Unknown format directive: %%%c\n",
+			 c);
 		    goto abort;
 		}
 		break;
@@ -234,7 +235,8 @@ stream_length(Stream * s)
     return s->current;
 }
 
-char rcsid_streams[] = "$Id: streams.c,v 1.4 2006-12-06 23:57:51 wrog Exp $";
+char rcsid_streams[] =
+    "$Id: streams.c,v 1.4 2006-12-06 23:57:51 wrog Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/streams.h b/server/streams.h
index bca856d..1a3640b 100644
--- a/server/streams.h
+++ b/server/streams.h
@@ -30,7 +30,7 @@ extern Stream *new_stream(int size);
 extern void stream_add_char(Stream *, char);
 extern void stream_delete_char(Stream *);
 extern void stream_add_string(Stream *, const char *);
-extern void stream_printf(Stream *, const char *,...);
+extern void stream_printf(Stream *, const char *, ...);
 extern void free_stream(Stream *);
 extern char *stream_contents(Stream *);
 extern char *reset_stream(Stream *);
diff --git a/server/structures.h b/server/structures.h
index 1c787ee..dab7d99 100644
--- a/server/structures.h
+++ b/server/structures.h
@@ -39,7 +39,8 @@ typedef int32 Objid;
  */
 enum error {
     E_NONE, E_TYPE, E_DIV, E_PERM, E_PROPNF, E_VERBNF, E_VARNF, E_INVIND,
-    E_RECMOVE, E_MAXREC, E_RANGE, E_ARGS, E_NACC, E_INVARG, E_QUOTA, E_FLOAT
+    E_RECMOVE, E_MAXREC, E_RANGE, E_ARGS, E_NACC, E_INVARG, E_QUOTA,
+	E_FLOAT
 };
 
 /* Do not reorder or otherwise modify this list, except to add new elements at
@@ -50,25 +51,25 @@ enum error {
  */
 //typedef enum {
 //    TYPE_INT, TYPE_OBJ, _TYPE_STR, TYPE_ERR, _TYPE_LIST, /* user-visible */
-//    TYPE_CLEAR,			/* in clear properties' value slot */
-//    TYPE_NONE,			/* in uninitialized MOO variables */
-//    TYPE_CATCH,			/* on-stack marker for an exception handler */
-//    TYPE_FINALLY,		/* on-stack marker for a TRY-FINALLY clause */
-//    _TYPE_FLOAT			/* floating-point number; user-visible */
+//    TYPE_CLEAR,                       /* in clear properties' value slot */
+//    TYPE_NONE,                        /* in uninitialized MOO variables */
+//    TYPE_CATCH,                       /* on-stack marker for an exception handler */
+//    TYPE_FINALLY,             /* on-stack marker for a TRY-FINALLY clause */
+//    _TYPE_FLOAT                       /* floating-point number; user-visible */
 //} var_type;
 
 // the following replace the above typdef enum var_type
 typedef int var_type;
-const var_type TYPE_INT     =  0 ;
-const var_type TYPE_OBJ     =  1 ;
-const var_type _TYPE_STR    =  2 ;
-const var_type TYPE_ERR     =  3 ;
-const var_type _TYPE_LIST   =  4 ;
-const var_type TYPE_CLEAR   =  5 ;
-const var_type TYPE_NONE    =  6 ;
-const var_type TYPE_CATCH   =  7 ;
-const var_type TYPE_FINALLY =  8 ;
-const var_type _TYPE_FLOAT  =  9 ;
+const var_type TYPE_INT = 0;
+const var_type TYPE_OBJ = 1;
+const var_type _TYPE_STR = 2;
+const var_type TYPE_ERR = 3;
+const var_type _TYPE_LIST = 4;
+const var_type TYPE_CLEAR = 5;
+const var_type TYPE_NONE = 6;
+const var_type TYPE_CATCH = 7;
+const var_type TYPE_FINALLY = 8;
+const var_type _TYPE_FLOAT = 9;
 
 /* Types which have external data should be marked with the TYPE_COMPLEX_FLAG
  * so that free_var/var_ref/var_dup can recognize them easily.  This flag is
diff --git a/server/sym_table.c b/server/sym_table.c
index 4a4aa2c..4bd5b24 100644
--- a/server/sym_table.c
+++ b/server/sym_table.c
@@ -32,7 +32,8 @@ new_names(unsigned max_size)
 {
     Names *names = (Names *) mymalloc(sizeof(Names), M_NAMES);
 
-    names->names = (const char **) mymalloc(sizeof(char *) * max_size, M_NAMES);
+    names->names =
+	(const char **) mymalloc(sizeof(char *) * max_size, M_NAMES);
     names->max_size = max_size;
     names->size = 0;
 
@@ -126,7 +127,7 @@ find_or_add_name(Names ** names, const char *str)
 
 	for (i = 0; i < old_max; i++) {
 	    _new->names[i] = (*names)->names[i];
-        }
+	}
 	_new->size = old_max;
 	myfree((*names)->names, M_NAMES);
 	myfree(*names, M_NAMES);
@@ -147,7 +148,8 @@ free_names(Names * names)
     myfree(names, M_NAMES);
 }
 
-char rcsid_sym_table[] = "$Id: sym_table.c,v 1.3 1998-12-14 13:19:05 nop Exp $";
+char rcsid_sym_table[] =
+    "$Id: sym_table.c,v 1.3 1998-12-14 13:19:05 nop Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/tasks.c b/server/tasks.c
index 01c24bf..c97209f 100644
--- a/server/tasks.c
+++ b/server/tasks.c
@@ -49,10 +49,10 @@
 
 typedef enum {
     /* Input Tasks */
-    TASK_INBAND,	/* vanilla in-band */
-    TASK_OOB,		/* out-of-band unless disable_oob */
-    TASK_QUOTED,	/* in-band; needs unquote unless disable-oob */
-    TASK_BINARY,	/* in-band; binary mode string */
+    TASK_INBAND,		/* vanilla in-band */
+    TASK_OOB,			/* out-of-band unless disable_oob */
+    TASK_QUOTED,		/* in-band; needs unquote unless disable-oob */
+    TASK_BINARY,		/* in-band; binary mode string */
     /* Background Tasks */
     TASK_FORKED,
     TASK_SUSPENDED
@@ -76,7 +76,7 @@ typedef struct suspended_task {
 typedef struct {
     char *string;
     int length;
-    struct task *next_itail;	/* see tqueue.first_itail */ 
+    struct task *next_itail;	/* see tqueue.first_itail */
 } input_task;
 
 typedef struct task {
@@ -91,13 +91,13 @@ typedef struct task {
 
 enum icmd_flag {
     /* fix icmd_index() if you change any of the following numbers: */
-    ICMD_SUFFIX       = 1,
+    ICMD_SUFFIX = 1,
     ICMD_OUTPUTSUFFIX = 2,
     ICMD_OUTPUTPREFIX = 3,
-    ICMD_PREFIX       = 4,
-    ICMD_PROGRAM      = 5,  /* .program */
+    ICMD_PREFIX = 4,
+    ICMD_PROGRAM = 5,		/* .program */
     /* mask */
-    ICMD_ALL_CMDS = ((1<<(ICMD_PROGRAM+1))-2)
+    ICMD_ALL_CMDS = ((1 << (ICMD_PROGRAM + 1)) - 2)
 };
 
 typedef struct tqueue {
@@ -186,117 +186,110 @@ static ext_queue *external_queues = 0;
 static void
 double_to_timeval(double d, struct timeval *tv)
 {
-  double secs, usecs, frac;
+    double secs, usecs, frac;
 
-  frac = modf(d, &secs);
-  usecs = ((double) 1000000) * frac;
+    frac = modf(d, &secs);
+    usecs = ((double) 1000000) * frac;
 
-  tv->tv_sec  = (long) secs;
-  tv->tv_usec = (long) usecs;
+    tv->tv_sec = (long) secs;
+    tv->tv_usec = (long) usecs;
 
-  return;
+    return;
 }
 
 static double
 timeval_to_double(struct timeval *tv)
 {
-  double r;
+    double r;
 
-  r  = tv->tv_sec;
-  r += tv->tv_usec / ((double) 1000000);
+    r = tv->tv_sec;
+    r += tv->tv_usec / ((double) 1000000);
 
-  return r;
+    return r;
 }
 
 static int
 timeval_lt(struct timeval *tv1, struct timeval *tv2)
 /* Returns true if tv1 is less than tv2. If either arg is NULL, time 0 is assumed. */
 {
-  long secs1, usecs1;
-  long secs2, usecs2;
-
-  if (tv1 == NULL)
-  {
-    secs1  = 0;
-    usecs1 = 0;
-  }
-  else
-  {
-    secs1  = tv1->tv_sec;
-    usecs1 = tv1->tv_usec;
-  }
-
-  if (tv2 == NULL)
-  {
-    secs2  = 0;
-    usecs2 = 0;
-  }
-  else
-  {
-    secs2  = tv2->tv_sec;
-    usecs2 = tv2->tv_usec;
-  }
-
-  if (secs1 < secs2)
-    return 1;
+    long secs1, usecs1;
+    long secs2, usecs2;
 
-  if ((secs1 == secs2) && (usecs1 < usecs2))
-    return 1;
+    if (tv1 == NULL) {
+	secs1 = 0;
+	usecs1 = 0;
+    } else {
+	secs1 = tv1->tv_sec;
+	usecs1 = tv1->tv_usec;
+    }
+
+    if (tv2 == NULL) {
+	secs2 = 0;
+	usecs2 = 0;
+    } else {
+	secs2 = tv2->tv_sec;
+	usecs2 = tv2->tv_usec;
+    }
+
+    if (secs1 < secs2)
+	return 1;
 
-  return 0;
+    if ((secs1 == secs2) && (usecs1 < usecs2))
+	return 1;
+
+    return 0;
 }
 
 static void
-timeval_add(struct timeval *result, struct timeval *tv1, struct timeval *tv2)
+timeval_add(struct timeval *result, struct timeval *tv1,
+	    struct timeval *tv2)
 /* Adds *tv1 and *tv2 and writes the result to *result. */
 /* Neither *tv1 nor *tv2 should have negative fields. */
 /* It's safe to have (result == tv1) || (result == tv2) */
 {
-  struct timeval sum;
+    struct timeval sum;
 
-  sum.tv_sec  = tv1->tv_sec;
-  sum.tv_sec += tv2->tv_sec;
+    sum.tv_sec = tv1->tv_sec;
+    sum.tv_sec += tv2->tv_sec;
 
-  sum.tv_usec  = tv1->tv_usec;
-  sum.tv_usec += tv2->tv_usec;
+    sum.tv_usec = tv1->tv_usec;
+    sum.tv_usec += tv2->tv_usec;
 
-  if (sum.tv_usec >= 1000000)
-  {
-    /* Microsecond carry */
-    sum.tv_sec += sum.tv_usec / 1000000;
-    sum.tv_usec %= 1000000;
-  }
+    if (sum.tv_usec >= 1000000) {
+	/* Microsecond carry */
+	sum.tv_sec += sum.tv_usec / 1000000;
+	sum.tv_usec %= 1000000;
+    }
 
-  if ((sum.tv_sec < tv1->tv_sec) || (sum.tv_sec < tv2->tv_sec))
-  {
-    /* Seconds overflow */
-    sum.tv_sec = INT_MAX;
-  }
+    if ((sum.tv_sec < tv1->tv_sec) || (sum.tv_sec < tv2->tv_sec)) {
+	/* Seconds overflow */
+	sum.tv_sec = INT_MAX;
+    }
 
-  *result = sum;
+    *result = sum;
 }
 
 static void
-timeval_sub(struct timeval *result, struct timeval *tv1, struct timeval *tv2)
+timeval_sub(struct timeval *result, struct timeval *tv1,
+	    struct timeval *tv2)
 /* Subtracts *tv2 from *tv1 and stores the result in *result. */
 /* It's safe to have (result == tv1) || (result == tv2) */
 {
-  struct timeval diff;
+    struct timeval diff;
 
-  diff.tv_sec  = tv1->tv_sec;
-  diff.tv_usec = tv1->tv_usec;
+    diff.tv_sec = tv1->tv_sec;
+    diff.tv_usec = tv1->tv_usec;
 
-  diff.tv_sec  -= tv2->tv_sec;
-  diff.tv_usec -= tv2->tv_usec;
+    diff.tv_sec -= tv2->tv_sec;
+    diff.tv_usec -= tv2->tv_usec;
 
-  if (diff.tv_usec < 0)
-  {
-    /* Microsecond borrow */
-    diff.tv_sec -= ((-diff.tv_usec) / 1000000) + 1;
-    diff.tv_usec = 1000000 - ((-diff.tv_usec) % 1000000);
-  }
+    if (diff.tv_usec < 0) {
+	/* Microsecond borrow */
+	diff.tv_sec -= ((-diff.tv_usec) / 1000000) + 1;
+	diff.tv_usec = 1000000 - ((-diff.tv_usec) % 1000000);
+    }
 
-  *result = diff;
+    *result = diff;
 }
 
 /* 
@@ -322,12 +315,13 @@ timeval_sub(struct timeval *result, struct timeval *tv1, struct timeval *tv2)
       __IDLM(DEFINE,OUTPUTSUFFIX,(verb))		\
 
 static int
-icmd_index(const char * verb) {
+icmd_index(const char *verb)
+{
     /* evil, poor-man's minimal perfect hash */
     int len = strlen(verb);
     char c2 = len > 2 ? verb[2] : 0;
     char c8 = len > 8 ? verb[8] : 0;
-    switch (((c2&7)^6)+!(c8&2)) {
+    switch (((c2 & 7) ^ 6) + !(c8 & 2)) {
     default:
 	break;
 #define _ICMD_IX(ICMD_PREFIX,_,MATCH)		\
@@ -335,10 +329,11 @@ icmd_index(const char * verb) {
 	    if (MATCH) return ICMD_PREFIX;	\
 	    break;				\
 
-	ICMD_FOR_EACH(_ICMD_IX,verb);
+	ICMD_FOR_EACH(_ICMD_IX, verb);
     }
     return 0;
 }
+
 #undef _ICMD_IX
 
 static Var
@@ -353,9 +348,10 @@ icmd_list(int icmd_flags)
 	    list = listappend(list, s);		\
 	}					\
 
-    ICMD_FOR_EACH(_ICMD_MKSTR,@);
+    ICMD_FOR_EACH(_ICMD_MKSTR, @);
     return list;
 }
+
 #undef _ICMD_MKSTR
 
 static int
@@ -365,8 +361,7 @@ icmd_set_flags(tqueue * tq, Var list)
     int newflags;
     if (list.type == TYPE_INT) {
 	newflags = is_true(list) ? ICMD_ALL_CMDS : 0;
-    }
-    else if(list.type != TYPE_LIST)
+    } else if (list.type != TYPE_LIST)
 	return 0;
     else {
 	newflags = 0;
@@ -377,7 +372,7 @@ icmd_set_flags(tqueue * tq, Var list)
 	    icmd = icmd_index(list.v.list[i].v.str);
 	    if (!icmd)
 		return 0;
-	    newflags |= (1<<icmd);
+	    newflags |= (1 << icmd);
 	}
     }
     tq->icmds = newflags;
@@ -429,7 +424,8 @@ ensure_usage(tqueue * tq)
 char *
 default_flush_command(void)
 {
-    const char *str = server_string_option("default_flush_command", ".flush");
+    const char *str =
+	server_string_option("default_flush_command", ".flush");
 
     return (str && str[0] != '\0') ? str_dup(str) : 0;
 }
@@ -545,11 +541,10 @@ dequeue_input_task(tqueue * tq, enum dequeue_how how)
     if (!tq->first_input)
 	return 0;
     else if (how == (tq->first_input->kind == TASK_OOB)) {
-	pt     = &(tq->first_itail->next);
+	pt = &(tq->first_itail->next);
 	pitail = &(tq->first_itail->t.input.next_itail);
-    }
-    else {
-	pt     = &(tq->first_input);
+    } else {
+	pt = &(tq->first_input);
 	pitail = &(tq->first_itail);
     }
     t = *pt;
@@ -573,8 +568,7 @@ dequeue_input_task(tqueue * tq, enum dequeue_how how)
 
 	tq->total_input_length -= t->t.input.length;
 	if (tq->input_suspended
-	    && tq->connected
-	    && tq->total_input_length < INPUT_LOWAT) {
+	    && tq->connected && tq->total_input_length < INPUT_LOWAT) {
 	    server_resume_input(tq->player);
 	    tq->input_suspended = 0;
 	}
@@ -582,12 +576,12 @@ dequeue_input_task(tqueue * tq, enum dequeue_how how)
 	if (t->kind == TASK_OOB) {
 	    if (tq->disable_oob)
 		t->kind = TASK_INBAND;
-	}
-	else if (t->kind == TASK_QUOTED) {
-	    if (!tq->disable_oob) 
+	} else if (t->kind == TASK_QUOTED) {
+	    if (!tq->disable_oob)
 		memmove(t->t.input.string,
-			t->t.input.string + oob_quote_prefix_length, 
-			1 + strlen(t->t.input.string + oob_quote_prefix_length));
+			t->t.input.string + oob_quote_prefix_length,
+			1 + strlen(t->t.input.string +
+				   oob_quote_prefix_length));
 	    t->kind = TASK_INBAND;
 	}
     }
@@ -662,7 +656,7 @@ struct state {
 static void
 my_error(void *data, const char *msg)
 {
-  struct state *s = (state *) data;
+    struct state *s = (state *) data;
 
     notify(s->player, msg);
     s->nerrors++;
@@ -671,7 +665,7 @@ my_error(void *data, const char *msg)
 static int
 my_getc(void *data)
 {
-  struct state *s = (state *) data;
+    struct state *s = (state *) data;
 
     if (*(s->input) != '\0')
 	return *(s->input++);
@@ -679,8 +673,7 @@ my_getc(void *data)
 	return EOF;
 }
 
-static Parser_Client client =
-{my_error, 0, my_getc};
+static Parser_Client client = { my_error, 0, my_getc };
 
 static void
 end_programming(tqueue * tq)
@@ -760,10 +753,10 @@ static int
 do_intrinsic_command(tqueue * tq, Parsed_Command * pc)
 {
     int icmd = icmd_index(pc->verb);
-    if (!(icmd && (tq->icmds & (1<<icmd))))
+    if (!(icmd && (tq->icmds & (1 << icmd))))
 	return 0;
     switch (icmd) {
-    default: 
+    default:
 	panic("Bad return value from icmd_index()");
 	break;
     case ICMD_PROGRAM:
@@ -771,10 +764,10 @@ do_intrinsic_command(tqueue * tq, Parsed_Command * pc)
 	    return 0;
 	if (pc->args.v.list[0].v.num != 1)
 	    notify(tq->player, "Usage:  .program object:verb");
-	else	
+	else
 	    start_programming(tq, (char *) pc->args.v.list[1].v.str);
 	break;
-    case ICMD_PREFIX:	
+    case ICMD_PREFIX:
     case ICMD_OUTPUTPREFIX:
 	set_delimiter(&(tq->output_prefix), pc->argstr);
 	break;
@@ -798,12 +791,12 @@ do_command_task(tqueue * tq, char *command)
     } else {
 	Parsed_Command *pc = parse_command(command, tq->player);
 
-        {
-            char *s = str_dup("");
-            run_server_task(tq->player, SYSTEM_OBJECT, "do_prompt",
-                            parse_into_wordlist(s), s, 0);
-            free_str(s);
-        }
+	{
+	    char *s = str_dup("");
+	    run_server_task(tq->player, SYSTEM_OBJECT, "do_prompt",
+			    parse_into_wordlist(s), s, 0);
+	    free_str(s);
+	}
 
 	if (!pc)
 	    return 0;
@@ -823,17 +816,17 @@ do_command_task(tqueue * tq, char *command)
 	    args = parse_into_wordlist(command);
 	    if (run_server_task_setting_id(tq->player, tq->handler,
 					   "do_command", args, command,
-				      &result, &(tq->last_input_task_id))
-		!= OUTCOME_DONE
-		|| is_true(result)) {
+					   &result,
+					   &(tq->last_input_task_id))
+		!= OUTCOME_DONE || is_true(result)) {
 		/* Do nothing more; we assume :do_command handled it. */
 	    } else if (find_verb_on(self = tq->player, pc, &vh)
 		       || find_verb_on(self = location, pc, &vh)
 		       || find_verb_on(self = pc->dobj, pc, &vh)
 		       || find_verb_on(self = pc->iobj, pc, &vh)
 		       || (valid(self = location)
-			 && (vh = db_find_callable_verb(location, "huh"),
-			     vh.ptr))) {
+			   && (vh = db_find_callable_verb(location, "huh"),
+			       vh.ptr))) {
 		do_input_task(tq->player, pc, self, vh);
 	    } else {
 		notify(tq->player, "I couldn't understand that.");
@@ -845,12 +838,12 @@ do_command_task(tqueue * tq, char *command)
 
 	    free_var(result);
 
-            {
-                char *s = str_dup("");
-                run_server_task(tq->player, SYSTEM_OBJECT, "do_prompt",
-                                parse_into_wordlist(s), s, 0);
-                free_str(s);
-            }
+	    {
+		char *s = str_dup("");
+		run_server_task(tq->player, SYSTEM_OBJECT, "do_prompt",
+				parse_into_wordlist(s), s, 0);
+		free_str(s);
+	    }
 	}
 
 	free_parsed_command(pc);
@@ -903,7 +896,8 @@ do_login_task(tqueue * tq, char *command)
 	    dead_tq->player = NOTHING;	/* it'll be freed by run_ready_tasks */
 	    dead_tq->num_bg_tasks = 0;
 	}
-	player_connected(old_player, new_player, new_player > old_max_object);
+	player_connected(old_player, new_player,
+			 new_player > old_max_object);
     }
     free_var(result);
     return 1;
@@ -992,106 +986,153 @@ free_task_queue(task_queue q)
 	       if (!icmd_set_flags(tq, value))				\
 		   return 0;						\
 	   })								\
-    /*
-int
-tasks_set_connection_option(task_queue q, const char *option, Var value)
-{
-    CONNECTION_OPTION_SET(TASK_CO_TABLE, (tqueue *)q.ptr, option, value);
-}
-
-int
-tasks_connection_option(task_queue q, const char *option, Var * value)
-{
-    CONNECTION_OPTION_GET(TASK_CO_TABLE, (tqueue *)q.ptr, option, value);
-}
-
-Var
-tasks_connection_options(task_queue q, Var list)
-{
-    CONNECTION_OPTION_LIST(TASK_CO_TABLE, (tqueue *)q.ptr, list);
-}
-    */
+				/*
+				   int
+				   tasks_set_connection_option(task_queue q, const char *option, Var value)
+				   {
+				   CONNECTION_OPTION_SET(TASK_CO_TABLE, (tqueue *)q.ptr, option, value);
+				   }
+
+				   int
+				   tasks_connection_option(task_queue q, const char *option, Var * value)
+				   {
+				   CONNECTION_OPTION_GET(TASK_CO_TABLE, (tqueue *)q.ptr, option, value);
+				   }
+
+				   Var
+				   tasks_connection_options(task_queue q, Var list)
+				   {
+				   CONNECTION_OPTION_LIST(TASK_CO_TABLE, (tqueue *)q.ptr, list);
+				   }
+				 */
 
 int
 tasks_set_connection_option(task_queue q, const char *option, Var value)
 {
-  do { if (!mystrcasecmp((option), "flush-command")) { { if (((tqueue *)q.ptr)->flush_cmd) free_str(((tqueue *)q.ptr)->flush_cmd);
-        if ((value).type == (_TYPE_STR | 0x80) && (value).v.str[0] != '\0') ((tqueue *)q.ptr)->flush_cmd = str_ref((value).v.str);
-        else ((tqueue *)q.ptr)->flush_cmd = 0;
-      };
-      return 1;
-    } if (!mystrcasecmp((option), "hold-input")) { { ((tqueue *)q.ptr)->hold_input = is_true((value));
-        if (!((tqueue *)q.ptr)->hold_input && ((tqueue *)q.ptr)->first_input) ensure_usage(((tqueue *)q.ptr));
-      };
-      return 1;
-    } if (!mystrcasecmp((option), "disable-oob")) { { ((tqueue *)q.ptr)->disable_oob = is_true((value));
-        if (!((tqueue *)q.ptr)->disable_oob && ((tqueue *)q.ptr)->first_input && (((tqueue *)q.ptr)->first_itail->next || ((tqueue *)q.ptr)->first_input->kind == TASK_OOB)) ensure_usage(((tqueue *)q.ptr));
-      };
-      return 1;
-    } if (!mystrcasecmp((option), "intrinsic-commands")) { { if (!icmd_set_flags(((tqueue *)q.ptr), (value))) return 0;
-      };
-      return 1;
-    } return 0;
-  } while (0);
+    do {
+	if (!mystrcasecmp((option), "flush-command")) { {
+		if (((tqueue *) q.ptr)->flush_cmd)
+		    free_str(((tqueue *) q.ptr)->flush_cmd);
+		if ((value).type == (_TYPE_STR | 0x80)
+		    && (value).v.str[0] != '\0')
+		    ((tqueue *) q.ptr)->flush_cmd = str_ref((value).v.str);
+		else
+		    ((tqueue *) q.ptr)->flush_cmd = 0;
+	};
+	return 1;
+	}
+	if (!mystrcasecmp((option), "hold-input")) { {
+		((tqueue *) q.ptr)->hold_input = is_true((value));
+		if (!((tqueue *) q.ptr)->hold_input
+		    && ((tqueue *) q.ptr)->first_input)
+		    ensure_usage(((tqueue *) q.ptr));
+	};
+	return 1;
+	}
+	if (!mystrcasecmp((option), "disable-oob")) { {
+		((tqueue *) q.ptr)->disable_oob = is_true((value));
+		if (!((tqueue *) q.ptr)->disable_oob
+		    && ((tqueue *) q.ptr)->first_input
+		    && (((tqueue *) q.ptr)->first_itail->next
+			|| ((tqueue *) q.ptr)->first_input->kind ==
+			TASK_OOB))
+		    ensure_usage(((tqueue *) q.ptr));
+	};
+	return 1;
+	}
+	if (!mystrcasecmp((option), "intrinsic-commands")) { {
+		if (!icmd_set_flags(((tqueue *) q.ptr), (value)))
+		    return 0;
+	};
+	return 1;
+	}
+	return 0;
+    } while (0);
 
 }
 
 int
 tasks_connection_option(task_queue q, const char *option, Var * value)
 {
-  do { if (!mystrcasecmp((option), "flush-command")) { (value)->type = (var_type) ((_TYPE_STR | 0x80));
-      (value)->v.str = (((tqueue *)q.ptr)->flush_cmd ? str_ref(((tqueue *)q.ptr)->flush_cmd) : str_dup(""));
-      return 1;
-    } if (!mystrcasecmp((option), "hold-input")) { (value)->type = (TYPE_INT);
-      (value)->v.num = (((tqueue *)q.ptr)->hold_input);
-      return 1;
-    } if (!mystrcasecmp((option), "disable-oob")) { (value)->type = (TYPE_INT);
-      (value)->v.num = (((tqueue *)q.ptr)->disable_oob);
-      return 1;
-    } if (!mystrcasecmp((option), "intrinsic-commands")) { (value)->type = (var_type) ((_TYPE_LIST | 0x80));
-      (value)->v.list = (icmd_list(((tqueue *)q.ptr)->icmds).v.list);
-      return 1;
-    } return 0;
-  } while (0);
+    do {
+	if (!mystrcasecmp((option), "flush-command")) {
+	    (value)->type = (var_type) ((_TYPE_STR | 0x80));
+	    (value)->v.str =
+		(((tqueue *) q.ptr)->
+		 flush_cmd ? str_ref(((tqueue *) q.ptr)->
+				     flush_cmd) : str_dup(""));
+	    return 1;
+	}
+	if (!mystrcasecmp((option), "hold-input")) {
+	    (value)->type = (TYPE_INT);
+	    (value)->v.num = (((tqueue *) q.ptr)->hold_input);
+	    return 1;
+	}
+	if (!mystrcasecmp((option), "disable-oob")) {
+	    (value)->type = (TYPE_INT);
+	    (value)->v.num = (((tqueue *) q.ptr)->disable_oob);
+	    return 1;
+	}
+	if (!mystrcasecmp((option), "intrinsic-commands")) {
+	    (value)->type = (var_type) ((_TYPE_LIST | 0x80));
+	    (value)->v.list =
+		(icmd_list(((tqueue *) q.ptr)->icmds).v.list);
+	    return 1;
+	}
+	return 0;
+    } while (0);
 
 }
 
 Var
 tasks_connection_options(task_queue q, Var list)
 {
-  do { { Var pair = new_list(2);
-      pair.v.list[1].type = (var_type) (_TYPE_STR | 0x80);
-      pair.v.list[1].v.str = str_dup("flush-command");
-      pair.v.list[2].type = (var_type) ((_TYPE_STR | 0x80));
-      pair.v.list[2].v.str = (((tqueue *)q.ptr)->flush_cmd ? str_ref(((tqueue *)q.ptr)->flush_cmd) : str_dup(""));
-      (list) = listappend((list), pair);
-    } { Var pair = new_list(2);
-      pair.v.list[1].type = (var_type) (_TYPE_STR | 0x80);
-      pair.v.list[1].v.str = str_dup("hold-input");
-      pair.v.list[2].type = (TYPE_INT);
-      pair.v.list[2].v.num = (((tqueue *)q.ptr)->hold_input);
-      (list) = listappend((list), pair);
-    } { Var pair = new_list(2);
-      pair.v.list[1].type = (var_type) (_TYPE_STR | 0x80);
-      pair.v.list[1].v.str = str_dup("disable-oob");
-      pair.v.list[2].type = (TYPE_INT);
-      pair.v.list[2].v.num = (((tqueue *)q.ptr)->disable_oob);
-      (list) = listappend((list), pair);
-    } { Var pair = new_list(2);
-      pair.v.list[1].type = (var_type) (_TYPE_STR | 0x80);
-      pair.v.list[1].v.str = str_dup("intrinsic-commands");
-      pair.v.list[2].type = (var_type) ((_TYPE_LIST | 0x80));
-      pair.v.list[2].v.list = (icmd_list(((tqueue *)q.ptr)->icmds).v.list);
-      (list) = listappend((list), pair);
-    } return (list);
-  } while (0);
+    do { {
+	    Var pair = new_list(2);
+	    pair.v.list[1].type = (var_type) (_TYPE_STR | 0x80);
+	    pair.v.list[1].v.str = str_dup("flush-command");
+	    pair.v.list[2].type = (var_type) ((_TYPE_STR | 0x80));
+	    pair.v.list[2].v.str =
+		(((tqueue *) q.ptr)->
+		 flush_cmd ? str_ref(((tqueue *) q.ptr)->
+				     flush_cmd) : str_dup(""));
+	    (list) = listappend((list), pair);
+    }
+    {
+	Var pair = new_list(2);
+	pair.v.list[1].type = (var_type) (_TYPE_STR | 0x80);
+	pair.v.list[1].v.str = str_dup("hold-input");
+	pair.v.list[2].type = (TYPE_INT);
+	pair.v.list[2].v.num = (((tqueue *) q.ptr)->hold_input);
+	(list) = listappend((list), pair);
+    }
+    {
+	Var pair = new_list(2);
+	pair.v.list[1].type = (var_type) (_TYPE_STR | 0x80);
+	pair.v.list[1].v.str = str_dup("disable-oob");
+	pair.v.list[2].type = (TYPE_INT);
+	pair.v.list[2].v.num = (((tqueue *) q.ptr)->disable_oob);
+	(list) = listappend((list), pair);
+    }
+    {
+	Var pair = new_list(2);
+	pair.v.list[1].type = (var_type) (_TYPE_STR | 0x80);
+	pair.v.list[1].v.str = str_dup("intrinsic-commands");
+	pair.v.list[2].type = (var_type) ((_TYPE_LIST | 0x80));
+	pair.v.list[2].v.list =
+	    (icmd_list(((tqueue *) q.ptr)->icmds).v.list);
+	(list) = listappend((list), pair);
+    }
+    return (list);
+    } while (0);
 
 }
 
 #undef TASK_CO_TABLE
 
 static void
-enqueue_input_task(tqueue * tq, const char *input, int at_front, int binary)
+enqueue_input_task(tqueue * tq, const char *input, int at_front,
+		   int binary)
 {
     static char oob_prefix[] = OUT_OF_BAND_PREFIX;
     task *t;
@@ -1100,7 +1141,8 @@ enqueue_input_task(tqueue * tq, const char *input, int at_front, int binary)
     if (binary)
 	t->kind = TASK_BINARY;
     else if (oob_quote_prefix_length > 0
-	     && strncmp(oob_quote_prefix, input, oob_quote_prefix_length) == 0)
+	     && strncmp(oob_quote_prefix, input,
+			oob_quote_prefix_length) == 0)
 	t->kind = TASK_QUOTED;
     else if (sizeof(oob_prefix) > 1
 	     && strncmp(oob_prefix, input, sizeof(oob_prefix) - 1) == 0)
@@ -1121,8 +1163,7 @@ enqueue_input_task(tqueue * tq, const char *input, int at_front, int binary)
 	}
 	t->next = tq->first_input;
 	tq->first_input = t;
-    }
-    else {
+    } else {
 	if (tq->first_input && (((*(tq->last_itail))->kind == TASK_OOB)
 				!= (t->kind == TASK_OOB)))
 	    tq->last_itail = &((*(tq->last_itail))->t.input.next_itail);
@@ -1139,8 +1180,7 @@ enqueue_input_task(tqueue * tq, const char *input, int at_front, int binary)
 	ensure_usage(tq);
 
     if (!tq->input_suspended
-	&& tq->connected
-	&& tq->total_input_length > INPUT_HIWAT) {
+	&& tq->connected && tq->total_input_length > INPUT_HIWAT) {
 	server_suspend_input(tq->player);
 	tq->input_suspended = 1;
     }
@@ -1149,7 +1189,7 @@ enqueue_input_task(tqueue * tq, const char *input, int at_front, int binary)
 void
 task_suspend_input(task_queue q)
 {
-  tqueue *tq = (tqueue *) q.ptr;
+    tqueue *tq = (tqueue *) q.ptr;
 
     if (!tq->input_suspended && tq->connected) {
 	server_suspend_input(tq->player);
@@ -1183,13 +1223,13 @@ flush_input(tqueue * tq, int show_messages)
 void
 new_input_task(task_queue q, const char *input, int binary)
 {
-  tqueue *tq = (tqueue *) q.ptr;
+    tqueue *tq = (tqueue *) q.ptr;
 
     if (tq->flush_cmd && mystrcasecmp(input, tq->flush_cmd) == 0) {
 	flush_input(tq, 1);
 	return;
     }
-    enqueue_input_task(tq, input, 0/*at-rear*/, binary);
+    enqueue_input_task(tq, input, 0 /*at-rear */ , binary);
 }
 
 static void
@@ -1203,7 +1243,8 @@ enqueue_waiting(task * t)
     tqueue *tq = find_tqueue(progr, 1);
 
     tq->num_bg_tasks++;
-    if (!waiting_tasks || timeval_lt(&start_time, &GET_START_TIME(waiting_tasks))) {
+    if (!waiting_tasks
+	|| timeval_lt(&start_time, &GET_START_TIME(waiting_tasks))) {
 	t->next = waiting_tasks;
 	waiting_tasks = t;
     } else {
@@ -1268,7 +1309,8 @@ check_user_task_limit(Objid user)
 }
 
 enum error
-enqueue_forked_task2(activation a, int f_index, unsigned after_seconds, int vid)
+enqueue_forked_task2(activation a, int f_index, unsigned after_seconds,
+		     int vid)
 {
     int id;
     Var *rt_env;
@@ -1309,7 +1351,7 @@ enqueue_suspended_task(vm the_vm, void *data)
 	t = (task *) mymalloc(sizeof(task), M_TASK);
 	t->kind = TASK_SUSPENDED;
 	t->t.suspended.the_vm = the_vm;
-        timeval_add(&t->t.suspended.start_time, &now, &wait);
+	timeval_add(&t->t.suspended.start_time, &now, &wait);
 	t->t.suspended.value = zero;
 
 	enqueue_waiting(t);
@@ -1327,7 +1369,7 @@ resume_task(vm the_vm, Var value)
 
     t->kind = TASK_SUSPENDED;
     t->t.suspended.the_vm = the_vm;
-    double_to_timeval(0.0, &t->t.suspended.start_time);  /* ready now */
+    double_to_timeval(0.0, &t->t.suspended.start_time);	/* ready now */
     t->t.suspended.value = value;
 
     enqueue_bg_task(tq, t);
@@ -1387,28 +1429,28 @@ next_task_start(struct timeval *tv)
     tqueue *tq;
 
     for (tq = active_tqueues; tq; tq = tq->next)
-	if (tq->first_input != 0 || tq->first_bg != 0)
-        {
-            tv->tv_sec  = 0;
-            tv->tv_usec = 0;
+	if (tq->first_input != 0 || tq->first_bg != 0) {
+	    tv->tv_sec = 0;
+	    tv->tv_usec = 0;
 	    return 1;
-        }
+	}
 
     if (waiting_tasks != 0) {
-        struct timeval wait;
-        struct timeval now;
-        struct timeval zero;
+	struct timeval wait;
+	struct timeval now;
+	struct timeval zero;
 
-        zero.tv_sec = 0;
-        zero.tv_usec = 0;
+	zero.tv_sec = 0;
+	zero.tv_usec = 0;
 
-        gettimeofday(&now, NULL);
+	gettimeofday(&now, NULL);
 
 	timeval_sub(&wait, &(waiting_tasks->kind == TASK_FORKED
-		           ? waiting_tasks->t.forked.start_time
-	                   : waiting_tasks->t.suspended.start_time), &now);
+			     ? waiting_tasks->t.forked.start_time
+			     : waiting_tasks->t.suspended.start_time),
+		    &now);
 	*tv = timeval_lt(&wait, &zero) ? zero : wait;
-        return 1;
+	return 1;
     }
 
     return 0;
@@ -1423,10 +1465,13 @@ run_ready_tasks(void)
 
     gettimeofday(&now, NULL);
 
-    for (t = waiting_tasks; t && timeval_lt(&GET_START_TIME(t), &now); t = next_t) {
-	Objid progr = (t->kind == TASK_FORKED
-		       ? t->t.forked.a.progr
-		       : progr_of_cur_verb(t->t.suspended.the_vm));
+    for (t = waiting_tasks; t && timeval_lt(&GET_START_TIME(t), &now);
+	 t = next_t) {
+	Objid progr =
+	    (t->kind ==
+	     TASK_FORKED ? t->t.forked.a.progr : progr_of_cur_verb(t->t.
+								   suspended.
+								   the_vm));
 	tqueue *tq = find_tqueue(progr, 1);
 
 	next_t = t->next;
@@ -1454,9 +1499,9 @@ run_ready_tasks(void)
 		did_one = 1;
 	    }
 	    while (!did_one) {	/* Loop over tasks, looking for runnable one */
-		t = dequeue_input_task(tq, ((tq->hold_input && !tq->reading)
-					    ? DQ_OOB
-					    : DQ_FIRST));
+		t = dequeue_input_task(tq,
+				       ((tq->hold_input && !tq->reading)
+					? DQ_OOB : DQ_FIRST));
 		if (!t)
 		    t = dequeue_bg_task(tq);
 		if (!t)
@@ -1486,10 +1531,14 @@ run_ready_tasks(void)
 			 * couldn't come up with a good reason to keep that
 			 * restriction.
 			 */
-			add_command_to_history(tq->player, t->t.input.string);
-			did_one = (tq->player >= 0
-				   ? do_command_task
-				: do_login_task) (tq, t->t.input.string);
+			add_command_to_history(tq->player,
+					       t->t.input.string);
+			did_one =
+			    (tq->player >=
+			     0 ? do_command_task : do_login_task) (tq,
+								   t->t.
+								   input.
+								   string);
 		    }
 		    break;
 		case TASK_FORKED:
@@ -1541,8 +1590,8 @@ enum outcome
 run_server_task(Objid player, Objid what, const char *verb, Var args,
 		const char *argstr, Var * result)
 {
-    return run_server_task_setting_id(player, what, verb, args, argstr, result,
-				      0);
+    return run_server_task_setting_id(player, what, verb, args, argstr,
+				      result, 0);
 }
 
 enum outcome
@@ -1558,7 +1607,7 @@ run_server_task_setting_id(Objid player, Objid what, const char *verb,
     h = db_find_callable_verb(what, verb);
     if (h.ptr)
 	return do_server_verb_task(what, verb, args, h, player, argstr,
-				   result, 1/*traceback*/);
+				   result, 1 /*traceback */ );
     else {
 	/* simulate an empty verb */
 	if (result) {
@@ -1572,14 +1621,14 @@ run_server_task_setting_id(Objid player, Objid what, const char *verb,
 
 enum outcome
 run_server_program_task(Objid self, const char *verb, Var args, Objid vloc,
-		    const char *verbname, Program * program, Objid progr,
-			int debug, Objid player, const char *argstr,
-			Var * result)
+			const char *verbname, Program * program,
+			Objid progr, int debug, Objid player,
+			const char *argstr, Var * result)
 {
     current_task_id = new_task_id();
-    return do_server_program_task(self, verb, args, vloc, verbname, program,
-				  progr, debug, player, argstr, result,
-				  1/*traceback*/);
+    return do_server_program_task(self, verb, args, vloc, verbname,
+				  program, progr, debug, player, argstr,
+				  result, 1 /*traceback */ );
 }
 
 void
@@ -1597,16 +1646,19 @@ write_forked_task(forked_task ft)
 {
     int lineno = find_line_number(ft.program, ft.f_index, 0);
 
-    dbio_printf("0 %d %lf %d\n", lineno, timeval_to_double(&ft.start_time), ft.id);
+    dbio_printf("0 %d %lf %d\n", lineno, timeval_to_double(&ft.start_time),
+		ft.id);
     write_activ_as_pi(ft.a);
-    write_rt_env(ft.program->var_names, ft.rt_env, ft.program->num_var_names);
+    write_rt_env(ft.program->var_names, ft.rt_env,
+		 ft.program->num_var_names);
     dbio_write_forked_program(ft.program, ft.f_index);
 }
 
 static void
 write_suspended_task(suspended_task st)
 {
-    dbio_printf("%lf %d ", timeval_to_double(&st.start_time), st.the_vm->task_id);
+    dbio_printf("%lf %d ", timeval_to_double(&st.start_time),
+		st.the_vm->task_id);
     dbio_write_var(st.value);
     write_vm(st.the_vm);
 }
@@ -1685,7 +1737,7 @@ read_task_queue(void)
     }
     for (; count > 0; count--) {
 	int first_lineno, id, old_size;
-        double st;
+	double st;
 	char c;
 	struct timeval start_time;
 	Program *program;
@@ -1699,10 +1751,11 @@ read_task_queue(void)
 	    errlog("READ_TASK_QUEUE: Bad numbers, count = %d.\n", count);
 	    return 0;
 	}
-        double_to_timeval(st, &start_time);
+	double_to_timeval(st, &start_time);
 
 	if (!read_activ_as_pi(&a)) {
-	    errlog("READ_TASK_QUEUE: Bad activation, count = %d.\n", count);
+	    errlog("READ_TASK_QUEUE: Bad activation, count = %d.\n",
+		   count);
 	    return 0;
 	}
 	if (!read_rt_env(&old_names, &old_rt_env, &old_size)) {
@@ -1732,23 +1785,25 @@ read_task_queue(void)
     for (; suspended_count > 0; suspended_count--) {
 	task *t = (task *) mymalloc(sizeof(task), M_TASK);
 	int task_id;
-        double st;
+	double st;
 	char c;
 
 	t->kind = TASK_SUSPENDED;
 	if (dbio_scanf("%lf %d%c", &st, &task_id, &c) != 3) {
-	    errlog("READ_TASK_QUEUE: Bad suspended task header, count = %d\n",
-		   suspended_count);
+	    errlog
+		("READ_TASK_QUEUE: Bad suspended task header, count = %d\n",
+		 suspended_count);
 	    return 0;
 	}
-        double_to_timeval(st, &t->t.suspended.start_time);
+	double_to_timeval(st, &t->t.suspended.start_time);
 	if (c == ' ')
 	    t->t.suspended.value = dbio_read_var();
 	else if (c == '\n')
 	    t->t.suspended.value = zero;
 	else {
-	    errlog("READ_TASK_QUEUE: Bad suspended task value, count = %d\n",
-		   suspended_count);
+	    errlog
+		("READ_TASK_QUEUE: Bad suspended task value, count = %d\n",
+		 suspended_count);
 	    return 0;
 	}
 
@@ -2024,7 +2079,7 @@ struct qcl_data {
 static task_enum_action
 counting_closure(vm the_vm, const char *status, void *data)
 {
-  struct qcl_data *qdata = (qcl_data *) data;
+    struct qcl_data *qdata = (qcl_data *) data;
 
     if (qdata->show_all || qdata->progr == progr_of_cur_verb(the_vm))
 	qdata->i++;
@@ -2035,7 +2090,7 @@ counting_closure(vm the_vm, const char *status, void *data)
 static task_enum_action
 listing_closure(vm the_vm, const char *status, void *data)
 {
-  struct qcl_data *qdata = (qcl_data *) data;
+    struct qcl_data *qdata = (qcl_data *) data;
     Var list;
 
     if (qdata->show_all || qdata->progr == progr_of_cur_verb(the_vm)) {
@@ -2105,12 +2160,15 @@ bf_queued_tasks(Var arglist, Byte next, void *vdata, Objid progr)
 
 	for (t = tq->first_bg; t; t = t->next)
 	    if (t->kind == TASK_FORKED && (show_all
-					|| t->t.forked.a.progr == progr))
+					   || t->t.forked.a.progr ==
+					   progr))
 		tasks.v.list[i++] = list_for_forked_task(t->t.forked);
 	    else if (t->kind == TASK_SUSPENDED
 		     && (show_all
-		   || progr_of_cur_verb(t->t.suspended.the_vm) == progr))
-		tasks.v.list[i++] = list_for_suspended_task(t->t.suspended);
+			 || progr_of_cur_verb(t->t.suspended.the_vm) ==
+			 progr))
+		tasks.v.list[i++] =
+		    list_for_suspended_task(t->t.suspended);
     }
 
     for (t = waiting_tasks; t; t = t->next) {
@@ -2140,7 +2198,7 @@ struct fcl_data {
 static task_enum_action
 finding_closure(vm the_vm, const char *status, void *data)
 {
-  struct fcl_data *fdata = (fcl_data *) data;
+    struct fcl_data *fdata = (fcl_data *) data;
 
     if (the_vm->task_id == fdata->id) {
 	fdata->the_vm = the_vm;
@@ -2158,7 +2216,8 @@ find_suspended_task(int id)
     struct fcl_data fdata;
 
     for (t = waiting_tasks; t; t = t->next)
-	if (t->kind == TASK_SUSPENDED && t->t.suspended.the_vm->task_id == id)
+	if (t->kind == TASK_SUSPENDED
+	    && t->t.suspended.the_vm->task_id == id)
 	    return t->t.suspended.the_vm;
 
     for (tq = idle_tqueues; tq; tq = tq->next)
@@ -2199,7 +2258,7 @@ struct kcl_data {
 static task_enum_action
 killing_closure(vm the_vm, const char *status, void *data)
 {
-  struct kcl_data *kdata = (kcl_data *) data;
+    struct kcl_data *kdata = (kcl_data *) data;
 
     if (the_vm->task_id == kdata->id) {
 	if (is_wizard(kdata->owner)
@@ -2326,7 +2385,8 @@ do_resume(int id, Var value, Objid progr)
 	task *t = *tt;
 	Objid owner;
 
-	if (t->kind == TASK_SUSPENDED && t->t.suspended.the_vm->task_id == id)
+	if (t->kind == TASK_SUSPENDED
+	    && t->t.suspended.the_vm->task_id == id)
 	    owner = progr_of_cur_verb(t->t.suspended.the_vm);
 	else
 	    continue;
@@ -2408,7 +2468,7 @@ bf_output_delimiters(Var arglist, Byte next, void *vdata, Objid progr)
 
 	r = new_list(2);
 	r.v.list[1].type = (var_type) TYPE_STR;
-        r.v.list[2].type = (var_type) TYPE_STR;
+	r.v.list[2].type = (var_type) TYPE_STR;
 	r.v.list[1].v.str = str_dup(prefix);
 	r.v.list[2].v.str = str_dup(suffix);
     }
@@ -2429,7 +2489,7 @@ bf_force_input(Var arglist, Byte next, void *vdata, Objid progr)
 	return make_error_pack(E_PERM);
     }
     tq = find_tqueue(conn, 1);
-    enqueue_input_task(tq, line, at_front, 0/*non-binary*/);
+    enqueue_input_task(tq, line, at_front, 0 /*non-binary */ );
     free_var(arglist);
     return no_var_pack();
 }
@@ -2464,7 +2524,8 @@ register_tasks(void)
     register_function("resume", 1, 2, bf_resume, TYPE_INT, TYPE_ANY);
     register_function("force_input", 2, 3, bf_force_input,
 		      TYPE_OBJ, TYPE_STR, TYPE_ANY);
-    register_function("flush_input", 1, 2, bf_flush_input, TYPE_OBJ, TYPE_ANY);
+    register_function("flush_input", 1, 2, bf_flush_input, TYPE_OBJ,
+		      TYPE_ANY);
 }
 
 char rcsid_tasks[] = "$Id: tasks.c,v 1.14 2006-09-07 00:55:02 bjj Exp $";
diff --git a/server/tasks.h b/server/tasks.h
index 54935a6..83fbb72 100644
--- a/server/tasks.h
+++ b/server/tasks.h
@@ -33,16 +33,14 @@ typedef struct {
 extern task_queue new_task_queue(Objid player, Objid handler);
 extern void free_task_queue(task_queue q);
 
-extern int tasks_connection_option(task_queue, const char *,
-				   Var *);
+extern int tasks_connection_option(task_queue, const char *, Var *);
 extern Var tasks_connection_options(task_queue, Var);
-extern int tasks_set_connection_option(task_queue, const char *,
-				       Var);
+extern int tasks_set_connection_option(task_queue, const char *, Var);
 
 extern void new_input_task(task_queue, const char *, int);
 extern void task_suspend_input(task_queue);
 extern enum error enqueue_forked_task2(activation a, int f_index,
-			       unsigned after_seconds, int vid);
+				       unsigned after_seconds, int vid);
 extern enum error enqueue_suspended_task(vm the_vm, void *data);
 				/* data == &(int after_seconds) */
 extern enum error make_reading_task(vm the_vm, void *data);
@@ -91,11 +89,11 @@ extern enum outcome run_server_task(Objid player, Objid what,
 extern enum outcome run_server_task_setting_id(Objid player, Objid what,
 					       const char *verb, Var args,
 					       const char *argstr,
-					     Var * result, int *task_id);
+					       Var * result, int *task_id);
 extern enum outcome run_server_program_task(Objid self, const char *verb,
 					    Var args, Objid vloc,
 					    const char *verbname,
-					  Program * program, Objid progr,
+					    Program * program, Objid progr,
 					    int debug, Objid player,
 					    const char *argstr,
 					    Var * result);
diff --git a/server/timers.c b/server/timers.c
index 6328ecc..3208f46 100644
--- a/server/timers.c
+++ b/server/timers.c
@@ -294,7 +294,7 @@ reenable_timers(void)
 #if HAVE_SIGRELSE
     sigrelse(SIGALRM);		/* restore previous signal action */
 #else
-          #error I need some way to stop blocking SIGALRM!
+#error I need some way to stop blocking SIGALRM!
 #endif
 #endif
 #endif
diff --git a/server/tools/moobrowser.c b/server/tools/moobrowser.c
index 686f6cf..f25c665 100644
--- a/server/tools/moobrowser.c
+++ b/server/tools/moobrowser.c
@@ -62,8 +62,7 @@ char mode_verbstr[42];
 
 /* Verb argument constants */
 /* To update, copy this from db_verbs.c */
-static const char *prep_list[] =
-{
+static const char *prep_list[] = {
     "with/using",
     "at/to",
     "in front of",
@@ -80,6 +79,7 @@ static const char *prep_list[] =
     "as",
     "off/off of",
 };
+
 #define ASPEC_NONE 0
 #define ASPEC_ANY  1
 #define ASPEC_THIS 2
@@ -99,8 +99,7 @@ static const char *prep_list[] =
 #define TYPE_FLOAT 9
 
 /* Here be errors */
-static const char *error_list[] =
-{
+static const char *error_list[] = {
     "E_NONE",
     "E_TYPE",
     "E_DIV",
@@ -122,12 +121,12 @@ static const char *error_list[] =
 
 /* A structure defining the attributes of a property. */
 struct property {
-  int rootobj;
-  char *name;
-  char *value;
-  int clear;
-  int owner;
-  int perms;
+    int rootobj;
+    char *name;
+    char *value;
+    int clear;
+    int owner;
+    int perms;
 };
 
 
@@ -137,750 +136,834 @@ struct property {
 
 /* Read one line from the database, parse it as an object number and return the number. */
 /* '#5' -> 5  '#5 recycled' -> -5 */
-int read_obj(FILE *fh) {
-  int number;
-  char tmp_str[30];
-  fgets(tmp_str, 30, fh);
-  tmp_str[0] = ' ';
-  number = atoi(tmp_str);
-  if (strstr(tmp_str, "recycled") != NULL)
-    number = -number;
-  return number;
+int
+read_obj(FILE * fh)
+{
+    int number;
+    char tmp_str[30];
+    fgets(tmp_str, 30, fh);
+    tmp_str[0] = ' ';
+    number = atoi(tmp_str);
+    if (strstr(tmp_str, "recycled") != NULL)
+	number = -number;
+    return number;
 }
 
 /* Read one line from the database and return it.
 Does not include the trailing \n character. */
-char *read_big_str(FILE *fh) {
-  static char bufferstr[1024];
-  char *lineptr;
-  char *oldlineptr;
-  char *lfptr;
-  int size;
-
-  lineptr = NULL;
-  oldlineptr = NULL;
-  size = 1;
-  do {
-    fgets(bufferstr, sizeof(bufferstr), fh);
-    if (lineptr)
-      oldlineptr = lineptr;
-    size += strlen(bufferstr);
-    lineptr = (char *) malloc(sizeof(char) * size);
-    if (!lineptr) {
-      //printf("Unable to allocate %u bytes of memory. (read_big_str: lineptr)\n", sizeof(char) * size);
-      cout << "Unable to allocate " << sizeof(char) * size << " bytes of memory. (read_big_str: lineptr)\n";
-      exit(1);
-    }
-    if (oldlineptr) {
-      strcpy(lineptr, oldlineptr);
-      strcat(lineptr, bufferstr);
-      free(oldlineptr);
-    } else {
-      strcpy(lineptr, bufferstr);
-    }
-  } while (!strrchr(bufferstr, '\n'));
+char *
+read_big_str(FILE * fh)
+{
+    static char bufferstr[1024];
+    char *lineptr;
+    char *oldlineptr;
+    char *lfptr;
+    int size;
 
-  /* Strip the \n off the line. */
-  if ((lfptr = (char *) strchr(lineptr, '\n')))
-    *lfptr = '\0';
-  return lineptr;
+    lineptr = NULL;
+    oldlineptr = NULL;
+    size = 1;
+    do {
+	fgets(bufferstr, sizeof(bufferstr), fh);
+	if (lineptr)
+	    oldlineptr = lineptr;
+	size += strlen(bufferstr);
+	lineptr = (char *) malloc(sizeof(char) * size);
+	if (!lineptr) {
+	    //printf("Unable to allocate %u bytes of memory. (read_big_str: lineptr)\n", sizeof(char) * size);
+	    cout << "Unable to allocate " << sizeof(char) *
+		size << " bytes of memory. (read_big_str: lineptr)\n";
+	    exit(1);
+	}
+	if (oldlineptr) {
+	    strcpy(lineptr, oldlineptr);
+	    strcat(lineptr, bufferstr);
+	    free(oldlineptr);
+	} else {
+	    strcpy(lineptr, bufferstr);
+	}
+    } while (!strrchr(bufferstr, '\n'));
+
+    /* Strip the \n off the line. */
+    if ((lfptr = (char *) strchr(lineptr, '\n')))
+	*lfptr = '\0';
+    return lineptr;
 }
 
 
 /* Read one line from the database.  Throw it out. */
-void read_junk_str(FILE *fh) {
-  static char junk[1024];
+void
+read_junk_str(FILE * fh)
+{
+    static char junk[1024];
 
-  do
-    fgets(junk, sizeof(junk), fh);
-  while (!strrchr(junk, '\n'));
+    do
+	fgets(junk, sizeof(junk), fh);
+    while (!strrchr(junk, '\n'));
 }
 
 
 /* Return the smallest non-null integer of two integers. */
-char * minpos(char *a, char *b) {
-  if (a > 0 && b <= 0)
-    return a;
-  if (b > 0 && a <= 0)
-    return b;
-  if (a > 0 && b > 0)
-    return (a > b) ? b : a;
-  return 0;
+char *
+minpos(char *a, char *b)
+{
+    if (a > 0 && b <= 0)
+	return a;
+    if (b > 0 && a <= 0)
+	return b;
+    if (a > 0 && b > 0)
+	return (a > b) ? b : a;
+    return 0;
 }
 
 
 /* Open file for input. */
-FILE *openfile(char *filename) {
-  FILE *fh;
-  fh = fopen(filename, "r");
-  if (fh == NULL) {
-    printf("Unable to open database file: '%s'\n", filename);
-    exit(1);
-  }
-  return fh;
+FILE *
+openfile(char *filename)
+{
+    FILE *fh;
+    fh = fopen(filename, "r");
+    if (fh == NULL) {
+	printf("Unable to open database file: '%s'\n", filename);
+	exit(1);
+    }
+    return fh;
 }
 
 
 /* Parse the intro section */
-void parse_intro(char **lineptr, int *nobjs, int *nprogs, int *dummy, int *nusers, FILE *fh) {
-  /* First line: "** LambdaMOO Database, Format Version 4 **" */
-  *lineptr = read_big_str(fh);
-
-  /* Next four lines */
-  read_int(*nobjs, fh);
-  read_int(*nprogs, fh);
-  read_int(*dummy, fh);
-  read_int(*nusers, fh);
+void
+parse_intro(char **lineptr, int *nobjs, int *nprogs, int *dummy,
+	    int *nusers, FILE * fh)
+{
+    /* First line: "** LambdaMOO Database, Format Version 4 **" */
+    *lineptr = read_big_str(fh);
+
+    /* Next four lines */
+    read_int(*nobjs, fh);
+    read_int(*nprogs, fh);
+    read_int(*dummy, fh);
+    read_int(*nusers, fh);
 }
 
 
 /* Read in a value and format it.  Set 'size' to be the length of the return string,
 or to zero if one doesn't care about the value. */
-char *parse_value(int wanted, FILE *fh) {
-  char *returnstr;
-  char *elementstr;
-  char *tmpstr;
-  int type, listlength, errornum, first, escapes;
-
-  read_int(type, fh);
-
-  if (!wanted && (type==TYPE_INT || type==TYPE_OBJ || type==TYPE_STR || type==TYPE_ERR || type==TYPE_FLOAT)) {
-    /* We don't care about the answer, just eat the next line and move on. */
-    read_junk_str(fh);
-    return NULL;
-  } else if (!wanted && (type==TYPE_CLEAR)) {
-    /* There is no next line. */
-    return NULL;
-  }
+char *
+parse_value(int wanted, FILE * fh)
+{
+    char *returnstr;
+    char *elementstr;
+    char *tmpstr;
+    int type, listlength, errornum, first, escapes;
+
+    read_int(type, fh);
+
+    if (!wanted
+	&& (type == TYPE_INT || type == TYPE_OBJ || type == TYPE_STR
+	    || type == TYPE_ERR || type == TYPE_FLOAT)) {
+	/* We don't care about the answer, just eat the next line and move on. */
+	read_junk_str(fh);
+	return NULL;
+    } else if (!wanted && (type == TYPE_CLEAR)) {
+	/* There is no next line. */
+	return NULL;
+    }
 
-  switch (type) {
+    switch (type) {
     case (int) TYPE_INT:
-      return read_big_str(fh);
+	return read_big_str(fh);
     case TYPE_OBJ:
-      returnstr = (char *) malloc(sizeof(char) * 20);
-      if (!returnstr) {
-        //printf("Unable to allocate %u bytes of memory (parse_value: OBJ).\n", sizeof(char) * 20);
-        cout << "Unable to allocate " <<  sizeof(char) * 20 << " bytes of memory (parse_value: OBJ).\n";
-        exit(1);
-      }
-      strcpy(returnstr, "#");
-      elementstr = read_big_str(fh);
-      strcat(returnstr, elementstr);
-      free(elementstr);
-      return returnstr;
+	returnstr = (char *) malloc(sizeof(char) * 20);
+	if (!returnstr) {
+	    //printf("Unable to allocate %u bytes of memory (parse_value: OBJ).\n", sizeof(char) * 20);
+	    cout << "Unable to allocate " << sizeof(char) *
+		20 << " bytes of memory (parse_value: OBJ).\n";
+	    exit(1);
+	}
+	strcpy(returnstr, "#");
+	elementstr = read_big_str(fh);
+	strcat(returnstr, elementstr);
+	free(elementstr);
+	return returnstr;
     case TYPE_STR:
-      returnstr = read_big_str(fh);
-      /* Count the number of escapes needed. */
-      escapes = 0;
-      elementstr = returnstr;
-      
-      while ((elementstr = (char *) minpos( 
-                                           strchr(elementstr, '"'),
-                                           strchr(elementstr, '\\')
-                                            ) )) {
-        elementstr++;
-        escapes++;
-      }
-      elementstr = NULL;
-      tmpstr = returnstr;
-      /* Increase the size of the string to acommodate the two quotes and any escapes. */
-      returnstr = (char *) malloc(sizeof(char) * (1+strlen(tmpstr)+escapes+1+1));
-      if (!returnstr) {
-        //printf("Unable to allocate %u bytes of memory (parse_value: STR: main).\n", sizeof(char) * (1+strlen(tmpstr)+escapes+1+1));
-        cout << "Unable to allocate " <<  sizeof(char) * (1+strlen(tmpstr)+escapes+1+1) << " bytes of memory (parse_value: STR: main).\n";
-        exit(1);
-      }
-      /* Add a placeholder for the start quote. */
-      strcpy(returnstr, " ");
-      /* Paste in the unescaped string. */
-      strcat(returnstr, tmpstr);
-      free(tmpstr);
-      tmpstr = NULL;
-
-      /* Escape all " and / characters. */
-      elementstr = returnstr;
-      while ((elementstr = (char *) minpos( strchr(elementstr, '"'), strchr(elementstr, '\\')))) {
-        /* Copy the tail of the string into a temporary var. */
-        tmpstr = (char *) malloc(sizeof(char) * (strlen(elementstr)+1));
-        if (!tmpstr) {
-          //printf("Unable to allocate %u bytes of memory (parse_value: STR: tail).\n", sizeof(char) * (strlen(elementstr)+1));
-          cout << "Unable to allocate " <<  sizeof(char) * (strlen(elementstr)+1) << " bytes of memory (parse_value: STR: tail).\n";
-          exit(1);
-        }
-        strcpy(tmpstr, elementstr);
-        /* Add the backslash. */
-        elementstr[0] = '\\';
-        /* Place the tail back onto the string. */
-        strcpy(++elementstr, tmpstr);
-        free(tmpstr);
-        elementstr++;
-      }
-
-      /* Add the start and end quotes. */
-      returnstr[0] = '"';
-      strcat(returnstr, "\"");
-      return returnstr;
+	returnstr = read_big_str(fh);
+	/* Count the number of escapes needed. */
+	escapes = 0;
+	elementstr = returnstr;
+
+	while ((elementstr = (char *) minpos(strchr(elementstr, '"'),
+					     strchr(elementstr, '\\')
+		))) {
+	    elementstr++;
+	    escapes++;
+	}
+	elementstr = NULL;
+	tmpstr = returnstr;
+	/* Increase the size of the string to acommodate the two quotes and any escapes. */
+	returnstr =
+	    (char *) malloc(sizeof(char) *
+			    (1 + strlen(tmpstr) + escapes + 1 + 1));
+	if (!returnstr) {
+	    //printf("Unable to allocate %u bytes of memory (parse_value: STR: main).\n", sizeof(char) * (1+strlen(tmpstr)+escapes+1+1));
+	    cout << "Unable to allocate " << sizeof(char) * (1 +
+							     strlen(tmpstr)
+							     + escapes +
+							     1 +
+							     1) <<
+		" bytes of memory (parse_value: STR: main).\n";
+	    exit(1);
+	}
+	/* Add a placeholder for the start quote. */
+	strcpy(returnstr, " ");
+	/* Paste in the unescaped string. */
+	strcat(returnstr, tmpstr);
+	free(tmpstr);
+	tmpstr = NULL;
+
+	/* Escape all " and / characters. */
+	elementstr = returnstr;
+	while ((elementstr =
+		(char *) minpos(strchr(elementstr, '"'),
+				strchr(elementstr, '\\')))) {
+	    /* Copy the tail of the string into a temporary var. */
+	    tmpstr =
+		(char *) malloc(sizeof(char) * (strlen(elementstr) + 1));
+	    if (!tmpstr) {
+		//printf("Unable to allocate %u bytes of memory (parse_value: STR: tail).\n", sizeof(char) * (strlen(elementstr)+1));
+		cout << "Unable to allocate " << sizeof(char) *
+		    (strlen(elementstr) +
+		     1) << " bytes of memory (parse_value: STR: tail).\n";
+		exit(1);
+	    }
+	    strcpy(tmpstr, elementstr);
+	    /* Add the backslash. */
+	    elementstr[0] = '\\';
+	    /* Place the tail back onto the string. */
+	    strcpy(++elementstr, tmpstr);
+	    free(tmpstr);
+	    elementstr++;
+	}
+
+	/* Add the start and end quotes. */
+	returnstr[0] = '"';
+	strcat(returnstr, "\"");
+	return returnstr;
     case TYPE_ERR:
-      returnstr = (char *) malloc(sizeof(char) * 15);
-      if (!returnstr) {
-        //printf("Unable to allocate %u bytes of memory (parse_value: ERR).\n", sizeof(char) * 15);
-        cout << "Unable to allocate " <<  sizeof(char) * 15 << " bytes of memory (parse_value: ERR).\n";
-        exit(1);
-      }
-      read_int(errornum, fh);
-      if (0 <= errornum || errornum < (int)(sizeof(error_list) / sizeof(*error_list)))
-        strcpy(returnstr, error_list[errornum]);
-      else {
-        printf("Unknown error code: %d\n", errornum); exit(1);
-      }
-      return returnstr;
+	returnstr = (char *) malloc(sizeof(char) * 15);
+	if (!returnstr) {
+	    //printf("Unable to allocate %u bytes of memory (parse_value: ERR).\n", sizeof(char) * 15);
+	    cout << "Unable to allocate " << sizeof(char) *
+		15 << " bytes of memory (parse_value: ERR).\n";
+	    exit(1);
+	}
+	read_int(errornum, fh);
+	if (0 <= errornum
+	    || errornum < (int) (sizeof(error_list) / sizeof(*error_list)))
+	    strcpy(returnstr, error_list[errornum]);
+	else {
+	    printf("Unknown error code: %d\n", errornum);
+	    exit(1);
+	}
+	return returnstr;
     case TYPE_LIST:
-      read_int(listlength, fh);
-      if (wanted) {
-        /* Start the list with a '{' character. */
-        /* Allow room for a '}' character and a null character. */
-        returnstr = (char *) malloc(sizeof(char) * 3);
-        if (!returnstr) {
-          //printf("Unable to allocate %u bytes of memory (parse_value: LIST: open).\n", sizeof(char) * 3);
-          cout << "Unable to allocate " <<  sizeof(char) * 3 << " bytes of memory (parse_value: LIST: open).\n";
-          exit(1);
-        }
-        strcpy(returnstr, "{");
-      }
-      first = 1;
-      for (; listlength > 0; listlength--) {
-	elementstr = parse_value(wanted, fh);
-        if (wanted) {
-          /* Append this element to the list. */
-          tmpstr = returnstr;
-          /* Allow room for a ', ' string, a '}' character and a null character. */
-          returnstr = (char *) malloc(sizeof(char) * (strlen(tmpstr)+2+strlen(elementstr)+1+1));
-          if (!returnstr) {
-            //printf("Unable to allocate %u bytes of memory (parse_value: LIST: element).\n", sizeof(char) * (strlen(tmpstr)+2+strlen(elementstr)+1+1));
-            cout << "Unable to allocate " << sizeof(char) * (strlen(tmpstr)+2+strlen(elementstr)+1+1) << " bytes of memory (parse_value: LIST: element).\n";
-            exit(1);
-          }
-          strcpy(returnstr, tmpstr);
-          if (!first) {
-            /* Add a comma and space between each element. */
-            strcat(returnstr, ", ");
-          }
-          strcat(returnstr, elementstr);
-          free(elementstr);
-          free(tmpstr);
-        }
-        first = 0;
-      }
-      if (wanted) {
-        /* Add the } to the end of the list. */
-        /* There will always be space for an extra character. */
-        strcat(returnstr, "}");
-        return returnstr;
-      } else {
-        return NULL;
-      }
+	read_int(listlength, fh);
+	if (wanted) {
+	    /* Start the list with a '{' character. */
+	    /* Allow room for a '}' character and a null character. */
+	    returnstr = (char *) malloc(sizeof(char) * 3);
+	    if (!returnstr) {
+		//printf("Unable to allocate %u bytes of memory (parse_value: LIST: open).\n", sizeof(char) * 3);
+		cout << "Unable to allocate " << sizeof(char) *
+		    3 << " bytes of memory (parse_value: LIST: open).\n";
+		exit(1);
+	    }
+	    strcpy(returnstr, "{");
+	}
+	first = 1;
+	for (; listlength > 0; listlength--) {
+	    elementstr = parse_value(wanted, fh);
+	    if (wanted) {
+		/* Append this element to the list. */
+		tmpstr = returnstr;
+		/* Allow room for a ', ' string, a '}' character and a null character. */
+		returnstr =
+		    (char *) malloc(sizeof(char) *
+				    (strlen(tmpstr) + 2 +
+				     strlen(elementstr) + 1 + 1));
+		if (!returnstr) {
+		    //printf("Unable to allocate %u bytes of memory (parse_value: LIST: element).\n", sizeof(char) * (strlen(tmpstr)+2+strlen(elementstr)+1+1));
+		    cout << "Unable to allocate " << sizeof(char) *
+			(strlen(tmpstr) + 2 + strlen(elementstr) + 1 +
+			 1) <<
+			" bytes of memory (parse_value: LIST: element).\n";
+		    exit(1);
+		}
+		strcpy(returnstr, tmpstr);
+		if (!first) {
+		    /* Add a comma and space between each element. */
+		    strcat(returnstr, ", ");
+		}
+		strcat(returnstr, elementstr);
+		free(elementstr);
+		free(tmpstr);
+	    }
+	    first = 0;
+	}
+	if (wanted) {
+	    /* Add the } to the end of the list. */
+	    /* There will always be space for an extra character. */
+	    strcat(returnstr, "}");
+	    return returnstr;
+	} else {
+	    return NULL;
+	}
     case TYPE_CLEAR:
-      returnstr = (char *) malloc(sizeof(char) * 10);
-      if (!returnstr) {
-        //printf("Unable to allocate %u bytes of memory (parse_value: clear).\n", sizeof(char) * 10);
-        cout << "Unable to allocate " << sizeof(char) * 10 << " bytes of memory (parse_value: clear).\n";
-        exit(1);
-      }
-      strcpy(returnstr, "[clear]");
-      return returnstr;
+	returnstr = (char *) malloc(sizeof(char) * 10);
+	if (!returnstr) {
+	    //printf("Unable to allocate %u bytes of memory (parse_value: clear).\n", sizeof(char) * 10);
+	    cout << "Unable to allocate " << sizeof(char) *
+		10 << " bytes of memory (parse_value: clear).\n";
+	    exit(1);
+	}
+	strcpy(returnstr, "[clear]");
+	return returnstr;
     case TYPE_FLOAT:
-      return read_big_str(fh);
+	return read_big_str(fh);
     default:
-      printf("Unknown value type: %d\n", type);
-      printf("(Non-standard data types such as WAIFs are not supported.)\n");
-      exit(1);
-  }
-  return NULL;
+	printf("Unknown value type: %d\n", type);
+	printf
+	    ("(Non-standard data types such as WAIFs are not supported.)\n");
+	exit(1);
+    }
+    return NULL;
 }
 
 
 /* Reopen the database and look for the properties defined on a specific object. */
 /* Returns the object number of the requested object's parent. */
-int dig_props(int object, struct property *propstructs, int *propindex) {
-  FILE *fh;
-  int nobjs, nusers, nprogs, dummy, i, j;
-  char *lineptr;
-
-  int objnumber, parent;
-  int verbdefs, propdefs, nprops;
-  char *pnameptr;
-  char *pvalueptr;
-  int startindex;
-
-  /* printf("Deep scan for #%d\n", object); */
-  /* Open file for input */
-  fh = openfile(databasename);
-
-  /* Parse the intro section */
-  parse_intro(&lineptr, &nobjs, &nprogs, &dummy, &nusers, fh);
-  free(lineptr);
-
-  /* List of players */
-  for (i = 1; i <= nusers; i++)
-    read_int(dummy, fh);
-
-  /* List of objects */
-  parent = -1;
-  for (i = 1; i <= nobjs; i++) {
-    /* Parse all the lines devoted to the next object in the database. */
-    objnumber = read_obj(fh);
-    if (objnumber < 0) /* Recycled object */
-      continue;
-    read_junk_str(fh); /* Name */
-    read_junk_str(fh); /* Junk */
-    read_int(dummy, fh); /* Flags */
-    read_int(dummy, fh); /* Owner */
-    read_int(dummy, fh); /* Location */
-    read_int(dummy, fh); /* Contents */
-    read_int(dummy, fh); /* next */
-    read_int(dummy, fh); /* Parent */
-    if (objnumber == object)
-      parent = dummy;
-    read_int(dummy, fh); /* Child */
-    read_int(dummy, fh); /* Sibling */
-    read_int(verbdefs, fh);
-    for (j = 1; j <= verbdefs; j++) {
-      /* Parse all the lines devoted to a verb definition */
-      read_junk_str(fh);
-      read_int(dummy, fh); /* Verb owner */
-      read_int(dummy, fh); /* Verb perms */
-      read_int(dummy, fh); /* Verb prep */
-    }
-
-    startindex = *propindex;
-    read_int(propdefs, fh);
-    for (j = 1; j <= propdefs; j++) {
-      pnameptr = read_big_str(fh);
-      if (objnumber == object) {
-        *propindex = *propindex + 1;
-        propstructs[*propindex].name = pnameptr;
-        propstructs[*propindex].rootobj = objnumber;
-      } else {
-        free(pnameptr);
-      }
-    }
+int
+dig_props(int object, struct property *propstructs, int *propindex)
+{
+    FILE *fh;
+    int nobjs, nusers, nprogs, dummy, i, j;
+    char *lineptr;
+
+    int objnumber, parent;
+    int verbdefs, propdefs, nprops;
+    char *pnameptr;
+    char *pvalueptr;
+    int startindex;
+
+    /* printf("Deep scan for #%d\n", object); */
+    /* Open file for input */
+    fh = openfile(databasename);
+
+    /* Parse the intro section */
+    parse_intro(&lineptr, &nobjs, &nprogs, &dummy, &nusers, fh);
+    free(lineptr);
 
-    read_int(nprops, fh);
-    for (j = 1; j <= nprops; j++) {
-      pvalueptr = parse_value((objnumber == object), fh);
-      /* If the property on the child object is clear, use the parent's value. */
-      if (objnumber == object && strcmp(propstructs[startindex+j].value, "[clear]") == 0) {
-        free(propstructs[startindex+j].value);
-        propstructs[startindex+j].value = pvalueptr;
-      } else {
-        free(pvalueptr);
-      }
-      read_int(dummy, fh); /* Prop owner */
-      read_int(dummy, fh); /* Prop perms */
+    /* List of players */
+    for (i = 1; i <= nusers; i++)
+	read_int(dummy, fh);
+
+    /* List of objects */
+    parent = -1;
+    for (i = 1; i <= nobjs; i++) {
+	/* Parse all the lines devoted to the next object in the database. */
+	objnumber = read_obj(fh);
+	if (objnumber < 0)	/* Recycled object */
+	    continue;
+	read_junk_str(fh);	/* Name */
+	read_junk_str(fh);	/* Junk */
+	read_int(dummy, fh);	/* Flags */
+	read_int(dummy, fh);	/* Owner */
+	read_int(dummy, fh);	/* Location */
+	read_int(dummy, fh);	/* Contents */
+	read_int(dummy, fh);	/* next */
+	read_int(dummy, fh);	/* Parent */
+	if (objnumber == object)
+	    parent = dummy;
+	read_int(dummy, fh);	/* Child */
+	read_int(dummy, fh);	/* Sibling */
+	read_int(verbdefs, fh);
+	for (j = 1; j <= verbdefs; j++) {
+	    /* Parse all the lines devoted to a verb definition */
+	    read_junk_str(fh);
+	    read_int(dummy, fh);	/* Verb owner */
+	    read_int(dummy, fh);	/* Verb perms */
+	    read_int(dummy, fh);	/* Verb prep */
+	}
+
+	startindex = *propindex;
+	read_int(propdefs, fh);
+	for (j = 1; j <= propdefs; j++) {
+	    pnameptr = read_big_str(fh);
+	    if (objnumber == object) {
+		*propindex = *propindex + 1;
+		propstructs[*propindex].name = pnameptr;
+		propstructs[*propindex].rootobj = objnumber;
+	    } else {
+		free(pnameptr);
+	    }
+	}
+
+	read_int(nprops, fh);
+	for (j = 1; j <= nprops; j++) {
+	    pvalueptr = parse_value((objnumber == object), fh);
+	    /* If the property on the child object is clear, use the parent's value. */
+	    if (objnumber == object
+		&& strcmp(propstructs[startindex + j].value,
+			  "[clear]") == 0) {
+		free(propstructs[startindex + j].value);
+		propstructs[startindex + j].value = pvalueptr;
+	    } else {
+		free(pvalueptr);
+	    }
+	    read_int(dummy, fh);	/* Prop owner */
+	    read_int(dummy, fh);	/* Prop perms */
+	}
+
+	/* We found the target object; bail. */
+	if (objnumber == object)
+	    break;
     }
-
-    /* We found the target object; bail. */
-    if (objnumber == object)
-      break;
-  }
-  fclose(fh);
-  return parent;
+    fclose(fh);
+    return parent;
 }
 
 
 /* Parse all the lines devoted to the next object in the database. */
-void parse_obj(FILE *fh) {
-  int objnumber;
-  char *nameptr;
-  int flags, owner, location, contents, next, parent, child, sibling;
-  int verbdefs, propdefs, nprops;
-  int i;
-  char *vnameptr;
-  int vowner, vperms, vprep;
-  int dobj, iobj;
-
-  char **propdefnames;
-  struct property *propstructs;
-
-  objnumber = read_obj(fh);
-  if (mode == OBJECTS) {
+void
+parse_obj(FILE * fh)
+{
+    int objnumber;
+    char *nameptr;
+    int flags, owner, location, contents, next, parent, child, sibling;
+    int verbdefs, propdefs, nprops;
+    int i;
+    char *vnameptr;
+    int vowner, vperms, vprep;
+    int dobj, iobj;
+
+    char **propdefnames;
+    struct property *propstructs;
+
+    objnumber = read_obj(fh);
+    if (mode == OBJECTS) {
+	if (objnumber < 0) {
+	    printf("#%d recycled\n", -objnumber);
+	} else {
+	    printf("#%d\n", objnumber);
+	}
+    }
+
     if (objnumber < 0) {
-      printf("#%d recycled\n", -objnumber);
-    } else {
-      printf("#%d\n", objnumber);
+	if (mode_object == -objnumber)
+	    printf("Recycled\n");
+	return;
     }
-  }
-
-  if (objnumber < 0) {
-     if (mode_object == -objnumber)
-       printf("Recycled\n");
-     return;
-  }
-
-  nameptr = read_big_str(fh);
-  read_junk_str(fh);
-  read_int(flags, fh);
-  read_int(owner, fh);
-  read_int(location, fh);
-  read_int(contents, fh);
-  read_int(next, fh);
-  read_int(parent, fh);
-  read_int(child, fh);
-  read_int(sibling, fh);
-  if (mode == OBJECT && mode_object == objnumber) {
-    printf("Name:\t%s\n", nameptr);
-    printf("Flags:\t");
-    if (flags & OB_USER) printf("player ");
-    if (flags & OB_PROGRAMMER) printf("programmer ");
-    if (flags & OB_WIZARD) printf("wizard ");
-    /* if (flags & OB_OBSOLETE_1) printf(" X "); */
-    if (flags & OB_READ) printf("r ");
-    if (flags & OB_WRITE) printf("w ");
-    /* if (flags & OB_OBSOLETE_2) printf(" Y "); */
-    if (flags & OB_FERTILE) printf("f ");
-    printf("\n");
-    printf("Owner:\t#%d\n", owner);
-    printf("Location:\t#%d\n", location);
-    printf("Parent:\t#%d\n", parent);
-  }
-  free(nameptr);
-  nameptr = NULL;
-  if (mode == OBJECT && mode_object == parent) {
-    printf("Child:\t#%d\n", objnumber);
-  }
-  if (mode == OBJECT && mode_object == location) {
-    printf("Contains:\t#%d\n", objnumber);
-  }
-  if (mode == OBJECT && mode_object == owner) {
-    printf("Owns:\t#%d\n", objnumber);
-  }
-
-  read_int(verbdefs, fh);
-  for (i = 1; i <= verbdefs; i++) {
-    /* Parse all the lines devoted to a verb definition */
-    if (mode_object == objnumber)
-      vnameptr = read_big_str(fh);
-    else
-      read_junk_str(fh);
-    read_int(vowner, fh);
-    read_int(vperms, fh);
-    read_int(vprep, fh);
+
+    nameptr = read_big_str(fh);
+    read_junk_str(fh);
+    read_int(flags, fh);
+    read_int(owner, fh);
+    read_int(location, fh);
+    read_int(contents, fh);
+    read_int(next, fh);
+    read_int(parent, fh);
+    read_int(child, fh);
+    read_int(sibling, fh);
     if (mode == OBJECT && mode_object == objnumber) {
-      printf("Verb %d:\t:%s\n", i-1, vnameptr);
-    } else if (mode == VERB && mode_object == objnumber && mode_verb == i-1) {
-      printf("Name:\t%s\n", vnameptr);
-      printf("Owner:\t#%d\n", vowner);
-      printf("Perms:\t");
-      if (vperms & VF_READ) printf("r");
-      if (vperms & VF_WRITE) printf("w");
-      if (vperms & VF_EXEC) printf("x");
-      if (vperms & VF_DEBUG) printf("d");
-      if (!(vperms & VF_NOT_O)) printf("o");
-      printf("\n");
-      printf("Prepositions:\t");
-      dobj = (vperms >> DOBJSHIFT) & OBJMASK;
-      iobj = (vperms >> IOBJSHIFT) & OBJMASK;
-      if (dobj == ASPEC_NONE)
-        printf("none");
-      else if (dobj == ASPEC_ANY)
-        printf("any");
-      else if (dobj == ASPEC_THIS)
-        printf("this");
-      else {
-        printf("\nUnknown dobj: %d\n", dobj);
-        exit(1);
-      }
-      printf(" ");
-      if (vprep == PREP_ANY)
-        printf("any");
-      else if (vprep == PREP_NONE)
-        printf("none");
-      else if (0 <= vprep || vprep < (int)(sizeof(prep_list) / sizeof(*prep_list)))
-        printf("%s", prep_list[vprep]);
-      else {
-        printf("\nUnknown prep: %d\n", vprep);
-        exit(1);
-      }
-      printf(" ");
-      if (iobj == ASPEC_NONE)
-        printf("none");
-      else if (iobj == ASPEC_ANY)
-        printf("any");
-      else if (iobj == ASPEC_THIS)
-        printf("this");
-      else {
-        printf("\nUnknown iobj: %d\n", iobj);
-        exit(1);
-      }
-      printf("\n");
-    }
-    if (mode_object == objnumber)
-      free(vnameptr);
-  }
-
-  /*
-  For most of this program we just scan through data and instantly print anything that looks interesting.
-  Unlike the Moo, we don't soak up reams of data into memory.
-  However, the inherited property data is spread all over the database.
-  So we'll read it all in before printing it out.
-  */
-  read_int(propdefs, fh);
-  if ((mode == OBJECT || mode == PROP) && mode_object == objnumber) {
-    /* We are interested in the object.  Record all the property names. */
-    propdefnames = (char **)malloc(propdefs * sizeof(char *));
-    if (!propdefnames) {
-      //printf("Unable to allocate %u bytes of memory. (parse_obj: propdefnames)\n", propdefs * sizeof(char *));
-      cout << "Unable to allocate " << propdefs * sizeof(char *) << " bytes of memory. (parse_obj: propdefnames)\n";
-      exit(1);
+	printf("Name:\t%s\n", nameptr);
+	printf("Flags:\t");
+	if (flags & OB_USER)
+	    printf("player ");
+	if (flags & OB_PROGRAMMER)
+	    printf("programmer ");
+	if (flags & OB_WIZARD)
+	    printf("wizard ");
+	/* if (flags & OB_OBSOLETE_1) printf(" X "); */
+	if (flags & OB_READ)
+	    printf("r ");
+	if (flags & OB_WRITE)
+	    printf("w ");
+	/* if (flags & OB_OBSOLETE_2) printf(" Y "); */
+	if (flags & OB_FERTILE)
+	    printf("f ");
+	printf("\n");
+	printf("Owner:\t#%d\n", owner);
+	printf("Location:\t#%d\n", location);
+	printf("Parent:\t#%d\n", parent);
     }
-    for (i = 1; i <= propdefs; i++)
-      propdefnames[i-1] = read_big_str(fh);
-  } else {
-    /* We don't care about this object. */
-    for (i = 1; i <= propdefs; i++)
-      read_junk_str(fh);
-  }
-
-  read_int(nprops, fh);
-  if ((mode == OBJECT || mode == PROP) && mode_object == objnumber) {
-    /* Now that we know the total number of properties, build a structure to hold this info. */
-    propstructs = (property *)malloc(nprops * sizeof(struct property));
-    if (!propstructs) {
-      //printf("Unable to allocate %u bytes of memory. (parse_obj: propstructs)\n", nprops * sizeof(struct property));
-      cout << "Unable to allocate " << nprops * sizeof(struct property) << " bytes of memory. (parse_obj: propstructs)\n";
-      exit(1);
+    free(nameptr);
+    nameptr = NULL;
+    if (mode == OBJECT && mode_object == parent) {
+	printf("Child:\t#%d\n", objnumber);
     }
-    /* Copy over the defined list of prop names. */
-    for (i = 1; i <= propdefs; i++) {
-      propstructs[i-1].rootobj = objnumber;
-      propstructs[i-1].name = propdefnames[i-1];
-      propstructs[i-1].clear = 0;
+    if (mode == OBJECT && mode_object == location) {
+	printf("Contains:\t#%d\n", objnumber);
     }
-    free(propdefnames);
-    /* Read in the value, owner and perms of all props. */
-    for (i = 1; i <= nprops; i++) {
-      propstructs[i-1].value = parse_value(1, fh);
-      propstructs[i-1].clear = (strcmp(propstructs[i-1].value, "[clear]") == 0);
-      read_int(propstructs[i-1].owner, fh);
-      read_int(propstructs[i-1].perms, fh);
+    if (mode == OBJECT && mode_object == owner) {
+	printf("Owns:\t#%d\n", objnumber);
     }
-    /* Look up all ancestors to obtain missing names and values. */
-    i = propdefs-1;
-    while (parent != -1) {
-      parent = dig_props(parent, propstructs, &i);
+
+    read_int(verbdefs, fh);
+    for (i = 1; i <= verbdefs; i++) {
+	/* Parse all the lines devoted to a verb definition */
+	if (mode_object == objnumber)
+	    vnameptr = read_big_str(fh);
+	else
+	    read_junk_str(fh);
+	read_int(vowner, fh);
+	read_int(vperms, fh);
+	read_int(vprep, fh);
+	if (mode == OBJECT && mode_object == objnumber) {
+	    printf("Verb %d:\t:%s\n", i - 1, vnameptr);
+	} else if (mode == VERB && mode_object == objnumber
+		   && mode_verb == i - 1) {
+	    printf("Name:\t%s\n", vnameptr);
+	    printf("Owner:\t#%d\n", vowner);
+	    printf("Perms:\t");
+	    if (vperms & VF_READ)
+		printf("r");
+	    if (vperms & VF_WRITE)
+		printf("w");
+	    if (vperms & VF_EXEC)
+		printf("x");
+	    if (vperms & VF_DEBUG)
+		printf("d");
+	    if (!(vperms & VF_NOT_O))
+		printf("o");
+	    printf("\n");
+	    printf("Prepositions:\t");
+	    dobj = (vperms >> DOBJSHIFT) & OBJMASK;
+	    iobj = (vperms >> IOBJSHIFT) & OBJMASK;
+	    if (dobj == ASPEC_NONE)
+		printf("none");
+	    else if (dobj == ASPEC_ANY)
+		printf("any");
+	    else if (dobj == ASPEC_THIS)
+		printf("this");
+	    else {
+		printf("\nUnknown dobj: %d\n", dobj);
+		exit(1);
+	    }
+	    printf(" ");
+	    if (vprep == PREP_ANY)
+		printf("any");
+	    else if (vprep == PREP_NONE)
+		printf("none");
+	    else if (0 <= vprep
+		     || vprep <
+		     (int) (sizeof(prep_list) / sizeof(*prep_list)))
+		printf("%s", prep_list[vprep]);
+	    else {
+		printf("\nUnknown prep: %d\n", vprep);
+		exit(1);
+	    }
+	    printf(" ");
+	    if (iobj == ASPEC_NONE)
+		printf("none");
+	    else if (iobj == ASPEC_ANY)
+		printf("any");
+	    else if (iobj == ASPEC_THIS)
+		printf("this");
+	    else {
+		printf("\nUnknown iobj: %d\n", iobj);
+		exit(1);
+	    }
+	    printf("\n");
+	}
+	if (mode_object == objnumber)
+	    free(vnameptr);
     }
-    /* Print and free the collected property data. */
-    for (i = 1; i <= nprops; i++) {
-      if (mode == OBJECT) {
-        printf("Property %d:\t#%d.%s\n", i-1, propstructs[i-1].rootobj, propstructs[i-1].name);
-      } else if (strcmp(mode_prop, propstructs[i-1].name) == 0) {
-        printf("Defined:\t#%d\n", propstructs[i-1].rootobj);
-        printf("Owner:\t#%d\n", propstructs[i-1].owner);
-        printf("Perms:\t");
-        if (propstructs[i-1].perms & PF_READ) printf("r");
-        if (propstructs[i-1].perms & PF_WRITE) printf("w");
-        if (propstructs[i-1].perms & PF_CHOWN) printf("c");
-        printf("\n");
-        printf("Clear:\t%d\n", propstructs[i-1].clear);
-        printf("Value:\t%s\n", propstructs[i-1].value);
-        /* We're done.  Quit and let the OS clean up our memory. */
-        fclose(fh);
-        exit(0);
-      }
-      free(propstructs[i-1].name);
-      free(propstructs[i-1].value);
+
+    /*
+       For most of this program we just scan through data and instantly print anything that looks interesting.
+       Unlike the Moo, we don't soak up reams of data into memory.
+       However, the inherited property data is spread all over the database.
+       So we'll read it all in before printing it out.
+     */
+    read_int(propdefs, fh);
+    if ((mode == OBJECT || mode == PROP) && mode_object == objnumber) {
+	/* We are interested in the object.  Record all the property names. */
+	propdefnames = (char **) malloc(propdefs * sizeof(char *));
+	if (!propdefnames) {
+	    //printf("Unable to allocate %u bytes of memory. (parse_obj: propdefnames)\n", propdefs * sizeof(char *));
+	    cout << "Unable to allocate " << propdefs *
+		sizeof(char *) <<
+		" bytes of memory. (parse_obj: propdefnames)\n";
+	    exit(1);
+	}
+	for (i = 1; i <= propdefs; i++)
+	    propdefnames[i - 1] = read_big_str(fh);
+    } else {
+	/* We don't care about this object. */
+	for (i = 1; i <= propdefs; i++)
+	    read_junk_str(fh);
     }
-    free(propstructs);
-  } else {
-    /* We don't care about this object. */
-    for (i = 1; i <= nprops; i++) {
-      free(parse_value(0, fh));
-      read_int(vowner, fh);
-      read_int(vperms, fh);
+
+    read_int(nprops, fh);
+    if ((mode == OBJECT || mode == PROP) && mode_object == objnumber) {
+	/* Now that we know the total number of properties, build a structure to hold this info. */
+	propstructs =
+	    (property *) malloc(nprops * sizeof(struct property));
+	if (!propstructs) {
+	    //printf("Unable to allocate %u bytes of memory. (parse_obj: propstructs)\n", nprops * sizeof(struct property));
+	    cout << "Unable to allocate " << nprops *
+		sizeof(struct property) <<
+		" bytes of memory. (parse_obj: propstructs)\n";
+	    exit(1);
+	}
+	/* Copy over the defined list of prop names. */
+	for (i = 1; i <= propdefs; i++) {
+	    propstructs[i - 1].rootobj = objnumber;
+	    propstructs[i - 1].name = propdefnames[i - 1];
+	    propstructs[i - 1].clear = 0;
+	}
+	free(propdefnames);
+	/* Read in the value, owner and perms of all props. */
+	for (i = 1; i <= nprops; i++) {
+	    propstructs[i - 1].value = parse_value(1, fh);
+	    propstructs[i - 1].clear =
+		(strcmp(propstructs[i - 1].value, "[clear]") == 0);
+	    read_int(propstructs[i - 1].owner, fh);
+	    read_int(propstructs[i - 1].perms, fh);
+	}
+	/* Look up all ancestors to obtain missing names and values. */
+	i = propdefs - 1;
+	while (parent != -1) {
+	    parent = dig_props(parent, propstructs, &i);
+	}
+	/* Print and free the collected property data. */
+	for (i = 1; i <= nprops; i++) {
+	    if (mode == OBJECT) {
+		printf("Property %d:\t#%d.%s\n", i - 1,
+		       propstructs[i - 1].rootobj,
+		       propstructs[i - 1].name);
+	    } else if (strcmp(mode_prop, propstructs[i - 1].name) == 0) {
+		printf("Defined:\t#%d\n", propstructs[i - 1].rootobj);
+		printf("Owner:\t#%d\n", propstructs[i - 1].owner);
+		printf("Perms:\t");
+		if (propstructs[i - 1].perms & PF_READ)
+		    printf("r");
+		if (propstructs[i - 1].perms & PF_WRITE)
+		    printf("w");
+		if (propstructs[i - 1].perms & PF_CHOWN)
+		    printf("c");
+		printf("\n");
+		printf("Clear:\t%d\n", propstructs[i - 1].clear);
+		printf("Value:\t%s\n", propstructs[i - 1].value);
+		/* We're done.  Quit and let the OS clean up our memory. */
+		fclose(fh);
+		exit(0);
+	    }
+	    free(propstructs[i - 1].name);
+	    free(propstructs[i - 1].value);
+	}
+	free(propstructs);
+    } else {
+	/* We don't care about this object. */
+	for (i = 1; i <= nprops; i++) {
+	    free(parse_value(0, fh));
+	    read_int(vowner, fh);
+	    read_int(vperms, fh);
+	}
     }
-  }
 }
 
 
 /* Read in all the lines for one verb. */
-void parse_verb(FILE *fh) {
-  char *lineptr;
-
-  /* Read the object number and verb number (eg. "#123:4") */
-  lineptr = read_big_str(fh);
-  if (mode == VERB && strcmp(mode_verbstr, lineptr) == 0) {
-    /* This is the verb we seek; print it out. */
-    printf("\n");
-    do {
-      free(lineptr);
-      lineptr = read_big_str(fh);
-      printf("%s\n", lineptr);
-    } while (strcmp(lineptr, ".") != 0);
-  } else {
-    free(lineptr);
-    /* We're not interested in this verb, just eat it quickly. [optimised] */
-    /* Note: This code assumes that no compiled Moo verb can have a line ending with a dot. */
-    lineptr = (char *) malloc(sizeof(char) * 256);
-    if (!lineptr) {
-      //printf("Unable to allocate %u bytes of memory (parse_verb).\n", sizeof(char) * 256);
-      cout << "Unable to allocate " << sizeof(char) * 256 << " bytes of memory (parse_verb).\n";
-      exit(1);
+void
+parse_verb(FILE * fh)
+{
+    char *lineptr;
+
+    /* Read the object number and verb number (eg. "#123:4") */
+    lineptr = read_big_str(fh);
+    if (mode == VERB && strcmp(mode_verbstr, lineptr) == 0) {
+	/* This is the verb we seek; print it out. */
+	printf("\n");
+	do {
+	    free(lineptr);
+	    lineptr = read_big_str(fh);
+	    printf("%s\n", lineptr);
+	} while (strcmp(lineptr, ".") != 0);
+    } else {
+	free(lineptr);
+	/* We're not interested in this verb, just eat it quickly. [optimised] */
+	/* Note: This code assumes that no compiled Moo verb can have a line ending with a dot. */
+	lineptr = (char *) malloc(sizeof(char) * 256);
+	if (!lineptr) {
+	    //printf("Unable to allocate %u bytes of memory (parse_verb).\n", sizeof(char) * 256);
+	    cout << "Unable to allocate " << sizeof(char) *
+		256 << " bytes of memory (parse_verb).\n";
+	    exit(1);
+	}
+	do
+	    fgets(lineptr, 256, fh);
+	while (strcmp(lineptr, ".\n") != 0);
     }
-    do
-      fgets(lineptr, 256, fh);
-    while (strcmp(lineptr, ".\n") != 0);
-  }
-  free(lineptr);
+    free(lineptr);
 }
 
 
-int main(int argc, char *argv[]) {
-  FILE *fh;
-  char *lineptr;
-  int nobjs, nprogs, dummy, nusers, user, clocks;
-  /* int queuedtasks, suspendedtasks, connections; */
-  int i;
-
-  if (argc == 1 || argc > 3) {
-    printf("Usage: moobrowser <DB FILE>\n");
-    printf("       moobrowser <DB FILE> [objects | players]\n");
-    /* printf("       moobrowser <DB FILE> [objects | players | queuedtasks | suspendedtasks | connections]\n"); */
-    printf("       moobrowser <DB FILE> [<OBJECT> | <OBJECT:VERBNUM> | <OBJECT.PROPNAME>]\n");
-    printf("       Object numbers can omit the '#' symbol.\n");
-    return 1;
-  }
-
-  if (argc == 2) {
-    mode = SUMMARY;
-    printf("> Summary\n");
-  } else if (strcmp(argv[2], "objects") == 0) {
-    mode = OBJECTS;
-    printf("> Objects\n");
-  } else if (strcmp(argv[2], "players") == 0) {
-    mode = PLAYERS;
-    printf("> Players\n");
-  } else if (strcmp(argv[2], "clocks") == 0) {
-    /* This is an undocumented feature.  The clock section is obsolete and should be empty. */
-    mode = CLOCKS;
-    printf("> Clocks\n");
-  } else if (strcmp(argv[2], "queuedtasks") == 0) {
-    mode = QUEUEDTASKS;
-    printf("> Queued tasks\n");
-  } else if (strcmp(argv[2], "suspendedtasks") == 0) {
-    mode = SUSPENDEDTASKS;
-    printf("> Suspended tasks\n");
-  } else if (strcmp(argv[2], "connections") == 0) {
-    mode = CONNECTIONS;
-    printf("> Connections\n");
-  } else {
-    if (argv[2][0] == '#') {
-      /* Eat the redundant # symbol. */
-      strcpy(argv[2], argv[2]+1);
+int
+main(int argc, char *argv[])
+{
+    FILE *fh;
+    char *lineptr;
+    int nobjs, nprogs, dummy, nusers, user, clocks;
+    /* int queuedtasks, suspendedtasks, connections; */
+    int i;
+
+    if (argc == 1 || argc > 3) {
+	printf("Usage: moobrowser <DB FILE>\n");
+	printf("       moobrowser <DB FILE> [objects | players]\n");
+	/* printf("       moobrowser <DB FILE> [objects | players | queuedtasks | suspendedtasks | connections]\n"); */
+	printf
+	    ("       moobrowser <DB FILE> [<OBJECT> | <OBJECT:VERBNUM> | <OBJECT.PROPNAME>]\n");
+	printf("       Object numbers can omit the '#' symbol.\n");
+	return 1;
     }
-    if (strchr(argv[2], '.')) {
-      mode = PROP;
-      mode_object = atoi(argv[2]);
-      strncpy(mode_prop, (char *) strchr(argv[2], '.')+1, sizeof(mode_prop));
-      printf("> #%d.%s\n", mode_object, mode_prop);
-    } else if (strchr(argv[2], ':')) {
-      mode = VERB;
-      mode_object = atoi(argv[2]);
-      strcpy(argv[2], (char *) strchr(argv[2], ':')+1);
-      mode_verb = atoi(argv[2]);
-      printf("> #%d:%d\n", mode_object, mode_verb);
-      sprintf(mode_verbstr, "#%d:%d", mode_object, mode_verb);
+
+    if (argc == 2) {
+	mode = SUMMARY;
+	printf("> Summary\n");
+    } else if (strcmp(argv[2], "objects") == 0) {
+	mode = OBJECTS;
+	printf("> Objects\n");
+    } else if (strcmp(argv[2], "players") == 0) {
+	mode = PLAYERS;
+	printf("> Players\n");
+    } else if (strcmp(argv[2], "clocks") == 0) {
+	/* This is an undocumented feature.  The clock section is obsolete and should be empty. */
+	mode = CLOCKS;
+	printf("> Clocks\n");
+    } else if (strcmp(argv[2], "queuedtasks") == 0) {
+	mode = QUEUEDTASKS;
+	printf("> Queued tasks\n");
+    } else if (strcmp(argv[2], "suspendedtasks") == 0) {
+	mode = SUSPENDEDTASKS;
+	printf("> Suspended tasks\n");
+    } else if (strcmp(argv[2], "connections") == 0) {
+	mode = CONNECTIONS;
+	printf("> Connections\n");
     } else {
-      mode = OBJECT;
-      mode_object = atoi(argv[2]);
-      printf("> #%d\n", mode_object);
+	if (argv[2][0] == '#') {
+	    /* Eat the redundant # symbol. */
+	    strcpy(argv[2], argv[2] + 1);
+	}
+	if (strchr(argv[2], '.')) {
+	    mode = PROP;
+	    mode_object = atoi(argv[2]);
+	    strncpy(mode_prop, (char *) strchr(argv[2], '.') + 1,
+		    sizeof(mode_prop));
+	    printf("> #%d.%s\n", mode_object, mode_prop);
+	} else if (strchr(argv[2], ':')) {
+	    mode = VERB;
+	    mode_object = atoi(argv[2]);
+	    strcpy(argv[2], (char *) strchr(argv[2], ':') + 1);
+	    mode_verb = atoi(argv[2]);
+	    printf("> #%d:%d\n", mode_object, mode_verb);
+	    sprintf(mode_verbstr, "#%d:%d", mode_object, mode_verb);
+	} else {
+	    mode = OBJECT;
+	    mode_object = atoi(argv[2]);
+	    printf("> #%d\n", mode_object);
+	}
     }
-  }
-
-  /* Save the filename into a global variable so that other functions can reopen it for deeper data. */
-  databasename = (char *) malloc(sizeof(char) * (strlen(argv[1])+1));
-  if (!databasename) {
-    //printf("Unable to allocate %u bytes of memory. (main: databasename)\n", sizeof(char) * (strlen(argv[1])+1));
-    cout << "Unable to allocate " << sizeof(char) * (strlen(argv[1])+1) << " bytes of memory. (main: databasename)\n";
-    exit(1);
-  }
-  strcpy(databasename, argv[1]);
-
-  /* Open file for input */
-  fh = openfile(databasename);
-
-  /* Parse the intro section */
-  parse_intro(&lineptr, &nobjs, &nprogs, &dummy, &nusers, fh);
-  if (mode == SUMMARY)
-    printf("%s\n", lineptr);
-  free(lineptr);
-  lineptr = NULL;
-
-  /* List of players */
-  if (mode == PLAYERS || mode == SUMMARY)
-    printf("Players: %d\n", nusers);
-  for (i = 1; i <= nusers; i++) {
-    read_int(user, fh);
-    if (mode == PLAYERS)
-      printf("#%d\n", user);
-  }
-  if (mode == PLAYERS) {
-    fclose(fh);
-    return 0;
-  }
-
-  /* List of objects */
-  if (mode == OBJECTS || mode == SUMMARY)
-    printf("Objects: %d\n", nobjs);
-  for (i = 1; i <= nobjs; i++) {
-    parse_obj(fh);
-  }
-  if (mode == OBJECTS || mode == PROP || mode == OBJECT) {
-    fclose(fh);
-    return 0;
-  }
-
-  /* List of verbs */
-  if (mode == SUMMARY)
-    printf("Verbs: %d\n", nprogs);
-  for (i = 1; i <= nprogs; i++) {
-    parse_verb(fh);
-  }
-  if (mode == VERB) {
-    fclose(fh);
-    return 0;
-  }
-  
-  /* Normally there are 0 clocks (this whole section is obsolete) */
-  read_int(clocks, fh);
-  if (mode == CLOCKS)
-    printf("Clocks: %d\n", clocks);
-  for (i = 1; i <= clocks; i++) {
-    lineptr = read_big_str(fh);
-    if (mode == CLOCKS)
-      printf("%s\n", lineptr);
+
+    /* Save the filename into a global variable so that other functions can reopen it for deeper data. */
+    databasename = (char *) malloc(sizeof(char) * (strlen(argv[1]) + 1));
+    if (!databasename) {
+	//printf("Unable to allocate %u bytes of memory. (main: databasename)\n", sizeof(char) * (strlen(argv[1])+1));
+	cout << "Unable to allocate " << sizeof(char) * (strlen(argv[1]) +
+							 1) <<
+	    " bytes of memory. (main: databasename)\n";
+	exit(1);
+    }
+    strcpy(databasename, argv[1]);
+
+    /* Open file for input */
+    fh = openfile(databasename);
+
+    /* Parse the intro section */
+    parse_intro(&lineptr, &nobjs, &nprogs, &dummy, &nusers, fh);
+    if (mode == SUMMARY)
+	printf("%s\n", lineptr);
     free(lineptr);
     lineptr = NULL;
-  }
-  if (mode == CLOCKS) {
+
+    /* List of players */
+    if (mode == PLAYERS || mode == SUMMARY)
+	printf("Players: %d\n", nusers);
+    for (i = 1; i <= nusers; i++) {
+	read_int(user, fh);
+	if (mode == PLAYERS)
+	    printf("#%d\n", user);
+    }
+    if (mode == PLAYERS) {
+	fclose(fh);
+	return 0;
+    }
+
+    /* List of objects */
+    if (mode == OBJECTS || mode == SUMMARY)
+	printf("Objects: %d\n", nobjs);
+    for (i = 1; i <= nobjs; i++) {
+	parse_obj(fh);
+    }
+    if (mode == OBJECTS || mode == PROP || mode == OBJECT) {
+	fclose(fh);
+	return 0;
+    }
+
+    /* List of verbs */
+    if (mode == SUMMARY)
+	printf("Verbs: %d\n", nprogs);
+    for (i = 1; i <= nprogs; i++) {
+	parse_verb(fh);
+    }
+    if (mode == VERB) {
+	fclose(fh);
+	return 0;
+    }
+
+    /* Normally there are 0 clocks (this whole section is obsolete) */
+    read_int(clocks, fh);
+    if (mode == CLOCKS)
+	printf("Clocks: %d\n", clocks);
+    for (i = 1; i <= clocks; i++) {
+	lineptr = read_big_str(fh);
+	if (mode == CLOCKS)
+	    printf("%s\n", lineptr);
+	free(lineptr);
+	lineptr = NULL;
+    }
+    if (mode == CLOCKS) {
+	fclose(fh);
+	return 0;
+    }
+
+    /*
+       The following three sections of the database don't interest me.
+       If they interest you, feel free to implement them.  -- Neil, 2005
+     */
+
+    /* Queued tasks */
+    if (mode == QUEUEDTASKS)
+	printf
+	    ("Reporting of queued tasks has not been implemented yet.\n");
+    /* Suspended tasks */
+    if (mode == SUSPENDEDTASKS)
+	printf
+	    ("Reporting of suspended tasks has not been implemented yet.\n");
+    /* Connections */
+    if (mode == CONNECTIONS)
+	printf("Reporting of connections has not been implemented yet.\n");
+
     fclose(fh);
     return 0;
-  }
-
-  /*
-  The following three sections of the database don't interest me.
-  If they interest you, feel free to implement them.  -- Neil, 2005
-  */
-
-  /* Queued tasks */
-  if (mode == QUEUEDTASKS)
-    printf("Reporting of queued tasks has not been implemented yet.\n");
-  /* Suspended tasks */
-  if (mode == SUSPENDEDTASKS)
-    printf("Reporting of suspended tasks has not been implemented yet.\n");
-  /* Connections */
-  if (mode == CONNECTIONS)
-    printf("Reporting of connections has not been implemented yet.\n");
-
-  fclose(fh);
-  return 0;
 }
diff --git a/server/unparse.c b/server/unparse.c
index f8ecea7..6fb624f 100644
--- a/server/unparse.c
+++ b/server/unparse.c
@@ -122,8 +122,7 @@ struct prec {
     int precedence;
 };
 
-static struct prec prec_table[] =
-{
+static struct prec prec_table[] = {
     {EXPR_ASGN, 1},
 
     {EXPR_COND, 2},		/* the unparser for this depends on only ASGN having
@@ -171,8 +170,7 @@ struct binop {
     const char *string;
 };
 
-static struct binop binop_table[] =
-{
+static struct binop binop_table[] = {
     {EXPR_IN, " in "},
     {EXPR_OR, " || "},
     {EXPR_AND, " && "},
@@ -234,7 +232,8 @@ list_prg(Stmt * program, int p, int i)
 static void
 bracket_lt(Stream * str, enum Expr_Kind parent, Expr * child)
 {
-    if ((fully_parenthesize && expr_prec[child->kind] < expr_prec[EXPR_PROP])
+    if ((fully_parenthesize
+	 && expr_prec[child->kind] < expr_prec[EXPR_PROP])
 	|| expr_prec[parent] > expr_prec[child->kind]) {
 	stream_add_char(str, '(');
 	unparse_expr(str, child);
@@ -247,7 +246,8 @@ bracket_lt(Stream * str, enum Expr_Kind parent, Expr * child)
 static void
 bracket_le(Stream * str, enum Expr_Kind parent, Expr * child)
 {
-    if ((fully_parenthesize && expr_prec[child->kind] < expr_prec[EXPR_PROP])
+    if ((fully_parenthesize
+	 && expr_prec[child->kind] < expr_prec[EXPR_PROP])
 	|| expr_prec[parent] >= expr_prec[child->kind]) {
 	stream_add_char(str, '(');
 	unparse_expr(str, child);
@@ -712,14 +712,14 @@ unparse_program(Program * p, Unparser_Receiver r, void *data,
 static void
 print_line(void *data, const char *line)
 {
-  FILE *fp = (FILE *) data;
+    FILE *fp = (FILE *) data;
 
     fprintf(fp, "%s\n", line);
 }
 
 void
-unparse_to_file(FILE * fp, Program * p, int fully_parenthesize, int indent_lines,
-		int f_index)
+unparse_to_file(FILE * fp, Program * p, int fully_parenthesize,
+		int indent_lines, int f_index)
 {
     unparse_program(p, print_line, fp, fully_parenthesize, indent_lines,
 		    f_index);
@@ -732,7 +732,8 @@ unparse_to_stderr(Program * p, int fully_parenthesize, int indent_lines,
     unparse_to_file(stderr, p, fully_parenthesize, indent_lines, f_index);
 }
 
-char rcsid_unparse[] = "$Id: unparse.c,v 1.3 1998-12-14 13:19:12 nop Exp $";
+char rcsid_unparse[] =
+    "$Id: unparse.c,v 1.3 1998-12-14 13:19:12 nop Exp $";
 
 /* 
  * $Log: not supported by cvs2svn $
diff --git a/server/utils.c b/server/utils.c
index 7fbedae..9758324 100644
--- a/server/utils.c
+++ b/server/utils.c
@@ -40,22 +40,22 @@
  */
 
 static const char cmap[] =
-"\000\001\002\003\004\005\006\007\010\011\012\013\014\015\016\017"
-"\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037"
-"\040\041\042\043\044\045\046\047\050\051\052\053\054\055\056\057"
-"\060\061\062\063\064\065\066\067\070\071\072\073\074\075\076\077"
-"\100\141\142\143\144\145\146\147\150\151\152\153\154\155\156\157"
-"\160\161\162\163\164\165\166\167\170\171\172\133\134\135\136\137"
-"\140\141\142\143\144\145\146\147\150\151\152\153\154\155\156\157"
-"\160\161\162\163\164\165\166\167\170\171\172\173\174\175\176\177"
-"\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217"
-"\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237"
-"\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257"
-"\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277"
-"\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317"
-"\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337"
-"\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357"
-"\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377";
+    "\000\001\002\003\004\005\006\007\010\011\012\013\014\015\016\017"
+    "\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037"
+    "\040\041\042\043\044\045\046\047\050\051\052\053\054\055\056\057"
+    "\060\061\062\063\064\065\066\067\070\071\072\073\074\075\076\077"
+    "\100\141\142\143\144\145\146\147\150\151\152\153\154\155\156\157"
+    "\160\161\162\163\164\165\166\167\170\171\172\133\134\135\136\137"
+    "\140\141\142\143\144\145\146\147\150\151\152\153\154\155\156\157"
+    "\160\161\162\163\164\165\166\167\170\171\172\173\174\175\176\177"
+    "\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217"
+    "\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237"
+    "\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257"
+    "\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277"
+    "\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317"
+    "\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337"
+    "\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357"
+    "\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377";
 
 int
 mystrcasecmp(const char *ss, const char *tt)
@@ -149,7 +149,8 @@ complex_free_var(Var v)
 	if (delref(v.v.list) == 0) {
 	    Var *pv;
 
-	    for (i = v.v.list[0].v.num, pv = v.v.list + 1; i > 0; i--, pv++)
+	    for (i = v.v.list[0].v.num, pv = v.v.list + 1; i > 0;
+		 i--, pv++)
 		free_var(*pv);
 	    myfree(v.v.list, M_LIST);
 	}
@@ -261,7 +262,8 @@ equality(Var lhs, Var rhs, int case_matters)
 		    return 1;
 		}
 		for (i = 1; i <= lhs.v.list[0].v.num; i++) {
-		    if (!equality(lhs.v.list[i], rhs.v.list[i], case_matters))
+		    if (!equality
+			(lhs.v.list[i], rhs.v.list[i], case_matters))
 			return 0;
 		}
 		return 1;
@@ -274,7 +276,8 @@ equality(Var lhs, Var rhs, int case_matters)
 }
 
 char *
-strsub(const char *source, const char *what, const char *with, int case_counts)
+strsub(const char *source, const char *what, const char *with,
+       int case_counts)
 {
     static Stream *str = 0;
     int lwhat = strlen(what);
diff --git a/server/verbs.c b/server/verbs.c
index d2b9632..96d296b 100644
--- a/server/verbs.c
+++ b/server/verbs.c
@@ -41,7 +41,7 @@ struct verb_data {
 static int
 add_to_list(void *data, const char *verb_name)
 {
-  struct verb_data *d = (verb_data *) data;
+    struct verb_data *d = (verb_data *) data;
 
     d->i++;
     d->r.v.list[d->i].type = (var_type) TYPE_STR;
@@ -73,15 +73,15 @@ bf_verbs(Var arglist, Byte next, void *vdata, Objid progr)
 }
 
 static enum error
-validate_verb_info(Var v, Objid * owner, unsigned *flags, const char **names)
+validate_verb_info(Var v, Objid * owner, unsigned *flags,
+		   const char **names)
 {
     const char *s;
 
     if (!(v.type == TYPE_LIST
 	  && v.v.list[0].v.num == 3
 	  && v.v.list[1].type == TYPE_OBJ
-	  && v.v.list[2].type == TYPE_STR
-	  && v.v.list[3].type == TYPE_STR))
+	  && v.v.list[2].type == TYPE_STR && v.v.list[3].type == TYPE_STR))
 	return E_TYPE;
 
     *owner = v.v.list[1].v.obj;
@@ -158,8 +158,7 @@ validate_verb_args(Var v, db_arg_spec * dobj, db_prep_spec * prep,
     if (!(v.type == TYPE_LIST
 	  && v.v.list[0].v.num == 3
 	  && v.v.list[1].type == TYPE_STR
-	  && v.v.list[2].type == TYPE_STR
-	  && v.v.list[3].type == TYPE_STR))
+	  && v.v.list[2].type == TYPE_STR && v.v.list[3].type == TYPE_STR))
 	return E_TYPE;
 
     if (!match_arg_spec(v.v.list[1].v.str, dobj)
@@ -197,7 +196,8 @@ bf_add_verb(Var arglist, Byte next, void *vdata, Objid progr)
 	e = E_PERM;
     } else {
 	result.type = TYPE_INT;
-	result.v.num = db_add_verb(oid, names, owner, flags, dobj, prep, iobj);
+	result.v.num =
+	    db_add_verb(oid, names, owner, flags, dobj, prep, iobj);
     }
 
     free_var(arglist);
@@ -501,7 +501,8 @@ bf_set_verb_code(Var arglist, Byte next, void *vdata, Objid progr)
     if (!h.ptr) {
 	free_var(arglist);
 	return make_error_pack(E_VERBNF);
-    } else if (!is_programmer(progr) || !db_verb_allows(h, progr, VF_WRITE)) {
+    } else if (!is_programmer(progr)
+	       || !db_verb_allows(h, progr, VF_WRITE)) {
 	free_var(arglist);
 	return make_error_pack(E_PERM);
     }
@@ -572,11 +573,12 @@ register_verbs(void)
 		      TYPE_OBJ, TYPE_ANY, TYPE_LIST);
     register_function("add_verb", 3, 3, bf_add_verb,
 		      TYPE_OBJ, TYPE_LIST, TYPE_LIST);
-    register_function("delete_verb", 2, 2, bf_delete_verb, TYPE_OBJ, TYPE_ANY);
-    register_function("verb_code", 2, 4, bf_verb_code,
-		      TYPE_OBJ, TYPE_ANY, TYPE_ANY, TYPE_ANY);
-    register_function("set_verb_code", 3, 3, bf_set_verb_code,
-		      TYPE_OBJ, TYPE_ANY, TYPE_LIST);
+    register_function("delete_verb", 2, 2, bf_delete_verb, TYPE_OBJ,
+		      TYPE_ANY);
+    register_function("verb_code", 2, 4, bf_verb_code, TYPE_OBJ, TYPE_ANY,
+		      TYPE_ANY, TYPE_ANY);
+    register_function("set_verb_code", 3, 3, bf_set_verb_code, TYPE_OBJ,
+		      TYPE_ANY, TYPE_LIST);
     register_function("eval", 1, 1, bf_eval, TYPE_STR);
 }
 
diff --git a/server/version.c b/server/version.c
index 03b3424..857a6e0 100644
--- a/server/version.c
+++ b/server/version.c
@@ -48,4 +48,5 @@ check_version(DB_Version version)
     return version < Num_DB_Versions;
 }
 
-char rcsid_version[] = "$Id: version.c,v 1.12 2006-11-03 01:57:07 pschwan Exp $";
+char rcsid_version[] =
+    "$Id: version.c,v 1.12 2006-11-03 01:57:07 pschwan Exp $";
-- 
1.7.9.5

